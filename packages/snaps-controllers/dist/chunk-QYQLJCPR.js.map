{"version":3,"sources":["../src/insights/SnapInsightsController.ts"],"names":[],"mappings":"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","sourcesContent":["import type { RestrictedControllerMessenger } from '@metamask/base-controller';\nimport { BaseController } from '@metamask/base-controller';\nimport type {\n  Caveat,\n  GetPermissions,\n  ValidPermission,\n} from '@metamask/permission-controller';\nimport {\n  getSignatureOriginCaveat,\n  getTransactionOriginCaveat,\n  SnapEndowments,\n} from '@metamask/snaps-rpc-methods';\nimport type { Json, SnapId } from '@metamask/snaps-sdk';\nimport { HandlerType } from '@metamask/snaps-utils';\nimport { hasProperty } from '@metamask/utils';\n\nimport type { DeleteInterface } from '../interface';\nimport type { GetAllSnaps, HandleSnapRequest } from '../snaps';\nimport { getRunnableSnaps } from '../snaps';\nimport type {\n  TransactionControllerUnapprovedTransactionAddedEvent,\n  TransactionMeta,\n  SignatureStateChange,\n  SignatureControllerState,\n  StateSignature,\n  TransactionControllerTransactionStatusUpdatedEvent,\n} from '../types';\n\nconst controllerName = 'SnapInsightsController';\n\nexport type SnapInsightsControllerAllowedActions =\n  | HandleSnapRequest\n  | GetAllSnaps\n  | GetPermissions\n  | DeleteInterface;\n\nexport type SnapInsightsControllerActions = never;\n\nexport type SnapInsightsControllerAllowedEvents =\n  | TransactionControllerUnapprovedTransactionAddedEvent\n  | TransactionControllerTransactionStatusUpdatedEvent\n  | SignatureStateChange;\n\nexport type SnapInsightsControllerMessenger = RestrictedControllerMessenger<\n  typeof controllerName,\n  SnapInsightsControllerActions | SnapInsightsControllerAllowedActions,\n  SnapInsightsControllerAllowedEvents,\n  SnapInsightsControllerAllowedActions['type'],\n  SnapInsightsControllerAllowedEvents['type']\n>;\n\nexport type SnapInsight = {\n  snapId: SnapId;\n  interfaceId?: string | null;\n  error?: string;\n  loading: boolean;\n};\n\nexport type SnapInsightsControllerState = {\n  insights: Record<string, Record<SnapId, SnapInsight>>;\n};\n\nexport type SnapInsightsControllerArgs = {\n  messenger: SnapInsightsControllerMessenger;\n  state?: SnapInsightsControllerState;\n};\n\ntype SnapWithPermission = {\n  snapId: SnapId;\n  permission: ValidPermission<string, Caveat<string, Json>>;\n};\n\n/**\n * Controller for monitoring for new transactions and signatures to provide insight for.\n */\nexport class SnapInsightsController extends BaseController<\n  typeof controllerName,\n  SnapInsightsControllerState,\n  SnapInsightsControllerMessenger\n> {\n  constructor({ messenger, state }: SnapInsightsControllerArgs) {\n    super({\n      messenger,\n      metadata: {\n        insights: { persist: false, anonymous: false },\n      },\n      name: controllerName,\n      state: { insights: {}, ...state },\n    });\n\n    this.messagingSystem.subscribe(\n      'TransactionController:unapprovedTransactionAdded',\n      this.#handleTransaction.bind(this),\n    );\n\n    this.messagingSystem.subscribe(\n      'TransactionController:transactionStatusUpdated',\n      this.#handleTransactionStatusUpdate.bind(this),\n    );\n\n    this.messagingSystem.subscribe(\n      'SignatureController:stateChange',\n      this.#handleSignatureStateChange.bind(this),\n    );\n  }\n\n  /**\n   * Check if an insight already exists for a given ID.\n   *\n   * @param id - The ID.\n   * @returns True if the insight already exists, otherwise false.\n   */\n  #hasInsight(id: string) {\n    return hasProperty(this.state.insights, id);\n  }\n\n  /**\n   * Get a list of runnable Snaps that have a given permission.\n   * Also includes the permission object itself.\n   *\n   * @param permissionName - The permission name.\n   * @returns A list of objects containing Snap IDs and the permission object.\n   */\n  #getSnapsWithPermission(permissionName: string) {\n    const allSnaps = this.messagingSystem.call('SnapController:getAll');\n    const filteredSnaps = getRunnableSnaps(allSnaps);\n\n    return filteredSnaps.reduce<SnapWithPermission[]>((accumulator, snap) => {\n      const permissions = this.messagingSystem.call(\n        'PermissionController:getPermissions',\n        snap.id,\n      );\n      if (permissions && hasProperty(permissions, permissionName)) {\n        accumulator.push({\n          snapId: snap.id,\n          permission: permissions[permissionName],\n        });\n      }\n\n      return accumulator;\n    }, []);\n  }\n\n  /**\n   * Handle a newly added unapproved transaction.\n   * This function fetches insights from all available Snaps\n   * and populates the insights state blob with the responses.\n   *\n   * @param transaction - The transaction object.\n   */\n  #handleTransaction(transaction: TransactionMeta) {\n    const { id, txParams, chainId, origin } = transaction;\n\n    // This assumes that the transactions are EVM-compatible for now.\n    const caipChainId = `eip155:${parseInt(chainId, 16)}`;\n\n    const snaps = this.#getSnapsWithPermission(\n      SnapEndowments.TransactionInsight,\n    );\n\n    snaps.forEach(({ snapId, permission }) => {\n      const hasTransactionOriginCaveat = getTransactionOriginCaveat(permission);\n      const transactionOrigin =\n        hasTransactionOriginCaveat && origin ? origin : null;\n\n      this.update((state) => {\n        state.insights[id] ??= {};\n        state.insights[id][snapId] = { snapId, loading: true };\n      });\n\n      this.#handleSnapRequest({\n        snapId,\n        handler: HandlerType.OnTransaction,\n        params: {\n          transaction: txParams,\n          chainId: caipChainId,\n          transactionOrigin,\n        },\n      })\n        .then((response) =>\n          this.#handleSnapResponse({\n            id,\n            snapId,\n            response: response as Record<string, Json>,\n          }),\n        )\n        .catch((error) => this.#handleSnapResponse({ id, snapId, error }));\n    });\n  }\n\n  /**\n   * Handle the stateChange event emitted by the SignatureController.\n   * This function will remove existing insights from the state when applicable, as well as\n   * trigger insight fetching for newly added signatures.\n   *\n   * @param state - The SignatureController state blob.\n   */\n  #handleSignatureStateChange(state: SignatureControllerState) {\n    // If any IDs have disappeared since the last state update, the insight may be cleaned up.\n    for (const id of Object.keys(this.state.insights)) {\n      if (\n        !hasProperty(state.unapprovedTypedMessages, id) &&\n        !hasProperty(state.unapprovedPersonalMsgs, id)\n      ) {\n        this.#handleInsightCleanup(id);\n      }\n    }\n\n    if (\n      state.unapprovedPersonalMsgCount > 0 ||\n      state.unapprovedTypedMessagesCount > 0\n    ) {\n      const snaps = this.#getSnapsWithPermission(\n        SnapEndowments.SignatureInsight,\n      );\n\n      // This isn't very efficient, but SignatureController doesn't expose a better event for us to use yet.\n      for (const personalSignature of Object.values(\n        state.unapprovedPersonalMsgs,\n      )) {\n        this.#handleSignature(snaps, personalSignature);\n      }\n\n      for (const typedMessage of Object.values(state.unapprovedTypedMessages)) {\n        this.#handleSignature(snaps, typedMessage);\n      }\n    }\n  }\n\n  /**\n   * Handle a newly added unapproved signature.\n   * This function fetches insights from all available Snaps\n   * and populates the insights state blob with the responses.\n   *\n   * @param snaps - A list of Snaps to invoke.\n   * @param signature - The signature object.\n   */\n  #handleSignature(snaps: SnapWithPermission[], signature: StateSignature) {\n    const { id, msgParams } = signature;\n\n    if (this.#hasInsight(id)) {\n      return;\n    }\n\n    const { from, data, signatureMethod, origin } = msgParams;\n\n    /**\n     * Both eth_signTypedData_v3 and eth_signTypedData_v4 methods\n     * need to be parsed because their data is stringified. All other\n     * signature methods do not, so they are ignored.\n     */\n    const shouldParse =\n      signatureMethod === 'eth_signTypedData_v3' ||\n      signatureMethod === 'eth_signTypedData_v4';\n\n    const payload = {\n      from,\n      data: shouldParse ? JSON.parse(data as string) : data,\n      signatureMethod,\n    };\n\n    snaps.forEach(({ snapId, permission }) => {\n      const hasSignatureOriginCaveat = getSignatureOriginCaveat(permission);\n      const signatureOrigin =\n        origin && hasSignatureOriginCaveat ? origin : null;\n\n      this.update((state) => {\n        state.insights[id] ??= {};\n        state.insights[id][snapId] = { snapId, loading: true };\n      });\n\n      this.#handleSnapRequest({\n        snapId,\n        handler: HandlerType.OnSignature,\n        params: { signature: payload, signatureOrigin },\n      })\n        .then((response) =>\n          this.#handleSnapResponse({\n            id,\n            snapId,\n            response: response as Record<string, Json>,\n          }),\n        )\n        .catch((error) => this.#handleSnapResponse({ id, snapId, error }));\n    });\n  }\n\n  /**\n   * Handle the transactionStatusUpdated event emitted by the TransactionController.\n   * This function will remove insights for the transaction in question\n   * once the transaction status has changed from unapproved.\n   *\n   * @param args - An options bag.\n   * @param args.transactionMeta - The transaction.\n   */\n  #handleTransactionStatusUpdate({\n    transactionMeta,\n  }: {\n    transactionMeta: TransactionMeta;\n  }) {\n    if (transactionMeta.status !== 'unapproved') {\n      this.#handleInsightCleanup(transactionMeta.id);\n    }\n  }\n\n  #handleInsightCleanup(id: string) {\n    if (!this.#hasInsight(id)) {\n      return;\n    }\n\n    // Delete interfaces from interface controller.\n    Object.values(this.state.insights[id])\n      .filter((insight) => insight.interfaceId)\n      .forEach((insight) => {\n        this.messagingSystem.call(\n          'SnapInterfaceController:deleteInterface',\n          insight.interfaceId as string,\n        );\n      });\n\n    this.update((state) => {\n      delete state.insights[id];\n    });\n  }\n\n  /**\n   * Handle sending a request to a given Snap with a given payload.\n   *\n   * @param args - An options bag.\n   * @param args.snapId - The Snap ID.\n   * @param args.handler - The handler to invoke.\n   * @param args.params - The JSON-RPC params to send.\n   * @returns The response from the Snap.\n   */\n  async #handleSnapRequest({\n    snapId,\n    handler,\n    params,\n  }: {\n    snapId: SnapId;\n    handler: HandlerType.OnTransaction | HandlerType.OnSignature;\n    params: Record<string, Json>;\n  }) {\n    return this.messagingSystem.call('SnapController:handleRequest', {\n      snapId,\n      origin: '',\n      handler,\n      request: {\n        method: '',\n        params,\n      },\n    });\n  }\n\n  /**\n   * Handle response from a given Snap by persisting the response or error in state.\n   *\n   * @param args - An options bag.\n   * @param args.id - The transaction or signature ID.\n   * @param args.snapId - The Snap ID.\n   * @param args.response - An optional response object returned by the Snap.\n   * @param args.error - An optional error returned by the Snap.\n   */\n  #handleSnapResponse({\n    id,\n    snapId,\n    response,\n    error,\n  }: {\n    id: string;\n    snapId: SnapId;\n    response?: Record<string, Json>;\n    error?: Error;\n  }) {\n    this.update((state) => {\n      state.insights[id][snapId].loading = false;\n      state.insights[id][snapId].interfaceId = response?.id as string;\n      state.insights[id][snapId].error = error?.message;\n    });\n  }\n}\n"]}