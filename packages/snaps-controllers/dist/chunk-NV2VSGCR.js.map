{"version":3,"sources":["../src/services/proxy/ProxyExecutionService.ts"],"names":[],"mappings":";;;;;;;;;;;;;AACA,SAAS,cAAc;AADvB;AAcO,IAAM,wBAAN,cAAoC,yBAAiC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAc1E,YAAY;AAAA,IACV;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAAyC;AACvC,UAAM;AAAA,MACJ;AAAA,MACA;AAAA,MACA,SAAS;AAAA,IACX,CAAC;AAtBH,uBAAS,SAAT;AAwBE,uBAAK,SAAU;AAAA,EACjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAgB,aAAa,KAA+B;AAG1D,uBAAK,SAAQ,MAAM;AAAA,MACjB,OAAO,IAAI;AAAA,MACX,MAAM;AAAA,QACJ,SAAS;AAAA,QACT,QAAQ;AAAA,QACR,IAAI,OAAO;AAAA,MACb;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAgB,cAAc,OAAe;AAC3C,UAAM,SAAS,IAAI,uBAAuB;AAAA,MACxC,QAAQ,mBAAK;AAAA,MACb;AAAA,IACF,CAAC;AAMD,UAAM,IAAI,QAAQ,CAAC,YAAY;AAC7B,aAAO,KAAK,QAAQ,OAAO;AAC3B,aAAO,MAAM;AAAA,QACX,MAAM;AAAA,QACN,MAAM,EAAE,SAAS,OAAO,QAAQ,QAAQ,IAAI,OAAO,EAAE;AAAA,MACvD,CAAC;AAAA,IACH,CAAC;AAED,WAAO,EAAE,QAAQ,OAAO,OAAO;AAAA,EACjC;AACF;AAvEW","sourcesContent":["import type { BasePostMessageStream } from '@metamask/post-message-stream';\nimport { nanoid } from 'nanoid';\n\nimport type {\n  ExecutionServiceArgs,\n  TerminateJobArgs,\n} from '../AbstractExecutionService';\nimport { AbstractExecutionService } from '../AbstractExecutionService';\nimport { ProxyPostMessageStream } from '../ProxyPostMessageStream';\n\ntype ProxyExecutionEnvironmentServiceArgs = {\n  stream: BasePostMessageStream;\n} & ExecutionServiceArgs;\n\nexport class ProxyExecutionService extends AbstractExecutionService<string> {\n  readonly #stream: BasePostMessageStream;\n\n  /**\n   * Create a new proxy execution service.\n   *\n   * @param args - The constructor arguments.\n   * @param args.messenger - The messenger to use for communication with the\n   * `SnapController`.\n   * @param args.setupSnapProvider - The function to use to set up the snap\n   * provider.\n   * @param args.stream - The stream to use for communicating with the proxy\n   * executor.\n   */\n  constructor({\n    stream,\n    messenger,\n    setupSnapProvider,\n  }: ProxyExecutionEnvironmentServiceArgs) {\n    super({\n      messenger,\n      setupSnapProvider,\n      usePing: false,\n    });\n\n    this.#stream = stream;\n  }\n\n  /**\n   * Send a termination command to the proxy stream.\n   *\n   * @param job - The job to terminate.\n   */\n  protected async terminateJob(job: TerminateJobArgs<string>) {\n    // The `AbstractExecutionService` will have already closed the job stream,\n    // so we write to the runtime stream directly.\n    this.#stream.write({\n      jobId: job.id,\n      data: {\n        jsonrpc: '2.0',\n        method: 'terminateJob',\n        id: nanoid(),\n      },\n    });\n  }\n\n  /**\n   * Create a new stream for the specified job. This wraps the root stream\n   * in a stream specific to the job.\n   *\n   * @param jobId - The job ID.\n   */\n  protected async initEnvStream(jobId: string) {\n    const stream = new ProxyPostMessageStream({\n      stream: this.#stream,\n      jobId,\n    });\n\n    // Send a request and await any response before continuing\n    // This simulates the behaviour of non-proxy environments by effectively awaiting\n    // the load of the environment inside the proxy environment\n    // This assumes the proxy environment is already loaded before this function is called\n    await new Promise((resolve) => {\n      stream.once('data', resolve);\n      stream.write({\n        name: 'command',\n        data: { jsonrpc: '2.0', method: 'ping', id: nanoid() },\n      });\n    });\n\n    return { worker: jobId, stream };\n  }\n}\n"]}