{"version":3,"sources":["../src/interface/utils.ts"],"sourcesContent":["import { assert } from '@metamask/snaps-sdk';\nimport type {\n  FormState,\n  InterfaceState,\n  ComponentOrElement,\n  InterfaceContext,\n  State,\n} from '@metamask/snaps-sdk';\nimport type {\n  DropdownElement,\n  InputElement,\n  JSXElement,\n  OptionElement,\n  FileInputElement,\n  CheckboxElement,\n} from '@metamask/snaps-sdk/jsx';\nimport { isJSXElementUnsafe } from '@metamask/snaps-sdk/jsx';\nimport {\n  getJsonSizeUnsafe,\n  getJsxChildren,\n  getJsxElementFromComponent,\n  walkJsx,\n} from '@metamask/snaps-utils';\n\n/**\n * Get a JSX element from a component or JSX element. If the component is a\n * JSX element, it is returned as is. Otherwise, the component is converted to\n * a JSX element.\n *\n * @param component - The component to convert.\n * @returns The JSX element.\n */\nexport function getJsxInterface(component: ComponentOrElement): JSXElement {\n  if (isJSXElementUnsafe(component)) {\n    return component;\n  }\n\n  return getJsxElementFromComponent(component);\n}\n\n/**\n * Assert that the component name is unique in state.\n *\n * @param state - The interface state to verify against.\n * @param name - The component name to verify.\n */\nexport function assertNameIsUnique(state: InterfaceState, name: string) {\n  assert(\n    state[name] === undefined,\n    `Duplicate component names are not allowed, found multiple instances of: \"${name}\".`,\n  );\n}\n\n/**\n * Construct default state for a component.\n *\n * This function is meant to be used inside constructInputState to account\n * for component specific defaults and will not override the component value or existing form state.\n *\n * @param element - The input element.\n * @returns The default state for the specific component, if any.\n */\nfunction constructComponentSpecificDefaultState(\n  element: InputElement | DropdownElement | CheckboxElement,\n) {\n  switch (element.type) {\n    case 'Dropdown': {\n      const children = getJsxChildren(element) as OptionElement[];\n      return children[0]?.props.value;\n    }\n\n    case 'Checkbox':\n      return false;\n\n    default:\n      return null;\n  }\n}\n\n/**\n * Get the state value for a stateful component.\n *\n * Most components store the state value as a `value` prop.\n * This function exists to account for components where that isn't the case.\n *\n * @param element - The input element.\n * @returns The state value for a given component.\n */\nfunction getComponentStateValue(\n  element: InputElement | DropdownElement | CheckboxElement,\n) {\n  switch (element.type) {\n    case 'Checkbox':\n      return element.props.checked;\n\n    default:\n      return element.props.value;\n  }\n}\n\n/**\n * Construct the state for an input field.\n *\n * @param oldState - The previous state.\n * @param element - The input element.\n * @param form - An optional form that the input is enclosed in.\n * @returns The input state.\n */\nfunction constructInputState(\n  oldState: InterfaceState,\n  element: InputElement | DropdownElement | FileInputElement | CheckboxElement,\n  form?: string,\n) {\n  const oldStateUnwrapped = form ? (oldState[form] as FormState) : oldState;\n  const oldInputState = oldStateUnwrapped?.[element.props.name] as State;\n\n  if (element.type === 'FileInput') {\n    return oldInputState ?? null;\n  }\n\n  return (\n    getComponentStateValue(element) ??\n    oldInputState ??\n    constructComponentSpecificDefaultState(element) ??\n    null\n  );\n}\n\n/**\n * Construct the interface state for a given component tree.\n *\n * @param oldState - The previous state.\n * @param rootComponent - The UI component to construct state from.\n * @returns The interface state of the passed component.\n */\nexport function constructState(\n  oldState: InterfaceState,\n  rootComponent: JSXElement,\n): InterfaceState {\n  const newState: InterfaceState = {};\n\n  // Stack containing the forms we have visited and at which depth\n  const formStack: { name: string; depth: number }[] = [];\n\n  walkJsx(rootComponent, (component, depth) => {\n    let currentForm = formStack[formStack.length - 1];\n\n    // Pop the current form of the stack once we leave its depth.\n    if (currentForm && depth <= currentForm.depth) {\n      formStack.pop();\n      currentForm = formStack[formStack.length - 1];\n    }\n\n    if (component.type === 'Form') {\n      assertNameIsUnique(newState, component.props.name);\n      formStack.push({ name: component.props.name, depth });\n      newState[component.props.name] = {};\n      return;\n    }\n\n    // Stateful components inside a form\n    if (\n      currentForm &&\n      (component.type === 'Input' ||\n        component.type === 'Dropdown' ||\n        component.type === 'FileInput' ||\n        component.type === 'Checkbox')\n    ) {\n      const formState = newState[currentForm.name] as FormState;\n      assertNameIsUnique(formState, component.props.name);\n      formState[component.props.name] = constructInputState(\n        oldState,\n        component,\n        currentForm.name,\n      );\n      return;\n    }\n\n    // Stateful components outside a form\n    if (\n      component.type === 'Input' ||\n      component.type === 'Dropdown' ||\n      component.type === 'FileInput' ||\n      component.type === 'Checkbox'\n    ) {\n      assertNameIsUnique(newState, component.props.name);\n      newState[component.props.name] = constructInputState(oldState, component);\n    }\n  });\n\n  return newState;\n}\n\nconst MAX_CONTEXT_SIZE = 1_000_000; // 1 mb\n\n/**\n * Validate a JSON blob to be used as the interface context.\n *\n * @param context - The JSON blob.\n * @throws If the JSON blob is too large.\n */\nexport function validateInterfaceContext(context?: InterfaceContext) {\n  if (!context) {\n    return;\n  }\n\n  // We assume the validity of this JSON to be validated by the caller.\n  // E.g., in the RPC method implementation.\n  const size = getJsonSizeUnsafe(context);\n  assert(\n    size <= MAX_CONTEXT_SIZE,\n    `A Snap interface context may not be larger than ${\n      MAX_CONTEXT_SIZE / 1000000\n    } MB.`,\n  );\n}\n"],"mappings":";AAAA,SAAS,cAAc;AAgBvB,SAAS,0BAA0B;AACnC;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAUA,SAAS,gBAAgB,WAA2C;AACzE,MAAI,mBAAmB,SAAS,GAAG;AACjC,WAAO;AAAA,EACT;AAEA,SAAO,2BAA2B,SAAS;AAC7C;AAQO,SAAS,mBAAmB,OAAuB,MAAc;AACtE;AAAA,IACE,MAAM,IAAI,MAAM;AAAA,IAChB,4EAA4E,IAAI;AAAA,EAClF;AACF;AAWA,SAAS,uCACP,SACA;AACA,UAAQ,QAAQ,MAAM;AAAA,IACpB,KAAK,YAAY;AACf,YAAM,WAAW,eAAe,OAAO;AACvC,aAAO,SAAS,CAAC,GAAG,MAAM;AAAA,IAC5B;AAAA,IAEA,KAAK;AACH,aAAO;AAAA,IAET;AACE,aAAO;AAAA,EACX;AACF;AAWA,SAAS,uBACP,SACA;AACA,UAAQ,QAAQ,MAAM;AAAA,IACpB,KAAK;AACH,aAAO,QAAQ,MAAM;AAAA,IAEvB;AACE,aAAO,QAAQ,MAAM;AAAA,EACzB;AACF;AAUA,SAAS,oBACP,UACA,SACA,MACA;AACA,QAAM,oBAAoB,OAAQ,SAAS,IAAI,IAAkB;AACjE,QAAM,gBAAgB,oBAAoB,QAAQ,MAAM,IAAI;AAE5D,MAAI,QAAQ,SAAS,aAAa;AAChC,WAAO,iBAAiB;AAAA,EAC1B;AAEA,SACE,uBAAuB,OAAO,KAC9B,iBACA,uCAAuC,OAAO,KAC9C;AAEJ;AASO,SAAS,eACd,UACA,eACgB;AAChB,QAAM,WAA2B,CAAC;AAGlC,QAAM,YAA+C,CAAC;AAEtD,UAAQ,eAAe,CAAC,WAAW,UAAU;AAC3C,QAAI,cAAc,UAAU,UAAU,SAAS,CAAC;AAGhD,QAAI,eAAe,SAAS,YAAY,OAAO;AAC7C,gBAAU,IAAI;AACd,oBAAc,UAAU,UAAU,SAAS,CAAC;AAAA,IAC9C;AAEA,QAAI,UAAU,SAAS,QAAQ;AAC7B,yBAAmB,UAAU,UAAU,MAAM,IAAI;AACjD,gBAAU,KAAK,EAAE,MAAM,UAAU,MAAM,MAAM,MAAM,CAAC;AACpD,eAAS,UAAU,MAAM,IAAI,IAAI,CAAC;AAClC;AAAA,IACF;AAGA,QACE,gBACC,UAAU,SAAS,WAClB,UAAU,SAAS,cACnB,UAAU,SAAS,eACnB,UAAU,SAAS,aACrB;AACA,YAAM,YAAY,SAAS,YAAY,IAAI;AAC3C,yBAAmB,WAAW,UAAU,MAAM,IAAI;AAClD,gBAAU,UAAU,MAAM,IAAI,IAAI;AAAA,QAChC;AAAA,QACA;AAAA,QACA,YAAY;AAAA,MACd;AACA;AAAA,IACF;AAGA,QACE,UAAU,SAAS,WACnB,UAAU,SAAS,cACnB,UAAU,SAAS,eACnB,UAAU,SAAS,YACnB;AACA,yBAAmB,UAAU,UAAU,MAAM,IAAI;AACjD,eAAS,UAAU,MAAM,IAAI,IAAI,oBAAoB,UAAU,SAAS;AAAA,IAC1E;AAAA,EACF,CAAC;AAED,SAAO;AACT;AAEA,IAAM,mBAAmB;AAQlB,SAAS,yBAAyB,SAA4B;AACnE,MAAI,CAAC,SAAS;AACZ;AAAA,EACF;AAIA,QAAM,OAAO,kBAAkB,OAAO;AACtC;AAAA,IACE,QAAQ;AAAA,IACR,mDACE,mBAAmB,GACrB;AAAA,EACF;AACF;","names":[]}