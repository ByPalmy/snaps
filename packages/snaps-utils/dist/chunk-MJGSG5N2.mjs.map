{"version":3,"sources":["../src/ui.tsx"],"sourcesContent":["import type { Component } from '@metamask/snaps-sdk';\nimport { NodeType } from '@metamask/snaps-sdk';\nimport type {\n  BoldChildren,\n  FieldElement,\n  ItalicChildren,\n  JSXElement,\n  LinkElement,\n  MaybeArray,\n  RowChildren,\n  StandardFormattingElement,\n  TextChildren,\n} from '@metamask/snaps-sdk/jsx';\nimport {\n  Italic,\n  Link,\n  Bold,\n  Row,\n  Text,\n  Field,\n  Image,\n  Input,\n  Heading,\n  Form,\n  Divider,\n  Spinner,\n  Copyable,\n  Box,\n  Button,\n  Address,\n} from '@metamask/snaps-sdk/jsx';\nimport {\n  assert,\n  assertExhaustive,\n  AssertionError,\n  hasProperty,\n  isPlainObject,\n} from '@metamask/utils';\nimport { lexer, walkTokens } from 'marked';\nimport type { Token, Tokens } from 'marked';\n\nconst MAX_TEXT_LENGTH = 50_000; // 50 kb\nconst ALLOWED_PROTOCOLS = ['https:', 'mailto:'];\n\n/**\n * Get the button variant from a legacy button component variant.\n *\n * @param variant - The legacy button component variant.\n * @returns The button variant.\n */\nfunction getButtonVariant(variant?: 'primary' | 'secondary' | undefined) {\n  switch (variant) {\n    case 'primary':\n      return 'primary';\n    case 'secondary':\n      return 'destructive';\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Get the children of a JSX element. If there is only one child, the child is\n * returned directly. Otherwise, the children are returned as an array.\n *\n * @param elements - The JSX elements.\n * @returns The child or children.\n */\nfunction getChildren<Type>(elements: Type[]) {\n  if (elements.length === 1) {\n    return elements[0];\n  }\n\n  return elements;\n}\n\n/**\n * Get the text of a link token.\n *\n * @param token - The link token.\n * @returns The text of the link token.\n */\nfunction getLinkText(token: Tokens.Link | Tokens.Generic) {\n  if (token.tokens && token.tokens.length > 0) {\n    return getChildren(token.tokens.flatMap(getTextChildFromToken));\n  }\n\n  return token.href;\n}\n\n/**\n * Get the text child from a list of markdown tokens.\n *\n * @param tokens - The markdown tokens.\n * @returns The text child.\n */\nfunction getTextChildFromTokens(tokens: Token[]) {\n  return getChildren(tokens.flatMap(getTextChildFromToken));\n}\n\n/**\n * Get the text child from a markdown token.\n *\n * @param token - The markdown token.\n * @returns The text child.\n */\nfunction getTextChildFromToken(token: Token): TextChildren {\n  switch (token.type) {\n    case 'link': {\n      return <Link href={token.href} children={getLinkText(token)} />;\n    }\n\n    case 'text':\n      return token.text;\n\n    case 'strong':\n      return (\n        <Bold>\n          {\n            getTextChildFromTokens(\n              // Due to the way `marked` is typed, `token.tokens` can be\n              // `undefined`, but it's a required field of `Tokens.Bold`, so we\n              // can safely cast it to `Token[]`.\n              token.tokens as Token[],\n            ) as BoldChildren\n          }\n        </Bold>\n      );\n\n    case 'em':\n      return (\n        <Italic>\n          {\n            getTextChildFromTokens(\n              // Due to the way `marked` is typed, `token.tokens` can be\n              // `undefined`, but it's a required field of `Tokens.Bold`, so we\n              // can safely cast it to `Token[]`.\n              token.tokens as Token[],\n            ) as ItalicChildren\n          }\n        </Italic>\n      );\n\n    default:\n      return null;\n  }\n}\n\n/**\n * Get all text children from a markdown string.\n *\n * @param value - The markdown string.\n * @returns The text children.\n */\nexport function getTextChildren(\n  value: string,\n): (string | StandardFormattingElement | LinkElement)[] {\n  const rootTokens = lexer(value, { gfm: false });\n  const children: TextChildren = [];\n\n  walkTokens(rootTokens, (token) => {\n    if (token.type === 'paragraph') {\n      if (children.length > 0) {\n        children.push('\\n\\n');\n      }\n\n      const { tokens } = token as Tokens.Paragraph;\n      children.push(...tokens.flatMap(getTextChildFromToken));\n    }\n  });\n\n  return children.filter((child) => child !== null) as (\n    | string\n    | StandardFormattingElement\n    | LinkElement\n  )[];\n}\n\n/**\n * Validate the text size of a component. The text size is the total length of\n * all text in the component.\n *\n * @param component - The component to validate.\n * @throws An error if the text size exceeds the maximum allowed size.\n */\nfunction validateComponentTextSize(component: Component) {\n  const textSize = getTotalTextLength(component);\n  assert(\n    textSize <= MAX_TEXT_LENGTH,\n    `The text in a Snap UI may not be larger than ${\n      MAX_TEXT_LENGTH / 1000\n    } kB.`,\n  );\n}\n\n/**\n * Get a JSX element from a legacy UI component. This supports all legacy UI\n * components, and maps them to their JSX equivalents where possible.\n *\n * This function validates the text size of the component, but does not validate\n * the total size. The total size of the component should be validated before\n * calling this function.\n *\n * @param legacyComponent - The legacy UI component.\n * @returns The JSX element.\n */\nexport function getJsxElementFromComponent(\n  legacyComponent: Component,\n): JSXElement {\n  validateComponentTextSize(legacyComponent);\n\n  /**\n   * Get the JSX element for a component. This function is recursive and will\n   * call itself for child components.\n   *\n   * @param component - The component to convert to a JSX element.\n   * @returns The JSX element.\n   */\n  function getElement(component: Component) {\n    switch (component.type) {\n      case NodeType.Address:\n        return <Address address={component.value} />;\n\n      case NodeType.Button:\n        return (\n          <Button\n            name={component.name}\n            variant={getButtonVariant(component.variant)}\n            type={component.buttonType}\n          >\n            {component.value}\n          </Button>\n        );\n\n      case NodeType.Copyable:\n        return (\n          <Copyable value={component.value} sensitive={component.sensitive} />\n        );\n\n      case NodeType.Divider:\n        return <Divider />;\n\n      case NodeType.Form:\n        return (\n          <Form name={component.name}>\n            {getChildren(component.children.map(getElement)) as FieldElement[]}\n          </Form>\n        );\n\n      case NodeType.Heading:\n        return <Heading children={component.value} />;\n\n      case NodeType.Image:\n        // `Image` supports `alt`, but the legacy `Image` component does not.\n        return <Image src={component.value} />;\n\n      case NodeType.Input:\n        return (\n          <Field label={component.label} error={component.error}>\n            <Input\n              name={component.name}\n              type={component.inputType}\n              value={component.value}\n              placeholder={component.placeholder}\n            />\n          </Field>\n        );\n\n      case NodeType.Panel:\n        // `Panel` is renamed to `Box` in JSX.\n        return (\n          <Box children={getChildren(component.children.map(getElement))} />\n        );\n\n      case NodeType.Row:\n        return (\n          <Row label={component.label}>\n            {getElement(component.value) as RowChildren}\n          </Row>\n        );\n\n      case NodeType.Spinner:\n        return <Spinner />;\n\n      case NodeType.Text:\n        return <Text>{getChildren(getTextChildren(component.value))}</Text>;\n\n      /* istanbul ignore next 2 */\n      default:\n        return assertExhaustive(component);\n    }\n  }\n\n  return getElement(legacyComponent);\n}\n\n/**\n * Extract all links from a Markdown text string using the `marked` lexer.\n *\n * @param text - The markdown text string.\n * @returns A list of URLs linked to in the string.\n */\nfunction getMarkdownLinks(text: string) {\n  const tokens = lexer(text, { gfm: false });\n  const links: Tokens.Link[] = [];\n\n  // Walk the lexed tokens and collect all link tokens\n  walkTokens(tokens, (token) => {\n    if (token.type === 'link') {\n      links.push(token as Tokens.Link);\n    }\n  });\n\n  return links;\n}\n\n/**\n * Validate a link against the phishing list.\n *\n * @param link - The link to validate.\n * @param isOnPhishingList - The function that checks the link against the\n * phishing list.\n */\nfunction validateLink(\n  link: string,\n  isOnPhishingList: (url: string) => boolean,\n) {\n  try {\n    const url = new URL(link);\n    assert(\n      ALLOWED_PROTOCOLS.includes(url.protocol),\n      `Protocol must be one of: ${ALLOWED_PROTOCOLS.join(', ')}.`,\n    );\n\n    const hostname =\n      url.protocol === 'mailto:' ? url.pathname.split('@')[1] : url.hostname;\n\n    assert(!isOnPhishingList(hostname), 'The specified URL is not allowed.');\n  } catch (error) {\n    throw new Error(\n      `Invalid URL: ${\n        error instanceof AssertionError ? error.message : 'Unable to parse URL.'\n      }`,\n    );\n  }\n}\n\n/**\n * Search for Markdown links in a string and checks them against the phishing\n * list.\n *\n * @param text - The text to verify.\n * @param isOnPhishingList - The function that checks the link against the\n * phishing list.\n * @throws If the text contains a link that is not allowed.\n */\nexport function validateTextLinks(\n  text: string,\n  isOnPhishingList: (url: string) => boolean,\n) {\n  const links = getMarkdownLinks(text);\n\n  for (const link of links) {\n    validateLink(link.href, isOnPhishingList);\n  }\n}\n\n/**\n * Walk a JSX tree and validate each {@link LinkElement} node against the\n * phishing list.\n *\n * @param node - The JSX node to walk.\n * @param isOnPhishingList - The function that checks the link against the\n * phishing list.\n */\nexport function validateJsxLinks(\n  node: JSXElement,\n  isOnPhishingList: (url: string) => boolean,\n) {\n  walkJsx(node, (childNode) => {\n    if (childNode.type !== 'Link') {\n      return;\n    }\n\n    validateLink(childNode.props.href, isOnPhishingList);\n  });\n}\n\n/**\n * Calculate the total length of all text in the component.\n *\n * @param component - A custom UI component.\n * @returns The total length of all text components in the component.\n */\nexport function getTotalTextLength(component: Component): number {\n  const { type } = component;\n\n  switch (type) {\n    case NodeType.Panel:\n      return component.children.reduce<number>(\n        // This is a bug in TypeScript: https://github.com/microsoft/TypeScript/issues/48313\n        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n        (sum, node) => sum + getTotalTextLength(node),\n        0,\n      );\n\n    case NodeType.Row:\n      return getTotalTextLength(component.value);\n\n    case NodeType.Text:\n      return component.value.length;\n\n    default:\n      return 0;\n  }\n}\n\n/**\n * Check if a JSX element has children.\n *\n * @param element - A JSX element.\n * @returns `true` if the element has children, `false` otherwise.\n */\nexport function hasChildren<Element extends JSXElement>(\n  element: Element,\n): element is Element & {\n  props: { children: MaybeArray<JSXElement | string> };\n} {\n  return hasProperty(element.props, 'children');\n}\n\n/**\n * Get the children of a JSX element as an array. If the element has only one\n * child, the child is returned as an array.\n *\n * @param element - A JSX element.\n * @returns The children of the element.\n */\nexport function getJsxChildren(element: JSXElement): (JSXElement | string)[] {\n  if (hasChildren(element)) {\n    if (Array.isArray(element.props.children)) {\n      // @ts-expect-error - Each member of the union type has signatures, but\n      // none of those signatures are compatible with each other.\n      return element.props.children.filter(Boolean);\n    }\n\n    if (element.props.children) {\n      return [element.props.children];\n    }\n  }\n\n  return [];\n}\n\n/**\n * Walk a JSX tree and call a callback on each node.\n *\n * @param node - The JSX node to walk.\n * @param callback - The callback to call on each node.\n * @returns The result of the callback, if any.\n */\nexport function walkJsx<Value>(\n  node: JSXElement | JSXElement[],\n  callback: (node: JSXElement) => Value | undefined,\n): Value | undefined {\n  if (Array.isArray(node)) {\n    for (const child of node) {\n      const childResult = walkJsx(child as JSXElement, callback);\n      if (childResult !== undefined) {\n        return childResult;\n      }\n    }\n\n    return undefined;\n  }\n\n  const result = callback(node);\n  if (result !== undefined) {\n    return result;\n  }\n\n  if (\n    hasProperty(node, 'props') &&\n    isPlainObject(node.props) &&\n    hasProperty(node.props, 'children')\n  ) {\n    const children = getJsxChildren(node);\n    for (const child of children) {\n      if (isPlainObject(child)) {\n        const childResult = walkJsx(child, callback);\n        if (childResult !== undefined) {\n          return childResult;\n        }\n      }\n    }\n  }\n\n  return undefined;\n}\n"],"mappings":"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","names":[]}