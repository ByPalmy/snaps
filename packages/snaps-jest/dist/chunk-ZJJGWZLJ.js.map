{"version":3,"sources":["../src/internals/simulation/interface.ts"],"names":["content"],"mappings":"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","sourcesContent":["import type { DialogApprovalTypes } from '@metamask/snaps-rpc-methods';\nimport { DIALOG_APPROVAL_TYPES } from '@metamask/snaps-rpc-methods';\nimport type {\n  FormState,\n  InterfaceContext,\n  InterfaceState,\n  SnapId,\n  UserInputEvent,\n  File,\n} from '@metamask/snaps-sdk';\nimport { DialogType, UserInputEventType, assert } from '@metamask/snaps-sdk';\nimport type { FooterElement } from '@metamask/snaps-sdk/jsx';\nimport { type FormElement, type JSXElement } from '@metamask/snaps-sdk/jsx';\nimport {\n  HandlerType,\n  getJsxChildren,\n  unwrapError,\n  walkJsx,\n} from '@metamask/snaps-utils';\nimport { assertExhaustive, hasProperty } from '@metamask/utils';\nimport type { PayloadAction } from '@reduxjs/toolkit';\nimport { type SagaIterator } from 'redux-saga';\nimport { call, put, select, take } from 'redux-saga/effects';\n\nimport type {\n  FileOptions,\n  SnapInterface,\n  SnapInterfaceActions,\n} from '../../types';\nimport type { RootControllerMessenger } from './controllers';\nimport { getFileSize, getFileToUpload } from './files';\nimport type { Interface, RunSagaFunction } from './store';\nimport { getCurrentInterface, resolveInterface, setInterface } from './store';\n\n/**\n * The maximum file size that can be uploaded.\n */\nconst MAX_FILE_SIZE = 10_000_000; // 10 MB\n\n/**\n * Get a user interface object from a type and content object.\n *\n * @param runSaga - A function to run a saga outside the usual Redux flow.\n * @param type - The type of the interface.\n * @param content - The content to show in the interface.\n * @param interfaceActions - The actions to interact with the interface.\n * @returns The user interface object.\n */\nexport function getInterfaceResponse(\n  runSaga: RunSagaFunction,\n  type: DialogApprovalTypes[DialogType | 'default'],\n  content: JSXElement,\n  interfaceActions: SnapInterfaceActions,\n): SnapInterface {\n  switch (type) {\n    case DIALOG_APPROVAL_TYPES[DialogType.Alert]:\n      return {\n        ...interfaceActions,\n        type: DialogType.Alert,\n        content,\n        ok: resolveWith(runSaga, null),\n      };\n\n    case DIALOG_APPROVAL_TYPES[DialogType.Confirmation]:\n      return {\n        ...interfaceActions,\n        type: DialogType.Confirmation,\n        content,\n\n        ok: resolveWith(runSaga, true),\n        cancel: resolveWith(runSaga, false),\n      };\n\n    case DIALOG_APPROVAL_TYPES[DialogType.Prompt]:\n      return {\n        ...interfaceActions,\n        type: DialogType.Prompt,\n        content,\n\n        ok: resolveWithInput(runSaga),\n        cancel: resolveWith(runSaga, null),\n      };\n\n    case DIALOG_APPROVAL_TYPES.default: {\n      const footer = getElementByType<FooterElement>(content, 'Footer');\n\n      // No Footer defined so we apply a default footer.\n      if (!footer) {\n        return {\n          ...interfaceActions,\n          content,\n\n          ok: resolveWith(runSaga, null),\n          cancel: resolveWith(runSaga, null),\n        };\n      }\n\n      // Only one button in footer so we apply a default cancel button.\n      if (getJsxChildren(footer).length === 1) {\n        return {\n          ...interfaceActions,\n          content,\n\n          cancel: resolveWith(runSaga, null),\n        };\n      }\n\n      // We have two buttons in the footer so we assume the snap handles the approval of the interface.\n      return {\n        ...interfaceActions,\n        content,\n      };\n    }\n\n    default:\n      throw new Error(`Unknown or unsupported dialog type: \"${String(type)}\".`);\n  }\n}\n\n/**\n * Resolve the current user interface with the given value.\n *\n * @param value - The value to resolve the user interface with.\n * @yields Puts the resolve user interface action.\n */\nexport function* resolveWithSaga(value: unknown): SagaIterator {\n  yield put(resolveInterface(value));\n}\n\n/**\n * Resolve the current user interface with the given value. This returns a\n * function that can be used to resolve the user interface.\n *\n * @param runSaga - A function to run a saga outside the usual Redux flow.\n * @param value - The value to resolve the user interface with.\n * @returns A function that can be used to resolve the user interface.\n */\nfunction resolveWith(runSaga: RunSagaFunction, value: unknown) {\n  return async () => {\n    await runSaga(resolveWithSaga, value).toPromise();\n  };\n}\n\n/**\n * Resolve the current user interface with the provided input. This returns a\n * function that can be used to resolve the user interface.\n *\n * @param runSaga - A function to run a saga outside the usual Redux flow.\n * @returns A function that can be used to resolve the user interface.\n */\nfunction resolveWithInput(runSaga: RunSagaFunction) {\n  return async (value = '') => {\n    await runSaga(resolveWithSaga, value).toPromise();\n  };\n}\n\n/**\n * Get the stored user interface from the store.\n *\n * @param controllerMessenger - The controller messenger used to call actions.\n * @param snapId - The Snap ID.\n * @yields Takes the set interface action.\n * @returns The user interface object.\n */\nfunction* getStoredInterface(\n  controllerMessenger: RootControllerMessenger,\n  snapId: SnapId,\n): SagaIterator<Interface & { content: JSXElement }> {\n  const currentInterface: Interface | null = yield select(getCurrentInterface);\n\n  if (currentInterface) {\n    const { content } = controllerMessenger.call(\n      'SnapInterfaceController:getInterface',\n      snapId,\n      currentInterface.id,\n    );\n\n    return { ...currentInterface, content };\n  }\n\n  const { payload }: PayloadAction<Interface> = yield take(setInterface.type);\n  const { content } = controllerMessenger.call(\n    'SnapInterfaceController:getInterface',\n    snapId,\n    payload.id,\n  );\n\n  return { ...payload, content };\n}\n\n/**\n * A JSX element with a name.\n */\nexport type NamedJSXElement = JSXElement & { props: { name: string } };\n\n/**\n * Check if a JSX element is a JSX element with a given name.\n *\n * @param element - The JSX element.\n * @param name - The element name.\n * @returns True if the element is a JSX element with the given name, otherwise\n * false.\n */\nfunction isJSXElementWithName<Element extends JSXElement, Name extends string>(\n  element: Element,\n  name: Name,\n): element is Element & { props: { name: Name } } {\n  return hasProperty(element.props, 'name') && element.props.name === name;\n}\n\n/**\n * Find an element inside a form element in a JSX tree.\n *\n * @param form - The form element.\n * @param name - The element name.\n * @returns An object containing the element and the form name if it's contained\n * in a form, otherwise undefined.\n */\nfunction getFormElement(form: FormElement, name: string) {\n  const element = walkJsx<NamedJSXElement>(form, (childElement) => {\n    if (isJSXElementWithName(childElement, name)) {\n      return childElement;\n    }\n\n    return undefined;\n  });\n\n  if (element === undefined) {\n    return undefined;\n  }\n\n  return { element, form: form.props.name };\n}\n\n/**\n * Get an element from a JSX tree with the given name.\n *\n * @param content - The interface content.\n * @param name - The element name.\n * @returns An object containing the element and the form name if it's contained\n * in a form, otherwise undefined.\n */\nexport function getElement(\n  content: JSXElement,\n  name: string,\n):\n  | {\n      element: NamedJSXElement;\n      form?: string;\n    }\n  | undefined {\n  if (isJSXElementWithName(content, name)) {\n    return { element: content };\n  }\n\n  return walkJsx(content, (element) => {\n    if (element.type === 'Form') {\n      return getFormElement(element, name);\n    }\n\n    if (isJSXElementWithName(element, name)) {\n      return { element };\n    }\n\n    return undefined;\n  });\n}\n\n/**\n * Get an element from a JSX tree with the given type.\n *\n * @param content - The interface content.\n * @param type - The element type.\n * @returns The element with the given type.\n */\nexport function getElementByType<Element extends JSXElement>(\n  content: JSXElement,\n  type: string,\n) {\n  return walkJsx(content, (element) => {\n    if (element.type === type) {\n      return element as Element;\n    }\n\n    return undefined;\n  });\n}\n\n/**\n * Handle submitting event requests to OnUserInput including unwrapping potential errors.\n *\n * @param controllerMessenger - The controller messenger used to call actions.\n * @param snapId - The Snap ID.\n * @param id - The interface ID.\n * @param event - The event to submit.\n * @param context - The interface context.\n */\nasync function handleEvent(\n  controllerMessenger: RootControllerMessenger,\n  snapId: SnapId,\n  id: string,\n  event: UserInputEvent,\n  context: InterfaceContext | null,\n) {\n  try {\n    await controllerMessenger.call(\n      'ExecutionService:handleRpcRequest',\n      snapId,\n      {\n        origin: '',\n        handler: HandlerType.OnUserInput,\n        request: {\n          jsonrpc: '2.0',\n          method: ' ',\n          params: {\n            event,\n            id,\n            context,\n          },\n        },\n      },\n    );\n  } catch (error) {\n    const [unwrapped] = unwrapError(error);\n    throw unwrapped;\n  }\n}\n\n/**\n * Click on an element of the Snap interface.\n *\n * @param controllerMessenger - The controller messenger used to call actions.\n * @param id - The interface ID.\n * @param content - The interface content.\n * @param snapId - The Snap ID.\n * @param name - The element name.\n */\nexport async function clickElement(\n  controllerMessenger: RootControllerMessenger,\n  id: string,\n  content: JSXElement,\n  snapId: SnapId,\n  name: string,\n): Promise<void> {\n  const result = getElement(content, name);\n  assert(\n    result !== undefined,\n    `Could not find an element in the interface with the name \"${name}\".`,\n  );\n\n  assert(\n    result.element.type === 'Button' || result.element.type === 'Checkbox',\n    `Expected an element of type \"Button\" or \"Checkbox\", but found \"${result.element.type}\".`,\n  );\n\n  const { state, context } = controllerMessenger.call(\n    'SnapInterfaceController:getInterface',\n    snapId,\n    id,\n  );\n\n  const { type } = result.element;\n  const elementName = result.element.props.name;\n\n  const formState = (result.form ? state[result.form] : state) as FormState;\n  const currentValue = formState[elementName];\n\n  switch (type) {\n    case 'Button': {\n      // Button click events are always triggered.\n      await handleEvent(\n        controllerMessenger,\n        snapId,\n        id,\n        {\n          type: UserInputEventType.ButtonClickEvent,\n          name: elementName,\n        },\n        context,\n      );\n\n      if (result.form && result.element.props.type === 'submit') {\n        await handleEvent(\n          controllerMessenger,\n          snapId,\n          id,\n          {\n            type: UserInputEventType.FormSubmitEvent,\n            name: result.form,\n            value: state[result.form] as FormState,\n          },\n          context,\n        );\n      }\n      break;\n    }\n\n    case 'Checkbox': {\n      const newValue = !currentValue;\n      const newState = mergeValue(state, name, newValue, result.form);\n\n      controllerMessenger.call(\n        'SnapInterfaceController:updateInterfaceState',\n        id,\n        newState,\n      );\n\n      await handleEvent(\n        controllerMessenger,\n        snapId,\n        id,\n        {\n          type: UserInputEventType.InputChangeEvent,\n          name: elementName,\n          value: newValue,\n        },\n        context,\n      );\n      break;\n    }\n\n    /* istanbul ignore next */\n    default:\n      assertExhaustive(type);\n  }\n}\n\n/**\n * Merge a value in the interface state.\n *\n * @param state - The actual interface state.\n * @param name - The component name that changed value.\n * @param value - The new value.\n * @param form - The form name if the element is in one.\n * @returns The state with the merged value.\n */\nexport function mergeValue(\n  state: InterfaceState,\n  name: string,\n  value: string | File | boolean | null,\n  form?: string,\n): InterfaceState {\n  if (form) {\n    return {\n      ...state,\n      [form]: {\n        ...(state[form] as FormState),\n        [name]: value,\n      },\n    };\n  }\n\n  return { ...state, [name]: value };\n}\n\n/**\n * Type a value in an interface element.\n *\n * @param controllerMessenger - The controller messenger used to call actions.\n * @param id - The interface ID.\n * @param content - The interface Components.\n * @param snapId - The Snap ID.\n * @param name - The element name.\n * @param value - The value to type in the element.\n */\nexport async function typeInField(\n  controllerMessenger: RootControllerMessenger,\n  id: string,\n  content: JSXElement,\n  snapId: SnapId,\n  name: string,\n  value: string,\n) {\n  const result = getElement(content, name);\n\n  assert(\n    result !== undefined,\n    `Could not find an element in the interface with the name \"${name}\".`,\n  );\n\n  assert(\n    result.element.type === 'Input',\n    `Expected an element of type \"Input\", but found \"${result.element.type}\".`,\n  );\n\n  const { state, context } = controllerMessenger.call(\n    'SnapInterfaceController:getInterface',\n    snapId,\n    id,\n  );\n\n  const newState = mergeValue(state, name, value, result.form);\n\n  controllerMessenger.call(\n    'SnapInterfaceController:updateInterfaceState',\n    id,\n    newState,\n  );\n\n  await controllerMessenger.call('ExecutionService:handleRpcRequest', snapId, {\n    origin: '',\n    handler: HandlerType.OnUserInput,\n    request: {\n      jsonrpc: '2.0',\n      method: ' ',\n      params: {\n        event: {\n          type: UserInputEventType.InputChangeEvent,\n          name: result.element.props.name,\n          value,\n        },\n        id,\n        context,\n      },\n    },\n  });\n}\n\n/**\n * Type a value in an interface element.\n *\n * @param controllerMessenger - The controller messenger used to call actions.\n * @param id - The interface ID.\n * @param content - The interface Components.\n * @param snapId - The Snap ID.\n * @param name - The element name.\n * @param value - The value to type in the element.\n */\nexport async function selectInDropdown(\n  controllerMessenger: RootControllerMessenger,\n  id: string,\n  content: JSXElement,\n  snapId: SnapId,\n  name: string,\n  value: string,\n) {\n  const result = getElement(content, name);\n\n  assert(\n    result !== undefined,\n    `Could not find an element in the interface with the name \"${name}\".`,\n  );\n\n  assert(\n    result.element.type === 'Dropdown',\n    `Expected an element of type \"Dropdown\", but found \"${result.element.type}\".`,\n  );\n\n  const options = getJsxChildren(result.element) as JSXElement[];\n  const selectedOption = options.find(\n    (option) =>\n      hasProperty(option.props, 'value') && option.props.value === value,\n  );\n\n  assert(\n    selectedOption !== undefined,\n    `The dropdown with the name \"${name}\" does not contain \"${value}\".`,\n  );\n\n  const { state, context } = controllerMessenger.call(\n    'SnapInterfaceController:getInterface',\n    snapId,\n    id,\n  );\n\n  const newState = mergeValue(state, name, value, result.form);\n\n  controllerMessenger.call(\n    'SnapInterfaceController:updateInterfaceState',\n    id,\n    newState,\n  );\n\n  await controllerMessenger.call('ExecutionService:handleRpcRequest', snapId, {\n    origin: '',\n    handler: HandlerType.OnUserInput,\n    request: {\n      jsonrpc: '2.0',\n      method: ' ',\n      params: {\n        event: {\n          type: UserInputEventType.InputChangeEvent,\n          name: result.element.props.name,\n          value,\n        },\n        id,\n        context,\n      },\n    },\n  });\n}\n\n/**\n * Get a formatted file size.\n *\n * @param size - The file size in bytes.\n * @returns The formatted file size in MB, with two decimal places.\n * @example\n * getFormattedFileSize(1_000_000); // '1.00 MB'\n */\nfunction getFormattedFileSize(size: number) {\n  return `${(size / 1_000_000).toFixed(2)} MB`;\n}\n\n/**\n * Upload a file to an interface element.\n *\n * @param controllerMessenger - The controller messenger used to call actions.\n * @param id - The interface ID.\n * @param content - The interface Components.\n * @param snapId - The Snap ID.\n * @param name - The element name.\n * @param file - The file to upload. This can be a path to a file or a\n * `Uint8Array` containing the file contents. If this is a path, the file is\n * resolved relative to the current working directory.\n * @param options - The file options.\n * @param options.fileName - The name of the file. By default, this is\n * inferred from the file path if it's a path, and defaults to an empty string\n * if it's a `Uint8Array`.\n * @param options.contentType - The content type of the file. By default, this\n * is inferred from the file name if it's a path, and defaults to\n * `application/octet-stream` if it's a `Uint8Array` or the content type\n * cannot be inferred from the file name.\n */\nexport async function uploadFile(\n  controllerMessenger: RootControllerMessenger,\n  id: string,\n  content: JSXElement,\n  snapId: SnapId,\n  name: string,\n  file: string | Uint8Array,\n  options?: FileOptions,\n) {\n  const result = getElement(content, name);\n\n  assert(\n    result !== undefined,\n    `Could not find an element in the interface with the name \"${name}\".`,\n  );\n\n  assert(\n    result.element.type === 'FileInput',\n    `Expected an element of type \"FileInput\", but found \"${result.element.type}\".`,\n  );\n\n  const { state, context } = controllerMessenger.call(\n    'SnapInterfaceController:getInterface',\n    snapId,\n    id,\n  );\n\n  const fileSize = await getFileSize(file);\n  if (fileSize > MAX_FILE_SIZE) {\n    throw new Error(\n      `The file size (${getFormattedFileSize(\n        fileSize,\n      )}) exceeds the maximum allowed size of ${getFormattedFileSize(\n        MAX_FILE_SIZE,\n      )}.`,\n    );\n  }\n\n  const fileObject = await getFileToUpload(file, options);\n  const newState = mergeValue(state, name, fileObject, result.form);\n\n  controllerMessenger.call(\n    'SnapInterfaceController:updateInterfaceState',\n    id,\n    newState,\n  );\n\n  await controllerMessenger.call('ExecutionService:handleRpcRequest', snapId, {\n    origin: '',\n    handler: HandlerType.OnUserInput,\n    request: {\n      jsonrpc: '2.0',\n      method: ' ',\n      params: {\n        event: {\n          type: UserInputEventType.FileUploadEvent,\n          name: result.element.props.name,\n          file: fileObject,\n        },\n        id,\n        context,\n      },\n    },\n  });\n}\n\n/**\n * Get the user interface actions for a Snap interface. These actions can be\n * used to interact with the interface.\n *\n * @param snapId - The Snap ID.\n * @param controllerMessenger - The controller messenger used to call actions.\n * @param interface - The interface object.\n * @param interface.content - The interface content.\n * @param interface.id - The interface ID.\n * @returns The user interface actions.\n */\nexport function getInterfaceActions(\n  snapId: SnapId,\n  controllerMessenger: RootControllerMessenger,\n  { content, id }: Omit<Interface, 'type'> & { content: JSXElement },\n): SnapInterfaceActions {\n  return {\n    clickElement: async (name: string) => {\n      await clickElement(controllerMessenger, id, content, snapId, name);\n    },\n\n    typeInField: async (name: string, value: string) => {\n      await typeInField(controllerMessenger, id, content, snapId, name, value);\n    },\n\n    selectInDropdown: async (name: string, value: string) => {\n      await selectInDropdown(\n        controllerMessenger,\n        id,\n        content,\n        snapId,\n        name,\n        value,\n      );\n    },\n\n    uploadFile: async (\n      name: string,\n      file: string | Uint8Array,\n      options?: FileOptions,\n    ) => {\n      await uploadFile(\n        controllerMessenger,\n        id,\n        content,\n        snapId,\n        name,\n        file,\n        options,\n      );\n    },\n  };\n}\n\n/**\n * Get a user interface object from a Snap.\n *\n * @param runSaga - A function to run a saga outside the usual Redux flow.\n * @param snapId - The Snap ID.\n * @param controllerMessenger - The controller messenger used to call actions.\n * @yields Takes the set interface action.\n * @returns The user interface object.\n */\nexport function* getInterface(\n  runSaga: RunSagaFunction,\n  snapId: SnapId,\n  controllerMessenger: RootControllerMessenger,\n): SagaIterator {\n  const storedInterface = yield call(\n    getStoredInterface,\n    controllerMessenger,\n    snapId,\n  );\n\n  const interfaceActions = getInterfaceActions(\n    snapId,\n    controllerMessenger,\n    storedInterface,\n  );\n\n  return getInterfaceResponse(\n    runSaga,\n    storedInterface.type,\n    storedInterface.content,\n    interfaceActions,\n  );\n}\n"]}