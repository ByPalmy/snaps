{"version":3,"sources":["../../src/jsx/jsx-dev-runtime.ts","../../src/jsx/jsx-runtime.ts","../../src/jsx/validation.ts","../../src/internals/structs.ts","../../src/internals/jsx.ts"],"sourcesContent":["import type { JsonObject, Key, SnapComponent } from './component';\nimport { jsx } from './jsx-runtime';\nimport { assertJSXElement } from './validation';\n\n/**\n * The JSX runtime for Snaps SDK components. This function is used to render\n * Snap components into a format that can be used by the Snaps.\n *\n * This is the \"development\" version of the runtime, which includes additional\n * validation, which is otherwise handled by MetaMask. To use this runtime,\n * specify `@metamask/snaps-sdk` as import source for JSX, and use\n * `react-jsxdev` as the pragma.\n *\n * @param component - The component to render.\n * @param props - The props to pass to the component.\n * @param key - The key of the component.\n * @returns The rendered component.\n * @see https://www.typescriptlang.org/tsconfig/#jsx\n */\nexport function jsxDEV<Props extends JsonObject>(\n  component: SnapComponent<Props>,\n  props: Props,\n  key: Key | null,\n): unknown | null {\n  const element = jsx(component, props, key);\n  assertJSXElement(element);\n\n  return element;\n}\n","import type { JsonObject, Key, SnapComponent } from './component';\n\n/**\n * The JSX runtime for Snaps SDK components. This function is used to render\n * Snap components into a format that can be used by the Snaps.\n *\n * This is the \"production\" version of the runtime, which does not include\n * additional validation, as it is handled by MetaMask. To use this runtime,\n * specify `@metamask/snaps-sdk` as import source for JSX, and use `react-jsx`\n * as the pragma.\n *\n * @param component - The component to render.\n * @param props - The props to pass to the component.\n * @param key - The key of the component.\n * @returns The rendered component.\n * @see https://www.typescriptlang.org/tsconfig/#jsx\n */\nexport function jsx<Props extends JsonObject>(\n  component: SnapComponent<Props>,\n  props: Props,\n  key: Key | null,\n): unknown | null {\n  if (typeof component === 'string') {\n    // If component is a string, it is a built-in HTML element. This is not\n    // supported in Snaps, so we throw an error.\n    throw new Error(\n      `An HTML element (\"${String(\n        component,\n      )}\") was used in a Snap component, which is not supported by Snaps UI. Please use one of the supported Snap components.`,\n    );\n  }\n\n  if (!component) {\n    // If component is undefined, a JSX fragment `<>...</>` was used, which is\n    // not supported in Snaps.\n    throw new Error(\n      'A JSX fragment was used in a Snap component, which is not supported by Snaps UI. Please use one of the supported Snap components.',\n    );\n  }\n\n  return component({ ...props, key });\n}\n\n/**\n * The JSX runtime for Snaps SDK components. This function is used to render\n * Snap components into a format that can be used by the Snaps.\n *\n * The `jsxs` function is used for rendering nested components.\n *\n * This is the \"production\" version of the runtime, which does not include\n * additional validation, as it is handled by MetaMask. To use this runtime,\n * specify `@metamask/snaps-sdk` as import source for JSX, and use `react-jsx`\n * as the pragma.\n *\n * @param component - The component to render.\n * @param props - The props to pass to the component.\n * @param key - The key of the component.\n * @returns The rendered component.\n * @see https://www.typescriptlang.org/tsconfig/#jsx\n */\nexport function jsxs<Props extends JsonObject>(\n  component: SnapComponent<Props>,\n  props: Props,\n  key: Key | null,\n): unknown | null {\n  return jsx(component, props, key);\n}\n","import {\n  hasProperty,\n  HexChecksumAddressStruct,\n  isPlainObject,\n  JsonStruct,\n} from '@metamask/utils';\nimport type { Struct } from 'superstruct';\nimport {\n  is,\n  boolean,\n  optional,\n  array,\n  lazy,\n  nullable,\n  number,\n  object,\n  record,\n  string,\n} from 'superstruct';\nimport type { ObjectSchema } from 'superstruct/dist/utils';\n\nimport type { Describe } from '../internals';\nimport { literal, nullUnion } from '../internals';\nimport type { EmptyObject } from '../types';\nimport type {\n  GenericSnapElement,\n  JsonObject,\n  Key,\n  MaybeArray,\n  SnapElement,\n  StringElement,\n} from './component';\nimport type {\n  AddressElement,\n  BoldElement,\n  BoxElement,\n  ButtonElement,\n  CopyableElement,\n  DividerElement,\n  FieldElement,\n  FormElement,\n  HeadingElement,\n  ImageElement,\n  InputElement,\n  ItalicElement,\n  JSXElement,\n  LinkElement,\n  RowElement,\n  SpinnerElement,\n  StandardFormattingElement,\n  TextElement,\n} from './components';\n\n/**\n * A struct for the {@link Key} type.\n */\nexport const KeyStruct: Describe<Key> = nullUnion([string(), number()]);\n\n/**\n * A struct for the {@link StringElement} type.\n */\nexport const StringElementStruct: Describe<StringElement> = maybeArray(\n  string(),\n);\n\n/**\n * A struct for the {@link GenericSnapElement} type.\n */\nexport const ElementStruct: Describe<GenericSnapElement> = object({\n  type: string(),\n  props: record(string(), JsonStruct),\n  key: nullable(KeyStruct),\n});\n\n/**\n * A helper function for creating a struct for a {@link MaybeArray} type.\n *\n * @param struct - The struct for the maybe array type.\n * @returns The struct for the maybe array type.\n */\nfunction maybeArray<Type, Schema>(\n  struct: Struct<Type, Schema>,\n): Struct<MaybeArray<Type>, any> {\n  return nullUnion([struct, array(struct)]);\n}\n\n/**\n * A helper function for creating a struct for a JSX element.\n *\n * @param name - The name of the element.\n * @param props - The props of the element.\n * @returns The struct for the element.\n */\nfunction element<Name extends string, Props extends ObjectSchema = EmptyObject>(\n  name: Name,\n  props: Props = {} as Props,\n) {\n  return object({\n    type: literal(name) as unknown as Struct<Name, Name>,\n    props: object(props),\n    key: nullable(KeyStruct),\n  });\n}\n\n/**\n * A struct for the {@link ButtonElement} type.\n */\nexport const ButtonStruct: Describe<ButtonElement> = element('Button', {\n  children: StringElementStruct,\n  name: optional(string()),\n  type: optional(nullUnion([literal('button'), literal('submit')])),\n  variant: optional(nullUnion([literal('primary'), literal('destructive')])),\n  disabled: optional(boolean()),\n});\n\n/**\n * A struct for the {@link InputElement} type.\n */\nexport const InputStruct: Describe<InputElement> = element('Input', {\n  name: string(),\n  type: optional(\n    nullUnion([literal('text'), literal('password'), literal('number')]),\n  ),\n  value: optional(string()),\n  placeholder: optional(string()),\n});\n\n/**\n * A struct for the {@link FieldElement} type.\n */\nexport const FieldStruct: Describe<FieldElement> = element('Field', {\n  label: optional(string()),\n  error: optional(string()),\n  children: InputStruct,\n});\n\n/**\n * A struct for the {@link FormElement} type.\n */\nexport const FormStruct: Describe<FormElement> = element('Form', {\n  children: maybeArray(nullUnion([FieldStruct, ButtonStruct])),\n  name: string(),\n});\n\n/**\n * A struct for the {@link BoldElement} type.\n */\nexport const BoldStruct: Describe<BoldElement> = element('Bold', {\n  children: maybeArray(\n    nullable(\n      nullUnion([\n        string(),\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        lazy(() => ItalicStruct) as unknown as Struct<\n          SnapElement<JsonObject, 'Italic'>\n        >,\n      ]),\n    ),\n  ),\n});\n\n/**\n * A struct for the {@link ItalicElement} type.\n */\nexport const ItalicStruct: Describe<ItalicElement> = element('Italic', {\n  children: maybeArray(\n    nullable(\n      nullUnion([\n        string(),\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        lazy(() => BoldStruct) as unknown as Struct<\n          SnapElement<JsonObject, 'Bold'>\n        >,\n      ]),\n    ),\n  ),\n});\n\nexport const FormattingStruct: Describe<StandardFormattingElement> = nullUnion([\n  BoldStruct,\n  ItalicStruct,\n]);\n\n/**\n * A struct for the {@link AddressElement} type.\n */\nexport const AddressStruct: Describe<AddressElement> = element('Address', {\n  address: HexChecksumAddressStruct,\n});\n\n/**\n * A struct for the {@link BoxElement} type.\n */\nexport const BoxStruct: Describe<BoxElement> = element('Box', {\n  children: maybeArray(\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    nullable(lazy(() => JSXElementStruct)),\n  ) as unknown as Struct<MaybeArray<GenericSnapElement | null>, null>,\n});\n\n/**\n * A struct for the {@link CopyableElement} type.\n */\nexport const CopyableStruct: Describe<CopyableElement> = element('Copyable', {\n  value: string(),\n  sensitive: optional(boolean()),\n});\n\n/**\n * A struct for the {@link DividerElement} type.\n */\nexport const DividerStruct: Describe<DividerElement> = element('Divider');\n\n/**\n * A struct for the {@link HeadingElement} type.\n */\nexport const HeadingStruct: Describe<HeadingElement> = element('Heading', {\n  children: StringElementStruct,\n});\n\n/**\n * A struct for the {@link ImageElement} type.\n */\nexport const ImageStruct: Describe<ImageElement> = element('Image', {\n  src: string(),\n  alt: optional(string()),\n});\n\n/**\n * A struct for the {@link LinkElement} type.\n */\nexport const LinkStruct: Describe<LinkElement> = element('Link', {\n  href: string(),\n  children: maybeArray(nullable(nullUnion([FormattingStruct, string()]))),\n});\n\n/**\n * A struct for the {@link TextElement} type.\n */\nexport const TextStruct: Describe<TextElement> = element('Text', {\n  children: maybeArray(\n    nullable(nullUnion([string(), BoldStruct, ItalicStruct, LinkStruct])),\n  ),\n});\n\n/**\n * A struct for the {@link RowElement} type.\n */\nexport const RowStruct: Describe<RowElement> = element('Row', {\n  label: string(),\n  children: nullUnion([AddressStruct, ImageStruct, TextStruct]),\n  variant: optional(\n    nullUnion([literal('default'), literal('warning'), literal('error')]),\n  ),\n});\n\n/**\n * A struct for the {@link SpinnerElement} type.\n */\nexport const SpinnerStruct: Describe<SpinnerElement> = element('Spinner');\n\n/**\n * A struct for the {@link JSXElement} type.\n */\nexport const JSXElementStruct: Describe<JSXElement> = nullUnion([\n  ButtonStruct,\n  InputStruct,\n  FieldStruct,\n  FormStruct,\n  BoldStruct,\n  ItalicStruct,\n  AddressStruct,\n  BoxStruct,\n  CopyableStruct,\n  DividerStruct,\n  HeadingStruct,\n  ImageStruct,\n  LinkStruct,\n  RowStruct,\n  SpinnerStruct,\n  TextStruct,\n]);\n\n/**\n * Check if a value is a JSX element.\n *\n * @param value - The value to check.\n * @returns True if the value is a JSX element, false otherwise.\n */\nexport function isJSXElement(value: unknown): value is JSXElement {\n  return is(value, JSXElementStruct);\n}\n\n/**\n * Check if a value is a JSX element, without validating all of its contents.\n * This is useful when you want to validate the structure of a value, but not\n * all the children.\n *\n * This should only be used when you are sure that the value is safe to use,\n * i.e., after using {@link isJSXElement}.\n *\n * @param value - The value to check.\n * @returns True if the value is a JSX element, false otherwise.\n */\nexport function isJSXElementUnsafe(value: unknown): value is JSXElement {\n  return (\n    isPlainObject(value) &&\n    hasProperty(value, 'type') &&\n    hasProperty(value, 'props') &&\n    hasProperty(value, 'key')\n  );\n}\n\n/**\n * Assert that a value is a JSX element.\n *\n * @param value - The value to check.\n * @throws If the value is not a JSX element.\n */\nexport function assertJSXElement(value: unknown): asserts value is JSXElement {\n  // TODO: We should use the error parsing utils from `snaps-utils` to improve\n  // the error messages. It currently includes colours and potentially other\n  // formatting that we might not want to include in the SDK.\n  if (!isJSXElement(value)) {\n    throw new Error(\n      `Expected a JSX element, but received ${JSON.stringify(\n        value,\n      )}. Please refer to the documentation for the supported JSX elements and their props.`,\n    );\n  }\n}\n","import type { Infer } from 'superstruct';\nimport {\n  Struct,\n  define,\n  literal as superstructLiteral,\n  union as superstructUnion,\n} from 'superstruct';\nimport type { AnyStruct, InferStructTuple } from 'superstruct/dist/utils';\n\nimport type { EnumToUnion } from './helpers';\n\n/**\n * A wrapper of `superstruct`'s `literal` struct that also defines the name of\n * the struct as the literal value.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n * For example, instead of returning an error like:\n *\n * ```\n * Expected the value to satisfy a union of `literal | literal`, but received: \\\"baz\\\"\n * ```\n *\n * This struct will return an error like:\n *\n * ```\n * Expected the value to satisfy a union of `\"foo\" | \"bar\"`, but received: \\\"baz\\\"\n * ```\n *\n * @param value - The literal value.\n * @returns The `superstruct` struct, which validates that the value is equal\n * to the literal value.\n */\nexport function literal<Type extends string | number | boolean>(value: Type) {\n  return define<Type>(\n    JSON.stringify(value),\n    superstructLiteral(value).validator,\n  );\n}\n\n/**\n * A wrapper of `superstruct`'s `union` struct that also defines the schema as\n * the union of the schemas of the structs.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n *\n * @param structs - The structs to union.\n * @param structs.\"0\" - The first struct.\n * @param structs.\"1\" - The remaining structs.\n * @returns The `superstruct` struct, which validates that the value satisfies\n * one of the structs.\n */\nexport function union<Head extends AnyStruct, Tail extends AnyStruct[]>([\n  head,\n  ...tail\n]: [head: Head, ...tail: Tail]): Struct<\n  Infer<Head> | InferStructTuple<Tail>[number],\n  [head: Head, ...tail: Tail]\n> {\n  const struct = superstructUnion([head, ...tail]);\n\n  return new Struct({\n    ...struct,\n    schema: [head, ...tail],\n  });\n}\n\n/**\n * Superstruct struct for validating an enum value. This allows using both the\n * enum string values and the enum itself as values.\n *\n * @param constant - The enum to validate against.\n * @returns The superstruct struct.\n */\nexport function enumValue<Type extends string>(\n  constant: Type,\n): Struct<EnumToUnion<Type>, null> {\n  return literal(constant as EnumToUnion<Type>);\n}\n","import type { Infer, Struct } from 'superstruct';\nimport type {\n  AnyStruct,\n  EnumSchema,\n  InferStructTuple,\n  IsExactMatch,\n  IsMatch,\n  IsRecord,\n  IsTuple,\n  UnionToIntersection,\n} from 'superstruct/dist/utils';\n\nimport type { EmptyObject } from '../types';\nimport { union } from './structs';\n\n/**\n * Check if a type is a union. Infers `true` if it is a union, otherwise\n * `false`.\n */\ntype IsUnion<Type> = [Type] extends [UnionToIntersection<Type>] ? false : true;\n\n/**\n * Get a struct schema for a type.\n *\n * This is copied from `superstruct` but fixes some issues with the original\n * implementation.\n */\ntype StructSchema<Type> = IsUnion<Type> extends true\n  ? null\n  : [Type] extends [EmptyObject]\n  ? EmptyObject\n  : [Type] extends [string | undefined | null]\n  ? [Type] extends [`0x${string}`]\n    ? null\n    : [Type] extends [IsMatch<Type, string | undefined | null>]\n    ? null\n    : [Type] extends [IsUnion<Type>]\n    ? EnumSchema<Type>\n    : Type\n  : [Type] extends [number | undefined | null]\n  ? [Type] extends [IsMatch<Type, number | undefined | null>]\n    ? null\n    : [Type] extends [IsUnion<Type>]\n    ? EnumSchema<Type>\n    : Type\n  : [Type] extends [boolean]\n  ? [Type] extends [IsExactMatch<Type, boolean>]\n    ? null\n    : Type\n  : Type extends\n      | bigint\n      | symbol\n      | undefined\n      | null\n      // eslint-disable-next-line @typescript-eslint/ban-types\n      | Function\n      | Date\n      | Error\n      | RegExp\n      | Map<any, any>\n      | WeakMap<any, any>\n      | Set<any>\n      | WeakSet<any>\n      | Promise<any>\n  ? null\n  : Type extends (infer E)[]\n  ? Type extends IsTuple<Type>\n    ? null\n    : Struct<E>\n  : Type extends object\n  ? Type extends IsRecord<Type>\n    ? null\n    : {\n        [InnerKey in keyof Type]: Describe<Type[InnerKey]>;\n      }\n  : null;\n\n/**\n * Describe a struct type.\n */\nexport type Describe<Type> = Struct<Type, StructSchema<Type>>;\n\n/**\n * Create a union struct that uses `null` for the schema type, for better\n * compatibility with `Describe`.\n *\n * @param structs - The structs to union.\n * @returns The `superstruct` struct, which validates that the value satisfies\n * one of the structs.\n */\nexport function nullUnion<Head extends AnyStruct, Tail extends AnyStruct[]>(\n  structs: [head: Head, ...tail: Tail],\n) {\n  return union(structs) as unknown as Struct<\n    Infer<Head> | InferStructTuple<Tail>[number],\n    null\n  >;\n}\n"],"mappings":"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","names":["import_superstruct","superstructLiteral","superstructUnion","element"]}