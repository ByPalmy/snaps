{"version":3,"sources":["../../src/jsx/index.ts","../../src/jsx/component.ts","../../src/jsx/components/form/Button.ts","../../src/jsx/components/form/Field.ts","../../src/jsx/components/form/Form.ts","../../src/jsx/components/form/Input.ts","../../src/jsx/components/formatting/Bold.ts","../../src/jsx/components/formatting/Italic.ts","../../src/jsx/components/Address.ts","../../src/jsx/components/Box.ts","../../src/jsx/components/Copyable.ts","../../src/jsx/components/Divider.ts","../../src/jsx/components/Heading.ts","../../src/jsx/components/Image.ts","../../src/jsx/components/Link.ts","../../src/jsx/components/Row.ts","../../src/jsx/components/Spinner.ts","../../src/jsx/components/Text.ts","../../src/jsx/jsx-runtime.ts","../../src/jsx/validation.ts","../../src/internals/structs.ts","../../src/internals/jsx.ts","../../src/jsx/jsx-dev-runtime.ts"],"sourcesContent":["export * from './component';\nexport * from './components';\nexport * from './jsx-runtime';\nexport * from './jsx-dev-runtime';\nexport {\n  JSXElementStruct,\n  isJSXElement,\n  isJSXElementUnsafe,\n  assertJSXElement,\n} from './validation';\n","import type { Json } from '@metamask/utils';\n\n/**\n * A key, which can be a string or a number.\n */\nexport type Key = string | number;\n\n/**\n * A JSON object.\n */\nexport type JsonObject = Record<string, Json>;\n\n/**\n * A generic JSX element.\n *\n * @property type - The type of the element.\n * @property props - The props of the element.\n * @property key - The key of the element.\n */\nexport type GenericSnapElement = {\n  type: string;\n  props: JsonObject;\n  key: Key | null;\n};\n\n/**\n * A JSX element.\n *\n * @property type - The type of the element.\n * @property props - The props of the element.\n * @property key - The key of the element.\n */\nexport type SnapElement<\n  Props extends JsonObject = Record<string, never>,\n  Type extends string = string,\n> = {\n  type: Type;\n  props: Props;\n  key: Key | null;\n};\n\n/**\n * A type that can be a single value or an array of values.\n *\n * @template Type - The type that can be an array.\n * @example\n * type MaybeArrayString = MaybeArray<string>;\n * const maybeArrayString: MaybeArrayString = 'hello';\n * const maybeArrayStringArray: MaybeArrayString = ['hello', 'world'];\n */\nexport type MaybeArray<Type> = Type | Type[];\n\n/**\n * A JSX node, which can be an element, a string, null, or an array of nodes.\n */\nexport type SnapNode = MaybeArray<GenericSnapElement | string | null>;\n\n/**\n * A JSX string element, which can be a string or an array of strings.\n */\nexport type StringElement = MaybeArray<string>;\n\n/**\n * A JSX component.\n */\nexport type SnapComponent<\n  Props extends JsonObject = Record<string, never>,\n  Type extends string = string,\n> = (props: Props & { key?: Key | null }) => SnapElement<Props, Type>;\n\n/**\n * Remove undefined props from an object.\n *\n * @param props - The object to remove undefined props from.\n * @returns The object without undefined props.\n */\nfunction removeUndefinedProps<Props extends JsonObject>(props: Props): Props {\n  return Object.fromEntries(\n    Object.entries(props).filter(([, value]) => value !== undefined),\n  ) as Props;\n}\n\n/**\n * Create a Snap component from a type. This is a helper function that creates a\n * Snap component function.\n *\n * @param type - The type of the component.\n * @returns A function that creates a Snap element.\n * @see SnapComponent\n */\nexport function createSnapComponent<\n  Props extends JsonObject = Record<string, never>,\n  Type extends string = string,\n>(type: Type): SnapComponent<Props, Type> {\n  return (props: Props & { key?: Key | null }) => {\n    const { key = null, ...rest } = props;\n    return {\n      type,\n      props: removeUndefinedProps(rest as Props),\n      key,\n    };\n  };\n}\n","import type { StringElement } from '../../component';\nimport { createSnapComponent } from '../../component';\n\n// TODO: Add the `onClick` prop to the `ButtonProps` type.\n\n/**\n * The props of the {@link Button} component.\n *\n * @property children - The text to display on the button.\n * @property name - The name of the button. This is used to identify the button\n * in the event handler.\n * @property type - The type of the button, i.e., `'button'` or `'submit'`.\n * Defaults to `'button'`.\n * @property variant - The variant of the button, i.e., `'primary'` or\n * `'destructive'`. Defaults to `'primary'`.\n * @property disabled - Whether the button is disabled. Defaults to `false`.\n */\nexport type ButtonProps = {\n  children: StringElement;\n  name?: string | undefined;\n  type?: 'button' | 'submit' | undefined;\n  variant?: 'primary' | 'destructive' | undefined;\n  disabled?: boolean | undefined;\n};\n\nconst TYPE = 'Button';\n\n/**\n * A button component, which is used to create a clickable button.\n *\n * @param props - The props of the component.\n * @param props.children - The text to display on the button. This should be a\n * string or an array of strings.\n * @returns A button element.\n * @example\n * <Button name=\"my-button\">Click me</Button>\n */\nexport const Button = createSnapComponent<ButtonProps, typeof TYPE>(TYPE);\n\n/**\n * A button element.\n *\n * @see Button\n */\nexport type ButtonElement = ReturnType<typeof Button>;\n","import { createSnapComponent } from '../../component';\nimport type { InputElement } from './Input';\n\n/**\n * The props of the {@link Field} component.\n *\n * @property label - The label of the field.\n * @property error - The error message of the field.\n * @property children - The input field and the submit button.\n */\nexport type FieldProps = {\n  label?: string | undefined;\n  error?: string | undefined;\n  children: InputElement;\n};\n\nconst TYPE = 'Field';\n\n/**\n * A field component, which is used to create a form field. This component can\n * only be used as a child of the {@link Form} component.\n *\n * @param props - The props of the component.\n * @param props.label - The label of the field.\n * @param props.error - The error message of the field.\n * @param props.children - The input field and the submit button.\n * @returns A field element.\n * @example\n * <Field label=\"Username\">\n *   <Input name=\"username\" type=\"text\" />\n * </Field>\n */\nexport const Field = createSnapComponent<FieldProps, typeof TYPE>(TYPE);\n\n/**\n * A field element.\n *\n * @see Field\n */\nexport type FieldElement = ReturnType<typeof Field>;\n","import type { MaybeArray } from '../../component';\nimport { createSnapComponent } from '../../component';\nimport type { ButtonElement } from './Button';\nimport type { FieldElement } from './Field';\n\n// TODO: Add `onSubmit` prop to the `FormProps` type.\n\n/**\n * The props of the {@link Form} component.\n *\n * @property children - The form fields. See {@link Field}.\n * @property name - The name of the form. This is used to identify the form in\n * the event handler.\n */\ntype FormProps = {\n  children: MaybeArray<FieldElement | ButtonElement>;\n  name: string;\n};\n\nconst TYPE = 'Form';\n\n/**\n * A form component, which is used to create a form.\n *\n * @param props - The props of the component.\n * @param props.children - The form fields. This should be a single field or an\n * array of fields.\n * @param props.name - The name of the form. This is used to identify the form\n * in the event handler.\n * @returns A form element.\n * @example\n * <Form name=\"my-form\">\n *   <Field label=\"Username\">\n *     <Input name=\"username\" type=\"text\" />\n *   </Field>\n *   <Button type=\"submit\">Submit</Button>\n * </Form>\n */\nexport const Form = createSnapComponent<FormProps, typeof TYPE>(TYPE);\n\n/**\n * A form element.\n *\n * @see Form\n */\nexport type FormElement = ReturnType<typeof Form>;\n","import { createSnapComponent } from '../../component';\n\n// TODO: Add the `onChange` prop to the `InputProps` type.\n\n/**\n * The props of the {@link Input} component.\n *\n * @property name - The name of the input field. This is used to identify the\n * input field in the form data.\n * @property type - The type of the input field. Defaults to `text`.\n * @property value - The value of the input field.\n * @property placeholder - The placeholder text of the input field.\n */\ntype InputProps = {\n  name: string;\n  type?: 'text' | 'password' | 'number' | undefined;\n  value?: string | undefined;\n  placeholder?: string | undefined;\n};\n\nconst TYPE = 'Input';\n\n/**\n * An input component, which is used to create an input field. This component\n * can only be used as a child of the {@link Field} component.\n *\n * @param props - The props of the component.\n * @param props.name - The name of the input field. This is used to identify the\n * input field in the form data.\n * @param props.type - The type of the input field.\n * @param props.value - The value of the input field.\n * @param props.placeholder - The placeholder text of the input field.\n * @returns An input element.\n * @example\n * <Input name=\"username\" type=\"text\" />\n */\nexport const Input = createSnapComponent<InputProps, typeof TYPE>(TYPE);\n\n/**\n * An input element.\n *\n * @see Input\n */\nexport type InputElement = ReturnType<typeof Input>;\n","import type { JsonObject, MaybeArray, SnapElement } from '../../component';\nimport { createSnapComponent } from '../../component';\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport type { Text } from '../Text';\n\n/**\n * The children of the {@link Bold} component.\n */\nexport type BoldChildren = MaybeArray<\n  | string\n  // We have to specify the type here to avoid a circular reference.\n  | SnapElement<JsonObject, 'Italic'>\n  | null\n>;\n\n/**\n * The props of the {@link Bold} component.\n *\n * @property children - The text to display in bold.\n */\nexport type BoldProps = {\n  children: BoldChildren;\n};\n\nconst TYPE = 'Bold';\n\n/**\n * A bold component, which is used to display text in bold. This component can\n * only be used as a child of the {@link Text} component.\n *\n * @param props - The props of the component.\n * @param props.children - The text to display in bold.\n * @returns A bold element.\n * @example\n * <Text>\n *   Hello <Bold>world</Bold>!\n * </Text>\n */\nexport const Bold = createSnapComponent<BoldProps, typeof TYPE>(TYPE);\n\n/**\n * A bold element.\n *\n * @see Bold\n */\nexport type BoldElement = ReturnType<typeof Bold>;\n","import type { JsonObject, MaybeArray, SnapElement } from '../../component';\nimport { createSnapComponent } from '../../component';\n\n/**\n * The children of the {@link Italic} component.\n */\nexport type ItalicChildren = MaybeArray<\n  | string\n  // We have to specify the type here to avoid a circular reference.\n  | SnapElement<JsonObject, 'Bold'>\n  | null\n>;\n\n/**\n * The props of the {@link Italic} component.\n *\n * @property children - The text to display in italic. This should be a string\n * or an array of strings.\n */\nexport type ItalicProps = {\n  children: ItalicChildren;\n};\n\nconst TYPE = 'Italic';\n\n/**\n * An italic component, which is used to display text in italic. This componen\n * can only be used as a child of the {@link Text} component.\n *\n * @param props - The props of the component.\n * @param props.children - The text to display in italic. This should be a\n * string or an array of strings.\n * @returns An italic element.\n * @example\n * <Text>\n *   Hello <Italic>world</Italic>!\n * </Text>\n */\nexport const Italic = createSnapComponent<ItalicProps, typeof TYPE>(TYPE);\n\n/**\n * An italic element.\n *\n * @see Italic\n */\nexport type ItalicElement = ReturnType<typeof Italic>;\n","import { createSnapComponent } from '../component';\n\n/**\n * The props of the {@link Address} component.\n *\n * @property address - The (Ethereum) address to display. This should be a\n * valid Ethereum address, starting with `0x`.\n */\nexport type AddressProps = {\n  address: `0x${string}`;\n};\n\nconst TYPE = 'Address';\n\n/**\n * An address component, which is used to display an Ethereum address.\n *\n * This component does not accept any children.\n *\n * @param props - The props of the component.\n * @param props.address - The (Ethereum) address to display. This should be a\n * valid Ethereum address, starting with `0x`.\n * @returns An address element.\n * @example\n * <Address address=\"0x1234567890123456789012345678901234567890\" />\n */\nexport const Address = createSnapComponent<AddressProps, typeof TYPE>(TYPE);\n\n/**\n * An address element.\n *\n * @see Address\n */\nexport type AddressElement = ReturnType<typeof Address>;\n","import type { GenericSnapElement, MaybeArray } from '../component';\nimport { createSnapComponent } from '../component';\n\n/**\n * The props of the {@link Box} component.\n *\n * @property children - The children of the box.\n */\nexport type BoxProps = {\n  // We can't use `JSXElement` because it causes a circular reference.\n  children: MaybeArray<GenericSnapElement | null>;\n};\n\nconst TYPE = 'Box';\n\n/**\n * A box component, which is used to group multiple components together.\n *\n * @param props - The props of the component.\n * @param props.children - The children of the box.\n * @returns A box element.\n * @example\n * <Box>\n *   <Text>Hello world!</Text>\n * </Box>\n */\nexport const Box = createSnapComponent<BoxProps, typeof TYPE>(TYPE);\n\n/**\n * A box element.\n *\n * @see Box\n */\nexport type BoxElement = ReturnType<typeof Box>;\n","import { createSnapComponent } from '../component';\n\n/**\n * The props of the {@link Copyable} component.\n *\n * @property value - The value to copy when the user clicks on the copyable\n * element.\n * @property sensitive - Whether the value is sensitive. If `true`, the value\n * will be hidden when the user is not interacting with the copyable element.\n */\nexport type CopyableProps = {\n  value: string;\n  sensitive?: boolean | undefined;\n};\n\nconst TYPE = 'Copyable';\n\n/**\n * A copyable component, which is used to display text that can be copied by the\n * user.\n *\n * @param props - The props of the component.\n * @param props.value - The value to copy when the user clicks on the copyable\n * element.\n * @param props.sensitive - Whether the value is sensitive. If `true`, the value\n * will be hidden when the user is not interacting with the copyable element.\n * @example\n * <Copyable value=\"0x1234567890123456789012345678901234567890\" />\n * <Copyable value=\"0x1234567890123456789012345678901234567890\" sensitive />\n */\nexport const Copyable = createSnapComponent<CopyableProps, typeof TYPE>(TYPE);\n\n/**\n * A copyable element.\n *\n * @see Copyable\n */\nexport type CopyableElement = ReturnType<typeof Copyable>;\n","import { createSnapComponent } from '../component';\n\nconst TYPE = 'Divider';\n\n/**\n * A divider component, which is used to create a horizontal line between\n * elements.\n *\n * This component does not have any props.\n *\n * @returns A divider element.\n * @example\n * <Divider />\n */\nexport const Divider = createSnapComponent(TYPE);\n\n/**\n * A divider element.\n *\n * @see Divider\n */\nexport type DividerElement = ReturnType<typeof Divider>;\n","import type { StringElement } from '../component';\nimport { createSnapComponent } from '../component';\n\n/**\n * The props of the {@link Heading} component.\n *\n * @property children - The text to display in the heading.\n */\ntype HeadingProps = {\n  children: StringElement;\n};\n\nconst TYPE = 'Heading';\n\n/**\n * A heading component, which is used to display heading text.\n *\n * @param props - The props of the component.\n * @param props.children - The text to display in the heading.\n * @returns A heading element.\n * @example\n * <Heading>Hello world!</Heading>\n */\nexport const Heading = createSnapComponent<HeadingProps, typeof TYPE>(TYPE);\n\n/**\n * A heading element.\n *\n * @see Heading\n */\nexport type HeadingElement = ReturnType<typeof Heading>;\n","import { createSnapComponent } from '../component';\n\n/**\n * The props of the {@link Image} component.\n *\n * @property src - The SVG image to display. This should be an SVG string, and\n * other formats such as PNG and JPEG are not supported directly. You can use\n * the `data:` URL scheme to embed images inside the SVG.\n * @property alt - The alternative text of the image, which describes the image\n * for users who cannot see it.\n */\ntype ImageProps = {\n  src: string;\n  alt?: string | undefined;\n};\n\nconst TYPE = 'Image';\n\n/**\n * An image component, which is used to display an image.\n *\n * This component does not accept any children.\n *\n * @param props - The props of the component.\n * @param props.src - The URL of the image to display. This should be an SVG\n * string, and other formats such as PNG and JPEG are not supported directly.\n * You can use the `data:` URL scheme to embed images inside the SVG.\n * @param props.alt - The alternative text of the image, which describes the\n * image for users who cannot see it.\n * @returns An image element.\n * @example\n * <Image src=\"<svg>...</svg>\" alt=\"An example image\" />\n */\nexport const Image = createSnapComponent<ImageProps, typeof TYPE>(TYPE);\n\n/**\n * An image element.\n *\n * @see Image\n */\nexport type ImageElement = ReturnType<typeof Image>;\n","import type { MaybeArray } from '../component';\nimport { createSnapComponent } from '../component';\nimport type { StandardFormattingElement } from './formatting';\n\n/**\n * The children of the {@link Link} component.\n */\nexport type LinkChildren = MaybeArray<\n  string | StandardFormattingElement | null\n>;\n\n/**\n * The props of the {@link Link} component.\n *\n * @property children - The text to display in the link.\n * @property href - The URL to link to. This must be an `https` or `mailto` URL.\n * `http` is not allowed.\n */\nexport type LinkProps = {\n  children: LinkChildren;\n  href: string;\n};\n\nconst TYPE = 'Link';\n\n/**\n * A link component, which is used to display a hyperlink.\n *\n * @param props - The props of the component.\n * @param props.children - The text to display in the link.\n * @param props.href - The URL to link to. This must be an `https` or `mailto`\n * URL. `http` is not allowed.\n * @returns A link element.\n * @example\n * <Link href=\"https://example.com\">Click here</Link>\n */\nexport const Link = createSnapComponent<LinkProps, typeof TYPE>(TYPE);\n\n/**\n * A link element.\n *\n * @see Link\n */\nexport type LinkElement = ReturnType<typeof Link>;\n","import { createSnapComponent } from '../component';\nimport type { AddressElement } from './Address';\nimport type { ImageElement } from './Image';\nimport type { TextElement } from './Text';\n\n/**\n * The children of a {@link Row} component.\n */\nexport type RowChildren = AddressElement | ImageElement | TextElement;\n\n/**\n * The props of the {@link Row} component.\n *\n * @property label - The label of the row.\n * @property children - The content of the row. This can be an address, an\n * image, or text.\n * @property variant - The variant of the row.\n */\nexport type RowProps = {\n  label: string;\n  children: RowChildren;\n  variant?: 'default' | 'warning' | 'error';\n};\n\nconst TYPE = 'Row';\n\n/**\n * A row component, which is used to display a row of information.\n *\n * @param props - The props of the component.\n * @param props.label - The label of the row.\n * @param props.children - The content of the row. This can be an address, an\n * image, or text.\n * @param props.variant - The variant of the row.\n * @returns A row element.\n * @example\n * <Row label=\"From\" variant=\"warning\">\n *   <Address address=\"0x1234567890123456789012345678901234567890\" />\n * </Row>\n */\nexport const Row = createSnapComponent<RowProps, typeof TYPE>(TYPE);\n\n/**\n * A row element.\n *\n * @see Row\n */\nexport type RowElement = ReturnType<typeof Row>;\n","import { createSnapComponent } from '../component';\n\nconst TYPE = 'Spinner';\n\n/**\n * A spinner component, which is used to display a spinner, indicating that some\n * operation is in progress.\n *\n * This component does not accept any props.\n *\n * @returns A spinner element.\n * @example\n * <Spinner />\n */\nexport const Spinner = createSnapComponent(TYPE);\n\n/**\n * A spinner element.\n *\n * @see Spinner\n */\nexport type SpinnerElement = ReturnType<typeof Spinner>;\n","import type { MaybeArray } from '../component';\nimport { createSnapComponent } from '../component';\nimport type { StandardFormattingElement } from './formatting';\nimport type { LinkElement } from './Link';\n\n/**\n * The children of the {@link Text} component.\n */\nexport type TextChildren = MaybeArray<\n  string | StandardFormattingElement | LinkElement | null\n>;\n\n/**\n * The props of the {@link Text} component.\n *\n * @property children - The text to display.\n */\nexport type TextProps = {\n  children: TextChildren;\n};\n\nconst TYPE = 'Text';\n\n/**\n * A text component, which is used to display text.\n *\n * @param props - The props of the component.\n * @param props.children - The text to display.\n * @returns A text element.\n * @example\n * <Text>\n *   Hello <Bold>world</Bold>!\n * </Text>\n */\nexport const Text = createSnapComponent<TextProps, typeof TYPE>(TYPE);\n\n/**\n * A text element.\n *\n * @see Text\n */\nexport type TextElement = ReturnType<typeof Text>;\n","import type { JsonObject, Key, SnapComponent } from './component';\n\n/**\n * The JSX runtime for Snaps SDK components. This function is used to render\n * Snap components into a format that can be used by the Snaps.\n *\n * This is the \"production\" version of the runtime, which does not include\n * additional validation, as it is handled by MetaMask. To use this runtime,\n * specify `@metamask/snaps-sdk` as import source for JSX, and use `react-jsx`\n * as the pragma.\n *\n * @param component - The component to render.\n * @param props - The props to pass to the component.\n * @param key - The key of the component.\n * @returns The rendered component.\n * @see https://www.typescriptlang.org/tsconfig/#jsx\n */\nexport function jsx<Props extends JsonObject>(\n  component: SnapComponent<Props>,\n  props: Props,\n  key: Key | null,\n): unknown | null {\n  if (typeof component === 'string') {\n    // If component is a string, it is a built-in HTML element. This is not\n    // supported in Snaps, so we throw an error.\n    throw new Error(\n      `An HTML element (\"${String(\n        component,\n      )}\") was used in a Snap component, which is not supported by Snaps UI. Please use one of the supported Snap components.`,\n    );\n  }\n\n  if (!component) {\n    // If component is undefined, a JSX fragment `<>...</>` was used, which is\n    // not supported in Snaps.\n    throw new Error(\n      'A JSX fragment was used in a Snap component, which is not supported by Snaps UI. Please use one of the supported Snap components.',\n    );\n  }\n\n  return component({ ...props, key });\n}\n\n/**\n * The JSX runtime for Snaps SDK components. This function is used to render\n * Snap components into a format that can be used by the Snaps.\n *\n * The `jsxs` function is used for rendering nested components.\n *\n * This is the \"production\" version of the runtime, which does not include\n * additional validation, as it is handled by MetaMask. To use this runtime,\n * specify `@metamask/snaps-sdk` as import source for JSX, and use `react-jsx`\n * as the pragma.\n *\n * @param component - The component to render.\n * @param props - The props to pass to the component.\n * @param key - The key of the component.\n * @returns The rendered component.\n * @see https://www.typescriptlang.org/tsconfig/#jsx\n */\nexport function jsxs<Props extends JsonObject>(\n  component: SnapComponent<Props>,\n  props: Props,\n  key: Key | null,\n): unknown | null {\n  return jsx(component, props, key);\n}\n","import {\n  hasProperty,\n  HexChecksumAddressStruct,\n  isPlainObject,\n  JsonStruct,\n} from '@metamask/utils';\nimport type { Struct } from 'superstruct';\nimport {\n  is,\n  boolean,\n  optional,\n  array,\n  lazy,\n  nullable,\n  number,\n  object,\n  record,\n  string,\n} from 'superstruct';\nimport type { ObjectSchema } from 'superstruct/dist/utils';\n\nimport type { Describe } from '../internals';\nimport { literal, nullUnion } from '../internals';\nimport type { EmptyObject } from '../types';\nimport type {\n  GenericSnapElement,\n  JsonObject,\n  Key,\n  MaybeArray,\n  SnapElement,\n  StringElement,\n} from './component';\nimport type {\n  AddressElement,\n  BoldElement,\n  BoxElement,\n  ButtonElement,\n  CopyableElement,\n  DividerElement,\n  FieldElement,\n  FormElement,\n  HeadingElement,\n  ImageElement,\n  InputElement,\n  ItalicElement,\n  JSXElement,\n  LinkElement,\n  RowElement,\n  SpinnerElement,\n  StandardFormattingElement,\n  TextElement,\n} from './components';\n\n/**\n * A struct for the {@link Key} type.\n */\nexport const KeyStruct: Describe<Key> = nullUnion([string(), number()]);\n\n/**\n * A struct for the {@link StringElement} type.\n */\nexport const StringElementStruct: Describe<StringElement> = maybeArray(\n  string(),\n);\n\n/**\n * A struct for the {@link GenericSnapElement} type.\n */\nexport const ElementStruct: Describe<GenericSnapElement> = object({\n  type: string(),\n  props: record(string(), JsonStruct),\n  key: nullable(KeyStruct),\n});\n\n/**\n * A helper function for creating a struct for a {@link MaybeArray} type.\n *\n * @param struct - The struct for the maybe array type.\n * @returns The struct for the maybe array type.\n */\nfunction maybeArray<Type, Schema>(\n  struct: Struct<Type, Schema>,\n): Struct<MaybeArray<Type>, any> {\n  return nullUnion([struct, array(struct)]);\n}\n\n/**\n * A helper function for creating a struct for a JSX element.\n *\n * @param name - The name of the element.\n * @param props - The props of the element.\n * @returns The struct for the element.\n */\nfunction element<Name extends string, Props extends ObjectSchema = EmptyObject>(\n  name: Name,\n  props: Props = {} as Props,\n) {\n  return object({\n    type: literal(name) as unknown as Struct<Name, Name>,\n    props: object(props),\n    key: nullable(KeyStruct),\n  });\n}\n\n/**\n * A struct for the {@link ButtonElement} type.\n */\nexport const ButtonStruct: Describe<ButtonElement> = element('Button', {\n  children: StringElementStruct,\n  name: optional(string()),\n  type: optional(nullUnion([literal('button'), literal('submit')])),\n  variant: optional(nullUnion([literal('primary'), literal('destructive')])),\n  disabled: optional(boolean()),\n});\n\n/**\n * A struct for the {@link InputElement} type.\n */\nexport const InputStruct: Describe<InputElement> = element('Input', {\n  name: string(),\n  type: optional(\n    nullUnion([literal('text'), literal('password'), literal('number')]),\n  ),\n  value: optional(string()),\n  placeholder: optional(string()),\n});\n\n/**\n * A struct for the {@link FieldElement} type.\n */\nexport const FieldStruct: Describe<FieldElement> = element('Field', {\n  label: optional(string()),\n  error: optional(string()),\n  children: InputStruct,\n});\n\n/**\n * A struct for the {@link FormElement} type.\n */\nexport const FormStruct: Describe<FormElement> = element('Form', {\n  children: maybeArray(nullUnion([FieldStruct, ButtonStruct])),\n  name: string(),\n});\n\n/**\n * A struct for the {@link BoldElement} type.\n */\nexport const BoldStruct: Describe<BoldElement> = element('Bold', {\n  children: maybeArray(\n    nullable(\n      nullUnion([\n        string(),\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        lazy(() => ItalicStruct) as unknown as Struct<\n          SnapElement<JsonObject, 'Italic'>\n        >,\n      ]),\n    ),\n  ),\n});\n\n/**\n * A struct for the {@link ItalicElement} type.\n */\nexport const ItalicStruct: Describe<ItalicElement> = element('Italic', {\n  children: maybeArray(\n    nullable(\n      nullUnion([\n        string(),\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        lazy(() => BoldStruct) as unknown as Struct<\n          SnapElement<JsonObject, 'Bold'>\n        >,\n      ]),\n    ),\n  ),\n});\n\nexport const FormattingStruct: Describe<StandardFormattingElement> = nullUnion([\n  BoldStruct,\n  ItalicStruct,\n]);\n\n/**\n * A struct for the {@link AddressElement} type.\n */\nexport const AddressStruct: Describe<AddressElement> = element('Address', {\n  address: HexChecksumAddressStruct,\n});\n\n/**\n * A struct for the {@link BoxElement} type.\n */\nexport const BoxStruct: Describe<BoxElement> = element('Box', {\n  children: maybeArray(\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    nullable(lazy(() => JSXElementStruct)),\n  ) as unknown as Struct<MaybeArray<GenericSnapElement | null>, null>,\n});\n\n/**\n * A struct for the {@link CopyableElement} type.\n */\nexport const CopyableStruct: Describe<CopyableElement> = element('Copyable', {\n  value: string(),\n  sensitive: optional(boolean()),\n});\n\n/**\n * A struct for the {@link DividerElement} type.\n */\nexport const DividerStruct: Describe<DividerElement> = element('Divider');\n\n/**\n * A struct for the {@link HeadingElement} type.\n */\nexport const HeadingStruct: Describe<HeadingElement> = element('Heading', {\n  children: StringElementStruct,\n});\n\n/**\n * A struct for the {@link ImageElement} type.\n */\nexport const ImageStruct: Describe<ImageElement> = element('Image', {\n  src: string(),\n  alt: optional(string()),\n});\n\n/**\n * A struct for the {@link LinkElement} type.\n */\nexport const LinkStruct: Describe<LinkElement> = element('Link', {\n  href: string(),\n  children: maybeArray(nullable(nullUnion([FormattingStruct, string()]))),\n});\n\n/**\n * A struct for the {@link TextElement} type.\n */\nexport const TextStruct: Describe<TextElement> = element('Text', {\n  children: maybeArray(\n    nullable(nullUnion([string(), BoldStruct, ItalicStruct, LinkStruct])),\n  ),\n});\n\n/**\n * A struct for the {@link RowElement} type.\n */\nexport const RowStruct: Describe<RowElement> = element('Row', {\n  label: string(),\n  children: nullUnion([AddressStruct, ImageStruct, TextStruct]),\n  variant: optional(\n    nullUnion([literal('default'), literal('warning'), literal('error')]),\n  ),\n});\n\n/**\n * A struct for the {@link SpinnerElement} type.\n */\nexport const SpinnerStruct: Describe<SpinnerElement> = element('Spinner');\n\n/**\n * A struct for the {@link JSXElement} type.\n */\nexport const JSXElementStruct: Describe<JSXElement> = nullUnion([\n  ButtonStruct,\n  InputStruct,\n  FieldStruct,\n  FormStruct,\n  BoldStruct,\n  ItalicStruct,\n  AddressStruct,\n  BoxStruct,\n  CopyableStruct,\n  DividerStruct,\n  HeadingStruct,\n  ImageStruct,\n  LinkStruct,\n  RowStruct,\n  SpinnerStruct,\n  TextStruct,\n]);\n\n/**\n * Check if a value is a JSX element.\n *\n * @param value - The value to check.\n * @returns True if the value is a JSX element, false otherwise.\n */\nexport function isJSXElement(value: unknown): value is JSXElement {\n  return is(value, JSXElementStruct);\n}\n\n/**\n * Check if a value is a JSX element, without validating all of its contents.\n * This is useful when you want to validate the structure of a value, but not\n * all the children.\n *\n * This should only be used when you are sure that the value is safe to use,\n * i.e., after using {@link isJSXElement}.\n *\n * @param value - The value to check.\n * @returns True if the value is a JSX element, false otherwise.\n */\nexport function isJSXElementUnsafe(value: unknown): value is JSXElement {\n  return (\n    isPlainObject(value) &&\n    hasProperty(value, 'type') &&\n    hasProperty(value, 'props') &&\n    hasProperty(value, 'key')\n  );\n}\n\n/**\n * Assert that a value is a JSX element.\n *\n * @param value - The value to check.\n * @throws If the value is not a JSX element.\n */\nexport function assertJSXElement(value: unknown): asserts value is JSXElement {\n  // TODO: We should use the error parsing utils from `snaps-utils` to improve\n  // the error messages. It currently includes colours and potentially other\n  // formatting that we might not want to include in the SDK.\n  if (!isJSXElement(value)) {\n    throw new Error(\n      `Expected a JSX element, but received ${JSON.stringify(\n        value,\n      )}. Please refer to the documentation for the supported JSX elements and their props.`,\n    );\n  }\n}\n","import type { Infer } from 'superstruct';\nimport {\n  Struct,\n  define,\n  literal as superstructLiteral,\n  union as superstructUnion,\n} from 'superstruct';\nimport type { AnyStruct, InferStructTuple } from 'superstruct/dist/utils';\n\nimport type { EnumToUnion } from './helpers';\n\n/**\n * A wrapper of `superstruct`'s `literal` struct that also defines the name of\n * the struct as the literal value.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n * For example, instead of returning an error like:\n *\n * ```\n * Expected the value to satisfy a union of `literal | literal`, but received: \\\"baz\\\"\n * ```\n *\n * This struct will return an error like:\n *\n * ```\n * Expected the value to satisfy a union of `\"foo\" | \"bar\"`, but received: \\\"baz\\\"\n * ```\n *\n * @param value - The literal value.\n * @returns The `superstruct` struct, which validates that the value is equal\n * to the literal value.\n */\nexport function literal<Type extends string | number | boolean>(value: Type) {\n  return define<Type>(\n    JSON.stringify(value),\n    superstructLiteral(value).validator,\n  );\n}\n\n/**\n * A wrapper of `superstruct`'s `union` struct that also defines the schema as\n * the union of the schemas of the structs.\n *\n * This is useful for improving the error messages returned by `superstruct`.\n *\n * @param structs - The structs to union.\n * @param structs.\"0\" - The first struct.\n * @param structs.\"1\" - The remaining structs.\n * @returns The `superstruct` struct, which validates that the value satisfies\n * one of the structs.\n */\nexport function union<Head extends AnyStruct, Tail extends AnyStruct[]>([\n  head,\n  ...tail\n]: [head: Head, ...tail: Tail]): Struct<\n  Infer<Head> | InferStructTuple<Tail>[number],\n  [head: Head, ...tail: Tail]\n> {\n  const struct = superstructUnion([head, ...tail]);\n\n  return new Struct({\n    ...struct,\n    schema: [head, ...tail],\n  });\n}\n\n/**\n * Superstruct struct for validating an enum value. This allows using both the\n * enum string values and the enum itself as values.\n *\n * @param constant - The enum to validate against.\n * @returns The superstruct struct.\n */\nexport function enumValue<Type extends string>(\n  constant: Type,\n): Struct<EnumToUnion<Type>, null> {\n  return literal(constant as EnumToUnion<Type>);\n}\n","import type { Infer, Struct } from 'superstruct';\nimport type {\n  AnyStruct,\n  EnumSchema,\n  InferStructTuple,\n  IsExactMatch,\n  IsMatch,\n  IsRecord,\n  IsTuple,\n  UnionToIntersection,\n} from 'superstruct/dist/utils';\n\nimport type { EmptyObject } from '../types';\nimport { union } from './structs';\n\n/**\n * Check if a type is a union. Infers `true` if it is a union, otherwise\n * `false`.\n */\ntype IsUnion<Type> = [Type] extends [UnionToIntersection<Type>] ? false : true;\n\n/**\n * Get a struct schema for a type.\n *\n * This is copied from `superstruct` but fixes some issues with the original\n * implementation.\n */\ntype StructSchema<Type> = IsUnion<Type> extends true\n  ? null\n  : [Type] extends [EmptyObject]\n  ? EmptyObject\n  : [Type] extends [string | undefined | null]\n  ? [Type] extends [`0x${string}`]\n    ? null\n    : [Type] extends [IsMatch<Type, string | undefined | null>]\n    ? null\n    : [Type] extends [IsUnion<Type>]\n    ? EnumSchema<Type>\n    : Type\n  : [Type] extends [number | undefined | null]\n  ? [Type] extends [IsMatch<Type, number | undefined | null>]\n    ? null\n    : [Type] extends [IsUnion<Type>]\n    ? EnumSchema<Type>\n    : Type\n  : [Type] extends [boolean]\n  ? [Type] extends [IsExactMatch<Type, boolean>]\n    ? null\n    : Type\n  : Type extends\n      | bigint\n      | symbol\n      | undefined\n      | null\n      // eslint-disable-next-line @typescript-eslint/ban-types\n      | Function\n      | Date\n      | Error\n      | RegExp\n      | Map<any, any>\n      | WeakMap<any, any>\n      | Set<any>\n      | WeakSet<any>\n      | Promise<any>\n  ? null\n  : Type extends (infer E)[]\n  ? Type extends IsTuple<Type>\n    ? null\n    : Struct<E>\n  : Type extends object\n  ? Type extends IsRecord<Type>\n    ? null\n    : {\n        [InnerKey in keyof Type]: Describe<Type[InnerKey]>;\n      }\n  : null;\n\n/**\n * Describe a struct type.\n */\nexport type Describe<Type> = Struct<Type, StructSchema<Type>>;\n\n/**\n * Create a union struct that uses `null` for the schema type, for better\n * compatibility with `Describe`.\n *\n * @param structs - The structs to union.\n * @returns The `superstruct` struct, which validates that the value satisfies\n * one of the structs.\n */\nexport function nullUnion<Head extends AnyStruct, Tail extends AnyStruct[]>(\n  structs: [head: Head, ...tail: Tail],\n) {\n  return union(structs) as unknown as Struct<\n    Infer<Head> | InferStructTuple<Tail>[number],\n    null\n  >;\n}\n","import type { JsonObject, Key, SnapComponent } from './component';\nimport { jsx } from './jsx-runtime';\nimport { assertJSXElement } from './validation';\n\n/**\n * The JSX runtime for Snaps SDK components. This function is used to render\n * Snap components into a format that can be used by the Snaps.\n *\n * This is the \"development\" version of the runtime, which includes additional\n * validation, which is otherwise handled by MetaMask. To use this runtime,\n * specify `@metamask/snaps-sdk` as import source for JSX, and use\n * `react-jsxdev` as the pragma.\n *\n * @param component - The component to render.\n * @param props - The props to pass to the component.\n * @param key - The key of the component.\n * @returns The rendered component.\n * @see https://www.typescriptlang.org/tsconfig/#jsx\n */\nexport function jsxDEV<Props extends JsonObject>(\n  component: SnapComponent<Props>,\n  props: Props,\n  key: Key | null,\n): unknown | null {\n  const element = jsx(component, props, key);\n  assertJSXElement(element);\n\n  return element;\n}\n"],"mappings":"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","names":["TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","TYPE","import_superstruct","superstructLiteral","superstructUnion","element"]}