{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://@metamask/webpack-plugin-example-snap/../node_modules/fast-safe-stringify/index.js","webpack://@metamask/webpack-plugin-example-snap/webpack/bootstrap","webpack://@metamask/webpack-plugin-example-snap/webpack/runtime/define property getters","webpack://@metamask/webpack-plugin-example-snap/webpack/runtime/hasOwnProperty shorthand","webpack://@metamask/webpack-plugin-example-snap/webpack/runtime/make namespace object","webpack://@metamask/webpack-plugin-example-snap/javascript/node_modules/@metamask/utils/dist/misc.mjs","webpack://@metamask/webpack-plugin-example-snap/javascript/node_modules/@metamask/superstruct/dist/error.mjs","webpack://@metamask/webpack-plugin-example-snap/javascript/node_modules/@metamask/superstruct/dist/utils.mjs","webpack://@metamask/webpack-plugin-example-snap/javascript/node_modules/@metamask/superstruct/dist/struct.mjs","webpack://@metamask/webpack-plugin-example-snap/javascript/node_modules/@metamask/superstruct/dist/structs/utilities.mjs","webpack://@metamask/webpack-plugin-example-snap/javascript/node_modules/@metamask/superstruct/dist/structs/types.mjs","webpack://@metamask/webpack-plugin-example-snap/javascript/node_modules/@metamask/superstruct/dist/structs/coercions.mjs","webpack://@metamask/webpack-plugin-example-snap/javascript/node_modules/@metamask/utils/dist/assert.mjs","webpack://@metamask/webpack-plugin-example-snap/javascript/node_modules/@metamask/utils/dist/errors.mjs","webpack://@metamask/webpack-plugin-example-snap/javascript/node_modules/@metamask/utils/dist/json.mjs","webpack://@metamask/webpack-plugin-example-snap/javascript/node_modules/@metamask/superstruct/dist/structs/refinements.mjs","webpack://@metamask/webpack-plugin-example-snap/javascript/node_modules/@metamask/rpc-errors/dist/chunk-MIW4NMY6.mjs","webpack://@metamask/webpack-plugin-example-snap/javascript/node_modules/@metamask/rpc-errors/dist/chunk-MPU3CVX3.mjs","webpack://@metamask/webpack-plugin-example-snap/javascript/node_modules/@metamask/rpc-errors/dist/chunk-XSKO3GXZ.mjs","webpack://@metamask/webpack-plugin-example-snap/javascript/node_modules/@metamask/rpc-errors/dist/chunk-KYP27U3C.mjs","webpack://@metamask/webpack-plugin-example-snap/javascript/node_modules/@metamask/utils/dist/hex.mjs","webpack://@metamask/webpack-plugin-example-snap/javascript/snaps-sdk/dist/index.mjs","webpack://@metamask/webpack-plugin-example-snap/./src/index.ts"],"sourcesContent":["module.exports = stringify\nstringify.default = stringify\nstringify.stable = deterministicStringify\nstringify.stableStringify = deterministicStringify\n\nvar LIMIT_REPLACE_NODE = '[...]'\nvar CIRCULAR_REPLACE_NODE = '[Circular]'\n\nvar arr = []\nvar replacerStack = []\n\nfunction defaultOptions () {\n  return {\n    depthLimit: Number.MAX_SAFE_INTEGER,\n    edgesLimit: Number.MAX_SAFE_INTEGER\n  }\n}\n\n// Regular stringify\nfunction stringify (obj, replacer, spacer, options) {\n  if (typeof options === 'undefined') {\n    options = defaultOptions()\n  }\n\n  decirc(obj, '', 0, [], undefined, 0, options)\n  var res\n  try {\n    if (replacerStack.length === 0) {\n      res = JSON.stringify(obj, replacer, spacer)\n    } else {\n      res = JSON.stringify(obj, replaceGetterValues(replacer), spacer)\n    }\n  } catch (_) {\n    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]')\n  } finally {\n    while (arr.length !== 0) {\n      var part = arr.pop()\n      if (part.length === 4) {\n        Object.defineProperty(part[0], part[1], part[3])\n      } else {\n        part[0][part[1]] = part[2]\n      }\n    }\n  }\n  return res\n}\n\nfunction setReplace (replace, val, k, parent) {\n  var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k)\n  if (propertyDescriptor.get !== undefined) {\n    if (propertyDescriptor.configurable) {\n      Object.defineProperty(parent, k, { value: replace })\n      arr.push([parent, k, val, propertyDescriptor])\n    } else {\n      replacerStack.push([val, k, replace])\n    }\n  } else {\n    parent[k] = replace\n    arr.push([parent, k, val])\n  }\n}\n\nfunction decirc (val, k, edgeIndex, stack, parent, depth, options) {\n  depth += 1\n  var i\n  if (typeof val === 'object' && val !== null) {\n    for (i = 0; i < stack.length; i++) {\n      if (stack[i] === val) {\n        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent)\n        return\n      }\n    }\n\n    if (\n      typeof options.depthLimit !== 'undefined' &&\n      depth > options.depthLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent)\n      return\n    }\n\n    if (\n      typeof options.edgesLimit !== 'undefined' &&\n      edgeIndex + 1 > options.edgesLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent)\n      return\n    }\n\n    stack.push(val)\n    // Optimize for Arrays. Big arrays could kill the performance otherwise!\n    if (Array.isArray(val)) {\n      for (i = 0; i < val.length; i++) {\n        decirc(val[i], i, i, stack, val, depth, options)\n      }\n    } else {\n      var keys = Object.keys(val)\n      for (i = 0; i < keys.length; i++) {\n        var key = keys[i]\n        decirc(val[key], key, i, stack, val, depth, options)\n      }\n    }\n    stack.pop()\n  }\n}\n\n// Stable-stringify\nfunction compareFunction (a, b) {\n  if (a < b) {\n    return -1\n  }\n  if (a > b) {\n    return 1\n  }\n  return 0\n}\n\nfunction deterministicStringify (obj, replacer, spacer, options) {\n  if (typeof options === 'undefined') {\n    options = defaultOptions()\n  }\n\n  var tmp = deterministicDecirc(obj, '', 0, [], undefined, 0, options) || obj\n  var res\n  try {\n    if (replacerStack.length === 0) {\n      res = JSON.stringify(tmp, replacer, spacer)\n    } else {\n      res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer)\n    }\n  } catch (_) {\n    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]')\n  } finally {\n    // Ensure that we restore the object as it was.\n    while (arr.length !== 0) {\n      var part = arr.pop()\n      if (part.length === 4) {\n        Object.defineProperty(part[0], part[1], part[3])\n      } else {\n        part[0][part[1]] = part[2]\n      }\n    }\n  }\n  return res\n}\n\nfunction deterministicDecirc (val, k, edgeIndex, stack, parent, depth, options) {\n  depth += 1\n  var i\n  if (typeof val === 'object' && val !== null) {\n    for (i = 0; i < stack.length; i++) {\n      if (stack[i] === val) {\n        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent)\n        return\n      }\n    }\n    try {\n      if (typeof val.toJSON === 'function') {\n        return\n      }\n    } catch (_) {\n      return\n    }\n\n    if (\n      typeof options.depthLimit !== 'undefined' &&\n      depth > options.depthLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent)\n      return\n    }\n\n    if (\n      typeof options.edgesLimit !== 'undefined' &&\n      edgeIndex + 1 > options.edgesLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent)\n      return\n    }\n\n    stack.push(val)\n    // Optimize for Arrays. Big arrays could kill the performance otherwise!\n    if (Array.isArray(val)) {\n      for (i = 0; i < val.length; i++) {\n        deterministicDecirc(val[i], i, i, stack, val, depth, options)\n      }\n    } else {\n      // Create a temporary object in the required way\n      var tmp = {}\n      var keys = Object.keys(val).sort(compareFunction)\n      for (i = 0; i < keys.length; i++) {\n        var key = keys[i]\n        deterministicDecirc(val[key], key, i, stack, val, depth, options)\n        tmp[key] = val[key]\n      }\n      if (typeof parent !== 'undefined') {\n        arr.push([parent, k, val])\n        parent[k] = tmp\n      } else {\n        return tmp\n      }\n    }\n    stack.pop()\n  }\n}\n\n// wraps replacer function to handle values we couldn't replace\n// and mark them as replaced value\nfunction replaceGetterValues (replacer) {\n  replacer =\n    typeof replacer !== 'undefined'\n      ? replacer\n      : function (k, v) {\n        return v\n      }\n  return function (key, val) {\n    if (replacerStack.length > 0) {\n      for (var i = 0; i < replacerStack.length; i++) {\n        var part = replacerStack[i]\n        if (part[1] === key && part[0] === val) {\n          val = part[2]\n          replacerStack.splice(i, 1)\n          break\n        }\n      }\n    }\n    return replacer.call(this, key, val)\n  }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","//\n// Types\n//\n//\n// Type Guards\n//\n/**\n * A {@link NonEmptyArray} type guard.\n *\n * @template Element - The non-empty array member type.\n * @param value - The value to check.\n * @returns Whether the value is a non-empty array.\n */\nexport function isNonEmptyArray(value) {\n    return Array.isArray(value) && value.length > 0;\n}\n/**\n * Type guard for \"nullishness\".\n *\n * @param value - Any value.\n * @returns `true` if the value is null or undefined, `false` otherwise.\n */\nexport function isNullOrUndefined(value) {\n    return value === null || value === undefined;\n}\n/**\n * A type guard for {@link RuntimeObject}.\n *\n * @param value - The value to check.\n * @returns Whether the specified value has a runtime type of `object` and is\n * neither `null` nor an `Array`.\n */\nexport function isObject(value) {\n    return Boolean(value) && typeof value === 'object' && !Array.isArray(value);\n}\n//\n// Other utility functions\n//\n/**\n * A type guard for ensuring an object has a property.\n *\n * @param objectToCheck - The object to check.\n * @param name - The property name to check for.\n * @returns Whether the specified object has an own property with the specified\n * name, regardless of whether it is enumerable or not.\n */\nexport const hasProperty = (objectToCheck, name) => Object.hasOwnProperty.call(objectToCheck, name);\n/**\n * `Object.getOwnPropertyNames()` is intentionally generic: it returns the\n * immediate property names of an object, but it cannot make guarantees about\n * the contents of that object, so the type of the property names is merely\n * `string[]`. While this is technically accurate, it is also unnecessary if we\n * have an object with a type that we own (such as an enum).\n *\n * @param object - The plain object.\n * @returns The own property names of the object which are assigned a type\n * derived from the object itself.\n */\nexport function getKnownPropertyNames(object) {\n    return Object.getOwnPropertyNames(object);\n}\n/**\n * Predefined sizes (in Bytes) of specific parts of JSON structure.\n */\nexport var JsonSize;\n(function (JsonSize) {\n    JsonSize[JsonSize[\"Null\"] = 4] = \"Null\";\n    JsonSize[JsonSize[\"Comma\"] = 1] = \"Comma\";\n    JsonSize[JsonSize[\"Wrapper\"] = 1] = \"Wrapper\";\n    JsonSize[JsonSize[\"True\"] = 4] = \"True\";\n    JsonSize[JsonSize[\"False\"] = 5] = \"False\";\n    JsonSize[JsonSize[\"Quote\"] = 1] = \"Quote\";\n    JsonSize[JsonSize[\"Colon\"] = 1] = \"Colon\";\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    JsonSize[JsonSize[\"Date\"] = 24] = \"Date\";\n})(JsonSize = JsonSize || (JsonSize = {}));\n/**\n * Regular expression with pattern matching for (special) escaped characters.\n */\nexport const ESCAPE_CHARACTERS_REGEXP = /\"|\\\\|\\n|\\r|\\t/gu;\n/**\n * Check if the value is plain object.\n *\n * @param value - Value to be checked.\n * @returns True if an object is the plain JavaScript object,\n * false if the object is not plain (e.g. function).\n */\nexport function isPlainObject(value) {\n    if (typeof value !== 'object' || value === null) {\n        return false;\n    }\n    try {\n        let proto = value;\n        while (Object.getPrototypeOf(proto) !== null) {\n            proto = Object.getPrototypeOf(proto);\n        }\n        return Object.getPrototypeOf(value) === proto;\n    }\n    catch (_) {\n        return false;\n    }\n}\n/**\n * Check if character is ASCII.\n *\n * @param character - Character.\n * @returns True if a character code is ASCII, false if not.\n */\nexport function isASCII(character) {\n    return character.charCodeAt(0) <= 127;\n}\n/**\n * Calculate string size.\n *\n * @param value - String value to calculate size.\n * @returns Number of bytes used to store whole string value.\n */\nexport function calculateStringSize(value) {\n    const size = value.split('').reduce((total, character) => {\n        if (isASCII(character)) {\n            return total + 1;\n        }\n        return total + 2;\n    }, 0);\n    // Also detect characters that need backslash escape\n    return size + (value.match(ESCAPE_CHARACTERS_REGEXP) ?? []).length;\n}\n/**\n * Calculate size of a number ofter JSON serialization.\n *\n * @param value - Number value to calculate size.\n * @returns Number of bytes used to store whole number in JSON.\n */\nexport function calculateNumberSize(value) {\n    return value.toString().length;\n}\n//# sourceMappingURL=misc.mjs.map","/**\n * A `StructFailure` represents a single specific failure in validation.\n */\n/**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */\nexport class StructError extends TypeError {\n    constructor(failure, failures) {\n        let cached;\n        const { message, explanation, ...rest } = failure;\n        const { path } = failure;\n        const cause = path.length === 0 ? message : `At path: ${path.join('.')} -- ${message}`;\n        super(explanation ?? cause);\n        if (explanation !== null && explanation !== undefined) {\n            this.cause = cause;\n        }\n        Object.assign(this, rest);\n        this.name = this.constructor.name;\n        this.failures = () => {\n            return (cached ?? (cached = [failure, ...failures()]));\n        };\n    }\n}\n//# sourceMappingURL=error.mjs.map","/**\n * Check if a value is an iterator.\n *\n * @param value - The value to check.\n * @returns Whether the value is an iterator.\n */\nfunction isIterable(value) {\n    return isObject(value) && typeof value[Symbol.iterator] === 'function';\n}\n/**\n * Check if a value is a plain object.\n *\n * @param value - The value to check.\n * @returns Whether the value is a plain object.\n */\nexport function isObject(value) {\n    return typeof value === 'object' && value !== null;\n}\n/**\n * Check if a value is a plain object.\n *\n * @param value - The value to check.\n * @returns Whether the value is a plain object.\n */\nexport function isPlainObject(value) {\n    if (Object.prototype.toString.call(value) !== '[object Object]') {\n        return false;\n    }\n    const prototype = Object.getPrototypeOf(value);\n    return prototype === null || prototype === Object.prototype;\n}\n/**\n * Return a value as a printable string.\n *\n * @param value - The value to print.\n * @returns The value as a string.\n */\nexport function print(value) {\n    if (typeof value === 'symbol') {\n        return value.toString();\n    }\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    return typeof value === 'string' ? JSON.stringify(value) : `${value}`;\n}\n/**\n * Shift (remove and return) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n *\n * @param input - The iterator to shift.\n * @returns The first value of the iterator, or `undefined` if the iterator is\n * empty.\n */\nexport function shiftIterator(input) {\n    const { done, value } = input.next();\n    return done ? undefined : value;\n}\n/**\n * Convert a single validation result to a failure.\n *\n * @param result - The result to convert.\n * @param context - The context of the validation.\n * @param struct - The struct being validated.\n * @param value - The value being validated.\n * @returns A failure if the result is a failure, or `undefined` if the result\n * is a success.\n */\nexport function toFailure(result, context, struct, value) {\n    if (result === true) {\n        return undefined;\n    }\n    else if (result === false) {\n        // eslint-disable-next-line no-param-reassign\n        result = {};\n    }\n    else if (typeof result === 'string') {\n        // eslint-disable-next-line no-param-reassign\n        result = { message: result };\n    }\n    const { path, branch } = context;\n    const { type } = struct;\n    const { refinement, message = `Expected a value of type \\`${type}\\`${refinement ? ` with refinement \\`${refinement}\\`` : ''}, but received: \\`${print(value)}\\``, } = result;\n    return {\n        value,\n        type,\n        refinement,\n        key: path[path.length - 1],\n        path,\n        branch,\n        ...result,\n        message,\n    };\n}\n/**\n * Convert a validation result to an iterable of failures.\n *\n * @param result - The result to convert.\n * @param context - The context of the validation.\n * @param struct - The struct being validated.\n * @param value - The value being validated.\n * @yields The failures.\n * @returns An iterable of failures.\n */\nexport function* toFailures(result, context, struct, value) {\n    if (!isIterable(result)) {\n        // eslint-disable-next-line no-param-reassign\n        result = [result];\n    }\n    for (const validationResult of result) {\n        const failure = toFailure(validationResult, context, struct, value);\n        if (failure) {\n            yield failure;\n        }\n    }\n}\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n *\n * @param value - The value to check.\n * @param struct - The struct to check against.\n * @param options - Optional settings.\n * @param options.path - The path to the value in the input data.\n * @param options.branch - The branch of the value in the input data.\n * @param options.coerce - Whether to coerce the value before validating it.\n * @param options.mask - Whether to mask the value before validating it.\n * @param options.message - An optional message to include in the error.\n * @yields An iterator of failures or success.\n * @returns An iterator of failures or success.\n */\nexport function* run(value, struct, options = {}) {\n    const { path = [], branch = [value], coerce = false, mask = false } = options;\n    const context = { path, branch };\n    if (coerce) {\n        // eslint-disable-next-line no-param-reassign\n        value = struct.coercer(value, context);\n        if (mask &&\n            struct.type !== 'type' &&\n            isObject(struct.schema) &&\n            isObject(value) &&\n            !Array.isArray(value)) {\n            for (const key in value) {\n                if (struct.schema[key] === undefined) {\n                    delete value[key];\n                }\n            }\n        }\n    }\n    let status = 'valid';\n    for (const failure of struct.validator(value, context)) {\n        failure.explanation = options.message;\n        status = 'not_valid';\n        yield [failure, undefined];\n    }\n    // eslint-disable-next-line prefer-const\n    for (let [innerKey, innerValue, innerStruct] of struct.entries(value, context)) {\n        const iterable = run(innerValue, innerStruct, {\n            path: innerKey === undefined ? path : [...path, innerKey],\n            branch: innerKey === undefined ? branch : [...branch, innerValue],\n            coerce,\n            mask,\n            message: options.message,\n        });\n        for (const result of iterable) {\n            if (result[0]) {\n                status =\n                    result[0].refinement === null || result[0].refinement === undefined\n                        ? 'not_valid'\n                        : 'not_refined';\n                yield [result[0], undefined];\n            }\n            else if (coerce) {\n                innerValue = result[1];\n                if (innerKey === undefined) {\n                    // eslint-disable-next-line no-param-reassign\n                    value = innerValue;\n                }\n                else if (value instanceof Map) {\n                    value.set(innerKey, innerValue);\n                }\n                else if (value instanceof Set) {\n                    value.add(innerValue);\n                }\n                else if (isObject(value)) {\n                    if (innerValue !== undefined || innerKey in value) {\n                        value[innerKey] = innerValue;\n                    }\n                }\n            }\n        }\n    }\n    if (status !== 'not_valid') {\n        for (const failure of struct.refiner(value, context)) {\n            failure.explanation = options.message;\n            status = 'not_refined';\n            yield [failure, undefined];\n        }\n    }\n    if (status === 'valid') {\n        yield [undefined, value];\n    }\n}\n//# sourceMappingURL=utils.mjs.map","import { StructError } from \"./error.mjs\";\nimport { toFailures, shiftIterator, run } from \"./utils.mjs\";\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */\nexport class Struct {\n    constructor(props) {\n        const { type, schema, validator, refiner, coercer = (value) => value, entries = function* () {\n            /* noop */\n        }, } = props;\n        this.type = type;\n        this.schema = schema;\n        this.entries = entries;\n        this.coercer = coercer;\n        if (validator) {\n            this.validator = (value, context) => {\n                const result = validator(value, context);\n                return toFailures(result, context, this, value);\n            };\n        }\n        else {\n            this.validator = () => [];\n        }\n        if (refiner) {\n            this.refiner = (value, context) => {\n                const result = refiner(value, context);\n                return toFailures(result, context, this, value);\n            };\n        }\n        else {\n            this.refiner = () => [];\n        }\n    }\n    /**\n     * Assert that a value passes the struct's validation, throwing if it doesn't.\n     */\n    assert(value, message) {\n        return assert(value, this, message);\n    }\n    /**\n     * Create a value with the struct's coercion logic, then validate it.\n     */\n    create(value, message) {\n        return create(value, this, message);\n    }\n    /**\n     * Check if a value passes the struct's validation.\n     */\n    is(value) {\n        return is(value, this);\n    }\n    /**\n     * Mask a value, coercing and validating it, but returning only the subset of\n     * properties defined by the struct's schema.\n     */\n    mask(value, message) {\n        return mask(value, this, message);\n    }\n    /**\n     * Validate a value with the struct's validation logic, returning a tuple\n     * representing the result.\n     *\n     * You may optionally pass `true` for the `withCoercion` argument to coerce\n     * the value before attempting to validate it. If you do, the result will\n     * contain the coerced result when successful.\n     */\n    validate(value, options = {}) {\n        return validate(value, this, options);\n    }\n}\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n *\n * @param value - The value to validate.\n * @param struct - The struct to validate against.\n * @param message - An optional message to include in the error.\n */\nexport function assert(value, struct, message) {\n    const result = validate(value, struct, { message });\n    if (result[0]) {\n        throw result[0];\n    }\n}\n/**\n * Create a value with the coercion logic of struct and validate it.\n *\n * @param value - The value to coerce and validate.\n * @param struct - The struct to validate against.\n * @param message - An optional message to include in the error.\n * @returns The coerced and validated value.\n */\nexport function create(value, struct, message) {\n    const result = validate(value, struct, { coerce: true, message });\n    if (result[0]) {\n        throw result[0];\n    }\n    else {\n        return result[1];\n    }\n}\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n *\n * @param value - The value to mask.\n * @param struct - The struct to mask against.\n * @param message - An optional message to include in the error.\n * @returns The masked value.\n */\nexport function mask(value, struct, message) {\n    const result = validate(value, struct, { coerce: true, mask: true, message });\n    if (result[0]) {\n        throw result[0];\n    }\n    else {\n        return result[1];\n    }\n}\n/**\n * Check if a value passes a struct.\n *\n * @param value - The value to validate.\n * @param struct - The struct to validate against.\n * @returns `true` if the value passes the struct, `false` otherwise.\n */\nexport function is(value, struct) {\n    const result = validate(value, struct);\n    return !result[0];\n}\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n *\n * @param value - The value to validate.\n * @param struct - The struct to validate against.\n * @param options - Optional settings.\n * @param options.coerce - Whether to coerce the value before validating it.\n * @param options.mask - Whether to mask the value before validating it.\n * @param options.message - An optional message to include in the error.\n * @returns A tuple containing the error (if invalid) and the validated value.\n */\nexport function validate(value, struct, options = {}) {\n    const tuples = run(value, struct, options);\n    const tuple = shiftIterator(tuples);\n    if (tuple[0]) {\n        const error = new StructError(tuple[0], function* () {\n            for (const innerTuple of tuples) {\n                if (innerTuple[0]) {\n                    yield innerTuple[0];\n                }\n            }\n        });\n        return [error, undefined];\n    }\n    const validatedValue = tuple[1];\n    return [undefined, validatedValue];\n}\n//# sourceMappingURL=struct.mjs.map","import { Struct } from \"../struct.mjs\";\nimport { object, optional, type } from \"./types.mjs\";\n/**\n * Create a new struct that combines the properties from multiple object or type\n * structs. Its return type will match the first parameter's type.\n *\n * @param Structs - The structs to combine.\n * @returns A new struct that combines the properties of the input structs.\n */\nexport function assign(...Structs) {\n    const isType = Structs[0]?.type === 'type';\n    const schemas = Structs.map(({ schema }) => schema);\n    const schema = Object.assign({}, ...schemas);\n    return isType ? type(schema) : object(schema);\n}\n/**\n * Define a new struct type with a custom validation function.\n *\n * @param name - The name of the struct type.\n * @param validator - The validation function.\n * @returns A new struct type.\n */\nexport function define(name, validator) {\n    return new Struct({ type: name, schema: null, validator });\n}\n/**\n * Create a new struct based on an existing struct, but the value is allowed to\n * be `undefined`. `log` will be called if the value is not `undefined`.\n *\n * @param struct - The struct to augment.\n * @param log - The function to call when the value is not `undefined`.\n * @returns A new struct that will only accept `undefined` or values that pass\n * the input struct.\n */\nexport function deprecated(struct, log) {\n    return new Struct({\n        ...struct,\n        refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n        validator(value, ctx) {\n            if (value === undefined) {\n                return true;\n            }\n            log(value, ctx);\n            return struct.validator(value, ctx);\n        },\n    });\n}\n/**\n * Create a struct with dynamic validation logic.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n *\n * @param fn - The callback to create the struct.\n * @returns A new struct with dynamic validation logic.\n */\nexport function dynamic(fn) {\n    return new Struct({\n        type: 'dynamic',\n        schema: null,\n        *entries(value, ctx) {\n            const struct = fn(value, ctx);\n            yield* struct.entries(value, ctx);\n        },\n        validator(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.validator(value, ctx);\n        },\n        coercer(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.coercer(value, ctx);\n        },\n        refiner(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.refiner(value, ctx);\n        },\n    });\n}\n/**\n * Create a struct with lazily evaluated validation logic.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n *\n * @param fn - The callback to create the struct.\n * @returns A new struct with lazily evaluated validation logic.\n */\nexport function lazy(fn) {\n    let struct;\n    return new Struct({\n        type: 'lazy',\n        schema: null,\n        *entries(value, ctx) {\n            struct ?? (struct = fn());\n            yield* struct.entries(value, ctx);\n        },\n        validator(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.validator(value, ctx);\n        },\n        coercer(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.coercer(value, ctx);\n        },\n        refiner(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.refiner(value, ctx);\n        },\n    });\n}\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n *\n * @param struct - The struct to augment.\n * @param keys - The keys to omit.\n * @returns A new struct that will not accept the input keys.\n */\nexport function omit(struct, keys) {\n    const { schema } = struct;\n    const subschema = { ...schema };\n    for (const key of keys) {\n        delete subschema[key];\n    }\n    switch (struct.type) {\n        case 'type':\n            return type(subschema);\n        default:\n            return object(subschema);\n    }\n}\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that will accept the input keys as `undefined`.\n */\nexport function partial(struct) {\n    const isStruct = struct instanceof Struct;\n    const schema = isStruct ? { ...struct.schema } : { ...struct };\n    // eslint-disable-next-line guard-for-in\n    for (const key in schema) {\n        schema[key] = optional(schema[key]);\n    }\n    if (isStruct && struct.type === 'type') {\n        return type(schema);\n    }\n    return object(schema);\n}\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n *\n * @param struct - The struct to augment.\n * @param keys - The keys to pick.\n * @returns A new struct that will only accept the input keys.\n */\nexport function pick(struct, keys) {\n    const { schema } = struct;\n    const subschema = {};\n    for (const key of keys) {\n        subschema[key] = schema[key];\n    }\n    switch (struct.type) {\n        case 'type':\n            return type(subschema);\n        default:\n            return object(subschema);\n    }\n}\n//# sourceMappingURL=utilities.mjs.map","import { Struct } from \"../struct.mjs\";\nimport { print, run, isObject } from \"../utils.mjs\";\nimport { define } from \"./utilities.mjs\";\n/**\n * Ensure that any value passes validation.\n *\n * @returns A struct that will always pass validation.\n */\nexport function any() {\n    return define('any', () => true);\n}\n/**\n * Ensure that a value is an array and that its elements are of a specific type.\n *\n * Note: If you omit the element struct, the arrays elements will not be\n * iterated at all. This can be helpful for cases where performance is critical,\n * and it is preferred to using `array(any())`.\n *\n * @param Element - The struct to validate each element in the array against.\n * @returns A new struct that will only accept arrays of the given type.\n */\nexport function array(Element) {\n    return new Struct({\n        type: 'array',\n        schema: Element,\n        *entries(value) {\n            if (Element && Array.isArray(value)) {\n                for (const [index, arrayValue] of value.entries()) {\n                    yield [index, arrayValue, Element];\n                }\n            }\n        },\n        coercer(value) {\n            return Array.isArray(value) ? value.slice() : value;\n        },\n        validator(value) {\n            return (Array.isArray(value) ||\n                `Expected an array value, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a bigint.\n *\n * @returns A new struct that will only accept bigints.\n */\nexport function bigint() {\n    return define('bigint', (value) => {\n        return typeof value === 'bigint';\n    });\n}\n/**\n * Ensure that a value is a boolean.\n *\n * @returns A new struct that will only accept booleans.\n */\nexport function boolean() {\n    return define('boolean', (value) => {\n        return typeof value === 'boolean';\n    });\n}\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n *\n * @returns A new struct that will only accept valid `Date` objects.\n */\nexport function date() {\n    return define('date', (value) => {\n        return ((value instanceof Date && !isNaN(value.getTime())) ||\n            `Expected a valid \\`Date\\` object, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is one of a set of potential values.\n *\n * Note: after creating the struct, you can access the definition of the\n * potential values as `struct.schema`.\n *\n * @param values - The potential values that the input can be.\n * @returns A new struct that will only accept the given values.\n */\nexport function enums(values) {\n    const schema = {};\n    const description = values.map((value) => print(value)).join();\n    for (const key of values) {\n        schema[key] = key;\n    }\n    return new Struct({\n        type: 'enums',\n        schema,\n        validator(value) {\n            return (values.includes(value) ||\n                `Expected one of \\`${description}\\`, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a function.\n *\n * @returns A new struct that will only accept functions.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function func() {\n    return define('func', (value) => {\n        return (typeof value === 'function' ||\n            `Expected a function, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is an instance of a specific class.\n *\n * @param Class - The class that the value must be an instance of.\n * @returns A new struct that will only accept instances of the given class.\n */\nexport function instance(Class) {\n    return define('instance', (value) => {\n        return (value instanceof Class ||\n            `Expected a \\`${Class.name}\\` instance, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is an integer.\n *\n * @returns A new struct that will only accept integers.\n */\nexport function integer() {\n    return define('integer', (value) => {\n        return ((typeof value === 'number' && !isNaN(value) && Number.isInteger(value)) ||\n            `Expected an integer, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value matches all of a set of types.\n *\n * @param Structs - The set of structs that the value must match.\n * @returns A new struct that will only accept values that match all of the\n * given structs.\n */\nexport function intersection(Structs) {\n    return new Struct({\n        type: 'intersection',\n        schema: null,\n        *entries(value, context) {\n            for (const { entries } of Structs) {\n                yield* entries(value, context);\n            }\n        },\n        *validator(value, context) {\n            for (const { validator } of Structs) {\n                yield* validator(value, context);\n            }\n        },\n        *refiner(value, context) {\n            for (const { refiner } of Structs) {\n                yield* refiner(value, context);\n            }\n        },\n    });\n}\n/**\n * Ensure that a value is an exact value, using `===` for comparison.\n *\n * @param constant - The exact value that the input must be.\n * @returns A new struct that will only accept the exact given value.\n */\nexport function literal(constant) {\n    const description = print(constant);\n    const valueType = typeof constant;\n    return new Struct({\n        type: 'literal',\n        schema: valueType === 'string' ||\n            valueType === 'number' ||\n            valueType === 'boolean'\n            ? constant\n            : null,\n        validator(value) {\n            return (value === constant ||\n                `Expected the literal \\`${description}\\`, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a `Map` object, and that its keys and values are of\n * specific types.\n *\n * @param Key - The struct to validate each key in the map against.\n * @param Value - The struct to validate each value in the map against.\n * @returns A new struct that will only accept `Map` objects.\n */\nexport function map(Key, Value) {\n    return new Struct({\n        type: 'map',\n        schema: null,\n        *entries(value) {\n            if (Key && Value && value instanceof Map) {\n                for (const [mapKey, mapValue] of value.entries()) {\n                    yield [mapKey, mapKey, Key];\n                    yield [mapKey, mapValue, Value];\n                }\n            }\n        },\n        coercer(value) {\n            return value instanceof Map ? new Map(value) : value;\n        },\n        validator(value) {\n            return (value instanceof Map ||\n                `Expected a \\`Map\\` object, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that no value ever passes validation.\n *\n * @returns A new struct that will never pass validation.\n */\nexport function never() {\n    return define('never', () => false);\n}\n/**\n * Augment an existing struct to allow `null` values.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that will accept `null` values.\n */\nexport function nullable(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx) => value === null || struct.validator(value, ctx),\n        refiner: (value, ctx) => value === null || struct.refiner(value, ctx),\n    });\n}\n/**\n * Ensure that a value is a number.\n *\n * @returns A new struct that will only accept numbers.\n */\nexport function number() {\n    return define('number', (value) => {\n        return ((typeof value === 'number' && !isNaN(value)) ||\n            `Expected a number, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is an object, that it has a known set of properties,\n * and that its properties are of specific types.\n *\n * Note: Unrecognized properties will fail validation.\n *\n * @param schema - An object that defines the structure of the object.\n * @returns A new struct that will only accept objects.\n */\nexport function object(schema) {\n    const knowns = schema ? Object.keys(schema) : [];\n    const Never = never();\n    return new Struct({\n        type: 'object',\n        schema: schema ?? null,\n        *entries(value) {\n            if (schema && isObject(value)) {\n                const unknowns = new Set(Object.keys(value));\n                for (const key of knowns) {\n                    unknowns.delete(key);\n                    yield [key, value[key], schema[key]];\n                }\n                for (const key of unknowns) {\n                    yield [key, value[key], Never];\n                }\n            }\n        },\n        validator(value) {\n            return (isObject(value) || `Expected an object, but received: ${print(value)}`);\n        },\n        coercer(value) {\n            return isObject(value) ? { ...value } : value;\n        },\n    });\n}\n/**\n * Augment a struct to allow `undefined` values.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that will accept `undefined` values.\n */\nexport function optional(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx) => value === undefined || struct.validator(value, ctx),\n        refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n    });\n}\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * @param Key - The struct to validate each key in the record against.\n * @param Value - The struct to validate each value in the record against.\n * @returns A new struct that will only accept objects.\n */\nexport function record(Key, Value) {\n    return new Struct({\n        type: 'record',\n        schema: null,\n        *entries(value) {\n            if (isObject(value)) {\n                // eslint-disable-next-line guard-for-in\n                for (const objectKey in value) {\n                    const objectValue = value[objectKey];\n                    yield [objectKey, objectKey, Key];\n                    yield [objectKey, objectValue, Value];\n                }\n            }\n        },\n        validator(value) {\n            return (isObject(value) || `Expected an object, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n *\n * @returns A new struct that will only accept `RegExp` objects.\n */\nexport function regexp() {\n    return define('regexp', (value) => {\n        return value instanceof RegExp;\n    });\n}\n/**\n * Ensure that a value is a `Set` object, and that its elements are of a\n * specific type.\n *\n * @param Element - The struct to validate each element in the set against.\n * @returns A new struct that will only accept `Set` objects.\n */\nexport function set(Element) {\n    return new Struct({\n        type: 'set',\n        schema: null,\n        *entries(value) {\n            if (Element && value instanceof Set) {\n                for (const setValue of value) {\n                    yield [setValue, setValue, Element];\n                }\n            }\n        },\n        coercer(value) {\n            return value instanceof Set ? new Set(value) : value;\n        },\n        validator(value) {\n            return (value instanceof Set ||\n                `Expected a \\`Set\\` object, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a string.\n *\n * @returns A new struct that will only accept strings.\n */\nexport function string() {\n    return define('string', (value) => {\n        return (typeof value === 'string' ||\n            `Expected a string, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is a tuple of a specific length, and that each of its\n * elements is of a specific type.\n *\n * @param Structs - The set of structs that the value must match.\n * @returns A new struct that will only accept tuples of the given types.\n */\nexport function tuple(Structs) {\n    const Never = never();\n    return new Struct({\n        type: 'tuple',\n        schema: null,\n        *entries(value) {\n            if (Array.isArray(value)) {\n                const length = Math.max(Structs.length, value.length);\n                for (let i = 0; i < length; i++) {\n                    yield [i, value[i], Structs[i] || Never];\n                }\n            }\n        },\n        validator(value) {\n            return (Array.isArray(value) ||\n                `Expected an array, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n *\n * @param schema - An object that defines the structure of the object.\n * @returns A new struct that will only accept objects.\n */\nexport function type(schema) {\n    const keys = Object.keys(schema);\n    return new Struct({\n        type: 'type',\n        schema,\n        *entries(value) {\n            if (isObject(value)) {\n                for (const k of keys) {\n                    yield [k, value[k], schema[k]];\n                }\n            }\n        },\n        validator(value) {\n            return (isObject(value) || `Expected an object, but received: ${print(value)}`);\n        },\n        coercer(value) {\n            return isObject(value) ? { ...value } : value;\n        },\n    });\n}\n/**\n * Ensure that a value matches one of a set of types.\n *\n * @param Structs - The set of structs that the value must match.\n * @returns A new struct that will only accept values that match one of the\n * given structs.\n */\nexport function union(Structs) {\n    const description = Structs.map((struct) => struct.type).join(' | ');\n    return new Struct({\n        type: 'union',\n        schema: null,\n        coercer(value) {\n            for (const InnerStruct of Structs) {\n                const [error, coerced] = InnerStruct.validate(value, { coerce: true });\n                if (!error) {\n                    return coerced;\n                }\n            }\n            return value;\n        },\n        validator(value, ctx) {\n            const failures = [];\n            for (const InnerStruct of Structs) {\n                const [...tuples] = run(value, InnerStruct, ctx);\n                const [first] = tuples;\n                if (!first?.[0]) {\n                    return [];\n                }\n                for (const [failure] of tuples) {\n                    if (failure) {\n                        failures.push(failure);\n                    }\n                }\n            }\n            return [\n                `Expected the value to satisfy a union of \\`${description}\\`, but received: ${print(value)}`,\n                ...failures,\n            ];\n        },\n    });\n}\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n *\n * @returns A struct that will always pass validation.\n */\nexport function unknown() {\n    return define('unknown', () => true);\n}\n//# sourceMappingURL=types.mjs.map","import { Struct, is } from \"../struct.mjs\";\nimport { isPlainObject } from \"../utils.mjs\";\nimport { string, unknown } from \"./types.mjs\";\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validation—for example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n *\n * @param struct - The struct to augment.\n * @param condition - A struct that the input must pass to be coerced.\n * @param coercer - A function that takes the input and returns the coerced\n * value.\n * @returns A new struct that will coerce its input before validating it.\n */\nexport function coerce(struct, condition, coercer) {\n    return new Struct({\n        ...struct,\n        coercer: (value, ctx) => {\n            return is(value, condition)\n                ? struct.coercer(coercer(value, ctx), ctx)\n                : struct.coercer(value, ctx);\n        },\n    });\n}\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n *\n * @param struct - The struct to augment.\n * @param fallback - The value to use when the input is `undefined`.\n * @param options - An optional options object.\n * @param options.strict - When `true`, the fallback will only be used when the\n * input is `undefined`. When `false`, the fallback will be used when the input\n * is `undefined` or when the input is a plain object and the fallback is a\n * plain object, and any keys in the fallback are missing from the input.\n * @returns A new struct that will replace `undefined` inputs with a default.\n */\nexport function defaulted(struct, fallback, options = {}) {\n    return coerce(struct, unknown(), (value) => {\n        const result = typeof fallback === 'function' ? fallback() : fallback;\n        if (value === undefined) {\n            return result;\n        }\n        if (!options.strict && isPlainObject(value) && isPlainObject(result)) {\n            const ret = { ...value };\n            let changed = false;\n            for (const key in result) {\n                if (ret[key] === undefined) {\n                    ret[key] = result[key];\n                    changed = true;\n                }\n            }\n            if (changed) {\n                return ret;\n            }\n        }\n        return value;\n    });\n}\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that will trim string inputs before validating them.\n */\nexport function trimmed(struct) {\n    return coerce(struct, string(), (value) => value.trim());\n}\n//# sourceMappingURL=coercions.mjs.map","import { assert as assertSuperstruct } from \"@metamask/superstruct\";\nimport { getErrorMessage } from \"./errors.mjs\";\n/**\n * Check if a value is a constructor, i.e., a function that can be called with\n * the `new` keyword.\n *\n * @param fn - The value to check.\n * @returns `true` if the value is a constructor, or `false` otherwise.\n */\nfunction isConstructable(fn) {\n    /* istanbul ignore next */\n    return Boolean(typeof fn?.prototype?.constructor?.name === 'string');\n}\n/**\n * Attempts to obtain the message from a possible error object. If it is\n * possible to do so, any trailing period will be removed from the message;\n * otherwise an empty string is returned.\n *\n * @param error - The error object to get the message from.\n * @returns The message without any trailing period if `error` is an object\n * with a `message` property; the string version of `error` without any trailing\n * period if it is not `undefined` or `null`; otherwise an empty string.\n */\nfunction getErrorMessageWithoutTrailingPeriod(error) {\n    // We'll add our own period.\n    return getErrorMessage(error).replace(/\\.$/u, '');\n}\n/**\n * Initialise an {@link AssertionErrorConstructor} error.\n *\n * @param ErrorWrapper - The error class to use.\n * @param message - The error message.\n * @returns The error object.\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction getError(ErrorWrapper, message) {\n    if (isConstructable(ErrorWrapper)) {\n        return new ErrorWrapper({\n            message,\n        });\n    }\n    return ErrorWrapper({\n        message,\n    });\n}\n/**\n * The default error class that is thrown if an assertion fails.\n */\nexport class AssertionError extends Error {\n    constructor(options) {\n        super(options.message);\n        this.code = 'ERR_ASSERTION';\n    }\n}\n/**\n * Same as Node.js assert.\n * If the value is falsy, throws an error, does nothing otherwise.\n *\n * @throws {@link AssertionError} If value is falsy.\n * @param value - The test that should be truthy to pass.\n * @param message - Message to be passed to {@link AssertionError} or an\n * {@link Error} instance to throw.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}. If a custom error class is provided for\n * the `message` argument, this argument is ignored.\n */\nexport function assert(value, message = 'Assertion failed.', \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper = AssertionError) {\n    if (!value) {\n        if (message instanceof Error) {\n            throw message;\n        }\n        throw getError(ErrorWrapper, message);\n    }\n}\n/**\n * Assert a value against a Superstruct struct.\n *\n * @param value - The value to validate.\n * @param struct - The struct to validate against.\n * @param errorPrefix - A prefix to add to the error message. Defaults to\n * \"Assertion failed\".\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the value is not valid.\n */\nexport function assertStruct(value, struct, errorPrefix = 'Assertion failed', \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper = AssertionError) {\n    try {\n        assertSuperstruct(value, struct);\n    }\n    catch (error) {\n        throw getError(ErrorWrapper, `${errorPrefix}: ${getErrorMessageWithoutTrailingPeriod(error)}.`);\n    }\n}\n/**\n * Use in the default case of a switch that you want to be fully exhaustive.\n * Using this function forces the compiler to enforce exhaustivity during\n * compile-time.\n *\n * @example\n * ```\n * const number = 1;\n * switch (number) {\n *   case 0:\n *     ...\n *   case 1:\n *     ...\n *   default:\n *     assertExhaustive(snapPrefix);\n * }\n * ```\n * @param _object - The object on which the switch is being operated.\n */\nexport function assertExhaustive(_object) {\n    throw new Error('Invalid branch reached. Should be detected during compilation.');\n}\n//# sourceMappingURL=assert.mjs.map","import { ErrorWithCause } from \"pony-cause\";\nimport { isNullOrUndefined, isObject } from \"./misc.mjs\";\n/**\n * Type guard for determining whether the given value is an instance of Error.\n * For errors generated via `fs.promises`, `error instanceof Error` won't work,\n * so we have to come up with another way of testing.\n *\n * @param error - The object to check.\n * @returns A boolean.\n */\nfunction isError(error) {\n    return (error instanceof Error ||\n        (isObject(error) && error.constructor.name === 'Error'));\n}\n/**\n * Type guard for determining whether the given value is an error object with a\n * `code` property such as the type of error that Node throws for filesystem\n * operations, etc.\n *\n * @param error - The object to check.\n * @returns A boolean.\n */\nexport function isErrorWithCode(error) {\n    return typeof error === 'object' && error !== null && 'code' in error;\n}\n/**\n * Type guard for determining whether the given value is an error object with a\n * `message` property, such as an instance of Error.\n *\n * @param error - The object to check.\n * @returns A boolean.\n */\nexport function isErrorWithMessage(error) {\n    return typeof error === 'object' && error !== null && 'message' in error;\n}\n/**\n * Type guard for determining whether the given value is an error object with a\n * `stack` property, such as an instance of Error.\n *\n * @param error - The object to check.\n * @returns A boolean.\n */\nexport function isErrorWithStack(error) {\n    return typeof error === 'object' && error !== null && 'stack' in error;\n}\n/**\n * Attempts to obtain the message from a possible error object, defaulting to an\n * empty string if it is impossible to do so.\n *\n * @param error - The possible error to get the message from.\n * @returns The message if `error` is an object with a `message` property;\n * the string version of `error` if it is not `undefined` or `null`; otherwise\n * an empty string.\n */\nexport function getErrorMessage(error) {\n    if (isErrorWithMessage(error) && typeof error.message === 'string') {\n        return error.message;\n    }\n    if (isNullOrUndefined(error)) {\n        return '';\n    }\n    return String(error);\n}\n/**\n * Builds a new error object, linking it to the original error via the `cause`\n * property if it is an Error.\n *\n * This function is useful to reframe error messages in general, but is\n * _critical_ when interacting with any of Node's filesystem functions as\n * provided via `fs.promises`, because these do not produce stack traces in the\n * case of an I/O error (see <https://github.com/nodejs/node/issues/30944>).\n *\n * @param originalError - The error to be wrapped (something throwable).\n * @param message - The desired message of the new error.\n * @returns A new error object.\n */\nexport function wrapError(originalError, message) {\n    if (isError(originalError)) {\n        let error;\n        if (Error.length === 2) {\n            // for some reason `tsserver` is not complaining that the\n            // Error constructor doesn't support a second argument in the editor,\n            // but `tsc` does. Error causes are not supported by our current tsc target (ES2020, we need ES2022 to make this work)\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            error = new Error(message, { cause: originalError });\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            error = new ErrorWithCause(message, { cause: originalError });\n        }\n        if (isErrorWithCode(originalError)) {\n            error.code = originalError.code;\n        }\n        return error;\n    }\n    if (message.length > 0) {\n        return new Error(`${String(originalError)}: ${message}`);\n    }\n    return new Error(String(originalError));\n}\n//# sourceMappingURL=errors.mjs.map","import { any, array, boolean, coerce, create, define, integer, is, lazy, literal, nullable, number, object as superstructObject, optional, record, string, union, unknown, Struct } from \"@metamask/superstruct\";\nimport { assertStruct } from \"./assert.mjs\";\nimport { hasProperty } from \"./misc.mjs\";\n/**\n * A struct to check if the given value is a valid object, with support for\n * {@link exactOptional} types.\n *\n * @param schema - The schema of the object.\n * @returns A struct to check if the given value is an object.\n */\nexport const object = (schema) => \n// The type is slightly different from a regular object struct, because we\n// want to make properties with `undefined` in their type optional, but not\n// `undefined` itself. This means that we need a type cast.\nsuperstructObject(schema);\n/**\n * Check the last field of a path is present.\n *\n * @param context - The context to check.\n * @param context.path - The path to check.\n * @param context.branch - The branch to check.\n * @returns Whether the last field of a path is present.\n */\nfunction hasOptional({ path, branch }) {\n    const field = path[path.length - 1];\n    return hasProperty(branch[branch.length - 2], field);\n}\n/**\n * A struct which allows the property of an object to be absent, or to be present\n * as long as it's valid and not set to `undefined`.\n *\n * This struct should be used in conjunction with the {@link object} from this\n * library, to get proper type inference.\n *\n * @param struct - The struct to check the value against, if present.\n * @returns A struct to check if the given value is valid, or not present.\n * @example\n * ```ts\n * const struct = object({\n *   foo: exactOptional(string()),\n *   bar: exactOptional(number()),\n *   baz: optional(boolean()),\n *   qux: unknown(),\n * });\n *\n * type Type = Infer<typeof struct>;\n * // Type is equivalent to:\n * // {\n * //   foo?: string;\n * //   bar?: number;\n * //   baz?: boolean | undefined;\n * //   qux: unknown;\n * // }\n * ```\n */\nexport function exactOptional(struct) {\n    return new Struct({\n        ...struct,\n        type: `optional ${struct.type}`,\n        validator: (value, context) => !hasOptional(context) || struct.validator(value, context),\n        refiner: (value, context) => !hasOptional(context) || struct.refiner(value, context),\n    });\n}\n/**\n * A struct to check if the given value is finite number. Superstruct's\n * `number()` struct does not check if the value is finite.\n *\n * @returns A struct to check if the given value is finite number.\n */\nconst finiteNumber = () => define('finite number', (value) => {\n    return is(value, number()) && Number.isFinite(value);\n});\n/**\n * A struct to check if the given value is a valid JSON-serializable value.\n *\n * Note that this struct is unsafe. For safe validation, use {@link JsonStruct}.\n */\n// We cannot infer the type of the struct, because it is recursive.\nexport const UnsafeJsonStruct = union([\n    literal(null),\n    boolean(),\n    finiteNumber(),\n    string(),\n    array(lazy(() => UnsafeJsonStruct)),\n    record(string(), lazy(() => UnsafeJsonStruct)),\n]);\n/**\n * A struct to check if the given value is a valid JSON-serializable value.\n *\n * This struct sanitizes the value before validating it, so that it is safe to\n * use with untrusted input.\n */\nexport const JsonStruct = coerce(UnsafeJsonStruct, any(), (value) => {\n    assertStruct(value, UnsafeJsonStruct);\n    return JSON.parse(JSON.stringify(value, (propKey, propValue) => {\n        // Strip __proto__ and constructor properties to prevent prototype pollution.\n        if (propKey === '__proto__' || propKey === 'constructor') {\n            return undefined;\n        }\n        return propValue;\n    }));\n});\n/**\n * Check if the given value is a valid {@link Json} value, i.e., a value that is\n * serializable to JSON.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid {@link Json} value.\n */\nexport function isValidJson(value) {\n    try {\n        getSafeJson(value);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Validate and return sanitized JSON.\n *\n * Note:\n * This function uses sanitized JsonStruct for validation\n * that applies stringify and then parse of a value provided\n * to ensure that there are no getters which can have side effects\n * that can cause security issues.\n *\n * @param value - JSON structure to be processed.\n * @returns Sanitized JSON structure.\n */\nexport function getSafeJson(value) {\n    return create(value, JsonStruct);\n}\n/**\n * Get the size of a JSON value in bytes. This also validates the value.\n *\n * @param value - The JSON value to get the size of.\n * @returns The size of the JSON value in bytes.\n */\nexport function getJsonSize(value) {\n    assertStruct(value, JsonStruct, 'Invalid JSON value');\n    const json = JSON.stringify(value);\n    return new TextEncoder().encode(json).byteLength;\n}\n/**\n * The string '2.0'.\n */\nexport const jsonrpc2 = '2.0';\nexport const JsonRpcVersionStruct = literal(jsonrpc2);\nexport const JsonRpcIdStruct = nullable(union([number(), string()]));\nexport const JsonRpcErrorStruct = object({\n    code: integer(),\n    message: string(),\n    data: exactOptional(JsonStruct),\n    stack: exactOptional(string()),\n});\nexport const JsonRpcParamsStruct = union([record(string(), JsonStruct), array(JsonStruct)]);\nexport const JsonRpcRequestStruct = object({\n    id: JsonRpcIdStruct,\n    jsonrpc: JsonRpcVersionStruct,\n    method: string(),\n    params: exactOptional(JsonRpcParamsStruct),\n});\nexport const JsonRpcNotificationStruct = object({\n    jsonrpc: JsonRpcVersionStruct,\n    method: string(),\n    params: exactOptional(JsonRpcParamsStruct),\n});\n/**\n * Check if the given value is a valid {@link JsonRpcNotification} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcNotification}\n * object.\n */\nexport function isJsonRpcNotification(value) {\n    return is(value, JsonRpcNotificationStruct);\n}\n/**\n * Assert that the given value is a valid {@link JsonRpcNotification} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcNotification} object.\n */\nexport function assertIsJsonRpcNotification(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    assertStruct(value, JsonRpcNotificationStruct, 'Invalid JSON-RPC notification', ErrorWrapper);\n}\n/**\n * Check if the given value is a valid {@link JsonRpcRequest} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcRequest} object.\n */\nexport function isJsonRpcRequest(value) {\n    return is(value, JsonRpcRequestStruct);\n}\n/**\n * Assert that the given value is a valid {@link JsonRpcRequest} object.\n *\n * @param value - The JSON-RPC request or notification to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcRequest} object.\n */\nexport function assertIsJsonRpcRequest(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    assertStruct(value, JsonRpcRequestStruct, 'Invalid JSON-RPC request', ErrorWrapper);\n}\nexport const PendingJsonRpcResponseStruct = superstructObject({\n    id: JsonRpcIdStruct,\n    jsonrpc: JsonRpcVersionStruct,\n    result: optional(unknown()),\n    error: optional(JsonRpcErrorStruct),\n});\nexport const JsonRpcSuccessStruct = object({\n    id: JsonRpcIdStruct,\n    jsonrpc: JsonRpcVersionStruct,\n    result: JsonStruct,\n});\nexport const JsonRpcFailureStruct = object({\n    id: JsonRpcIdStruct,\n    jsonrpc: JsonRpcVersionStruct,\n    error: JsonRpcErrorStruct,\n});\nexport const JsonRpcResponseStruct = union([\n    JsonRpcSuccessStruct,\n    JsonRpcFailureStruct,\n]);\n/**\n * Type guard to check whether specified JSON-RPC response is a\n * {@link PendingJsonRpcResponse}.\n *\n * @param response - The JSON-RPC response to check.\n * @returns Whether the specified JSON-RPC response is pending.\n */\nexport function isPendingJsonRpcResponse(response) {\n    return is(response, PendingJsonRpcResponseStruct);\n}\n/**\n * Assert that the given value is a valid {@link PendingJsonRpcResponse} object.\n *\n * @param response - The JSON-RPC response to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link PendingJsonRpcResponse}\n * object.\n */\nexport function assertIsPendingJsonRpcResponse(response, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    assertStruct(response, PendingJsonRpcResponseStruct, 'Invalid pending JSON-RPC response', ErrorWrapper);\n}\n/**\n * Type guard to check if a value is a {@link JsonRpcResponse}.\n *\n * @param response - The object to check.\n * @returns Whether the object is a JsonRpcResponse.\n */\nexport function isJsonRpcResponse(response) {\n    return is(response, JsonRpcResponseStruct);\n}\n/**\n * Assert that the given value is a valid {@link JsonRpcResponse} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcResponse} object.\n */\nexport function assertIsJsonRpcResponse(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    assertStruct(value, JsonRpcResponseStruct, 'Invalid JSON-RPC response', ErrorWrapper);\n}\n/**\n * Check if the given value is a valid {@link JsonRpcSuccess} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcSuccess} object.\n */\nexport function isJsonRpcSuccess(value) {\n    return is(value, JsonRpcSuccessStruct);\n}\n/**\n * Assert that the given value is a valid {@link JsonRpcSuccess} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcSuccess} object.\n */\nexport function assertIsJsonRpcSuccess(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    assertStruct(value, JsonRpcSuccessStruct, 'Invalid JSON-RPC success response', ErrorWrapper);\n}\n/**\n * Check if the given value is a valid {@link JsonRpcFailure} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcFailure} object.\n */\nexport function isJsonRpcFailure(value) {\n    return is(value, JsonRpcFailureStruct);\n}\n/**\n * Assert that the given value is a valid {@link JsonRpcFailure} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcFailure} object.\n */\nexport function assertIsJsonRpcFailure(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    assertStruct(value, JsonRpcFailureStruct, 'Invalid JSON-RPC failure response', ErrorWrapper);\n}\n/**\n * Check if the given value is a valid {@link JsonRpcError} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcError} object.\n */\nexport function isJsonRpcError(value) {\n    return is(value, JsonRpcErrorStruct);\n}\n/**\n * Assert that the given value is a valid {@link JsonRpcError} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcError} object.\n */\nexport function assertIsJsonRpcError(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    assertStruct(value, JsonRpcErrorStruct, 'Invalid JSON-RPC error', ErrorWrapper);\n}\n/**\n * Gets a function for validating JSON-RPC request / response `id` values.\n *\n * By manipulating the options of this factory, you can control the behavior\n * of the resulting validator for some edge cases. This is useful because e.g.\n * `null` should sometimes but not always be permitted.\n *\n * Note that the empty string (`''`) is always permitted by the JSON-RPC\n * specification, but that kind of sucks and you may want to forbid it in some\n * instances anyway.\n *\n * For more details, see the\n * [JSON-RPC Specification](https://www.jsonrpc.org/specification).\n *\n * @param options - An options object.\n * @param options.permitEmptyString - Whether the empty string (i.e. `''`)\n * should be treated as a valid ID. Default: `true`\n * @param options.permitFractions - Whether fractional numbers (e.g. `1.2`)\n * should be treated as valid IDs. Default: `false`\n * @param options.permitNull - Whether `null` should be treated as a valid ID.\n * Default: `true`\n * @returns The JSON-RPC ID validator function.\n */\nexport function getJsonRpcIdValidator(options) {\n    const { permitEmptyString, permitFractions, permitNull } = {\n        permitEmptyString: true,\n        permitFractions: false,\n        permitNull: true,\n        ...options,\n    };\n    /**\n     * Type guard for {@link JsonRpcId}.\n     *\n     * @param id - The JSON-RPC ID value to check.\n     * @returns Whether the given ID is valid per the options given to the\n     * factory.\n     */\n    const isValidJsonRpcId = (id) => {\n        return Boolean((typeof id === 'number' && (permitFractions || Number.isInteger(id))) ||\n            (typeof id === 'string' && (permitEmptyString || id.length > 0)) ||\n            (permitNull && id === null));\n    };\n    return isValidJsonRpcId;\n}\n//# sourceMappingURL=json.mjs.map","import { Struct } from \"../struct.mjs\";\nimport { toFailures } from \"../utils.mjs\";\n/**\n * Ensure that a string, array, map, or set is empty.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that will only accept empty values.\n */\nexport function empty(struct) {\n    return refine(struct, 'empty', (value) => {\n        // eslint-disable-next-line @typescript-eslint/no-shadow\n        const size = getSize(value);\n        return (size === 0 ||\n            `Expected an empty ${struct.type} but received one with a size of \\`${size}\\``);\n    });\n}\n/**\n * Get the size of a string, array, map, or set.\n *\n * @param value - The value to measure.\n * @returns The size of the value.\n */\nfunction getSize(value) {\n    if (value instanceof Map || value instanceof Set) {\n        return value.size;\n    }\n    return value.length;\n}\n/**\n * Ensure that a number or date is below a threshold.\n *\n * @param struct - The struct to augment.\n * @param threshold - The maximum value that the input can be.\n * @param options - An optional options object.\n * @param options.exclusive - When `true`, the input must be strictly less than\n * the threshold. When `false`, the input must be less than or equal to the\n * threshold.\n * @returns A new struct that will only accept values below the threshold.\n */\nexport function max(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, 'max', (value) => {\n        return exclusive\n            ? value < threshold\n            : value <= threshold ||\n                `Expected a ${struct.type} less than ${exclusive ? '' : 'or equal to '\n                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n                }${threshold} but received \\`${value}\\``;\n    });\n}\n/**\n * Ensure that a number or date is above a threshold.\n *\n * @param struct - The struct to augment.\n * @param threshold - The minimum value that the input can be.\n * @param options - An optional options object.\n * @param options.exclusive - When `true`, the input must be strictly greater\n * than the threshold. When `false`, the input must be greater than or equal to\n * the threshold.\n * @returns A new struct that will only accept values above the threshold.\n */\nexport function min(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, 'min', (value) => {\n        return exclusive\n            ? value > threshold\n            : value >= threshold ||\n                `Expected a ${struct.type} greater than ${exclusive ? '' : 'or equal to '\n                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n                }${threshold} but received \\`${value}\\``;\n    });\n}\n/**\n * Ensure that a string, array, map or set is not empty.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that will only accept non-empty values.\n */\nexport function nonempty(struct) {\n    return refine(struct, 'nonempty', (value) => {\n        // eslint-disable-next-line @typescript-eslint/no-shadow\n        const size = getSize(value);\n        return (size > 0 || `Expected a nonempty ${struct.type} but received an empty one`);\n    });\n}\n/**\n * Ensure that a string matches a regular expression.\n *\n * @param struct - The struct to augment.\n * @param regexp - The regular expression to match against.\n * @returns A new struct that will only accept strings matching the regular\n * expression.\n */\nexport function pattern(struct, regexp) {\n    return refine(struct, 'pattern', (value) => {\n        return (regexp.test(value) ||\n            `Expected a ${struct.type} matching \\`/${regexp.source}/\\` but received \"${value}\"`);\n    });\n}\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length,\n * or time) between `min` and `max`.\n *\n * @param struct - The struct to augment.\n * @param minimum - The minimum size that the input can be.\n * @param maximum - The maximum size that the input can be.\n * @returns A new struct that will only accept values within the given size\n * range.\n */\nexport function size(struct, minimum, maximum = minimum) {\n    const expected = `Expected a ${struct.type}`;\n    const of = minimum === maximum\n        ? `of \\`${minimum}\\``\n        : `between \\`${minimum}\\` and \\`${maximum}\\``;\n    return refine(struct, 'size', (value) => {\n        if (typeof value === 'number' || value instanceof Date) {\n            return ((minimum <= value && value <= maximum) ||\n                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n                `${expected} ${of} but received \\`${value}\\``);\n        }\n        else if (value instanceof Map || value instanceof Set) {\n            // eslint-disable-next-line @typescript-eslint/no-shadow\n            const { size } = value;\n            return ((minimum <= size && size <= maximum) ||\n                `${expected} with a size ${of} but received one with a size of \\`${size}\\``);\n        }\n        const { length } = value;\n        return ((minimum <= length && length <= maximum) ||\n            `${expected} with a length ${of} but received one with a length of \\`${length}\\``);\n    });\n}\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n *\n * @param struct - The struct to augment.\n * @param name - The name of the refinement.\n * @param refiner - The refiner function.\n * @returns A new struct that will run the refiner function after the existing\n * validation.\n */\nexport function refine(struct, name, refiner) {\n    return new Struct({\n        ...struct,\n        *refiner(value, ctx) {\n            yield* struct.refiner(value, ctx);\n            const result = refiner(value, ctx);\n            const failures = toFailures(result, ctx, struct, value);\n            for (const failure of failures) {\n                yield { ...failure, refinement: name };\n            }\n        },\n    });\n}\n//# sourceMappingURL=refinements.mjs.map","// src/error-constants.ts\nvar errorCodes = {\n  rpc: {\n    invalidInput: -32e3,\n    resourceNotFound: -32001,\n    resourceUnavailable: -32002,\n    transactionRejected: -32003,\n    methodNotSupported: -32004,\n    limitExceeded: -32005,\n    parse: -32700,\n    invalidRequest: -32600,\n    methodNotFound: -32601,\n    invalidParams: -32602,\n    internal: -32603\n  },\n  provider: {\n    userRejectedRequest: 4001,\n    unauthorized: 4100,\n    unsupportedMethod: 4200,\n    disconnected: 4900,\n    chainDisconnected: 4901\n  }\n};\nvar errorValues = {\n  \"-32700\": {\n    standard: \"JSON RPC 2.0\",\n    message: \"Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.\"\n  },\n  \"-32600\": {\n    standard: \"JSON RPC 2.0\",\n    message: \"The JSON sent is not a valid Request object.\"\n  },\n  \"-32601\": {\n    standard: \"JSON RPC 2.0\",\n    message: \"The method does not exist / is not available.\"\n  },\n  \"-32602\": {\n    standard: \"JSON RPC 2.0\",\n    message: \"Invalid method parameter(s).\"\n  },\n  \"-32603\": {\n    standard: \"JSON RPC 2.0\",\n    message: \"Internal JSON-RPC error.\"\n  },\n  \"-32000\": {\n    standard: \"EIP-1474\",\n    message: \"Invalid input.\"\n  },\n  \"-32001\": {\n    standard: \"EIP-1474\",\n    message: \"Resource not found.\"\n  },\n  \"-32002\": {\n    standard: \"EIP-1474\",\n    message: \"Resource unavailable.\"\n  },\n  \"-32003\": {\n    standard: \"EIP-1474\",\n    message: \"Transaction rejected.\"\n  },\n  \"-32004\": {\n    standard: \"EIP-1474\",\n    message: \"Method not supported.\"\n  },\n  \"-32005\": {\n    standard: \"EIP-1474\",\n    message: \"Request limit exceeded.\"\n  },\n  \"4001\": {\n    standard: \"EIP-1193\",\n    message: \"User rejected the request.\"\n  },\n  \"4100\": {\n    standard: \"EIP-1193\",\n    message: \"The requested account and/or method has not been authorized by the user.\"\n  },\n  \"4200\": {\n    standard: \"EIP-1193\",\n    message: \"The requested method is not supported by this Ethereum provider.\"\n  },\n  \"4900\": {\n    standard: \"EIP-1193\",\n    message: \"The provider is disconnected from all chains.\"\n  },\n  \"4901\": {\n    standard: \"EIP-1193\",\n    message: \"The provider is disconnected from the specified chain.\"\n  }\n};\n\nexport {\n  errorCodes,\n  errorValues\n};\n//# sourceMappingURL=chunk-MIW4NMY6.mjs.map","import {\n  errorCodes,\n  errorValues\n} from \"./chunk-MIW4NMY6.mjs\";\n\n// src/utils.ts\nimport {\n  hasProperty,\n  isValidJson,\n  isObject,\n  isJsonRpcError\n} from \"@metamask/utils\";\nvar FALLBACK_ERROR_CODE = errorCodes.rpc.internal;\nvar FALLBACK_MESSAGE = \"Unspecified error message. This is a bug, please report it.\";\nvar FALLBACK_ERROR = {\n  code: FALLBACK_ERROR_CODE,\n  message: getMessageFromCode(FALLBACK_ERROR_CODE)\n};\nvar JSON_RPC_SERVER_ERROR_MESSAGE = \"Unspecified server error.\";\nfunction getMessageFromCode(code, fallbackMessage = FALLBACK_MESSAGE) {\n  if (isValidCode(code)) {\n    const codeString = code.toString();\n    if (hasProperty(errorValues, codeString)) {\n      return errorValues[codeString].message;\n    }\n    if (isJsonRpcServerError(code)) {\n      return JSON_RPC_SERVER_ERROR_MESSAGE;\n    }\n  }\n  return fallbackMessage;\n}\nfunction isValidCode(code) {\n  return Number.isInteger(code);\n}\nfunction serializeError(error, { fallbackError = FALLBACK_ERROR, shouldIncludeStack = true } = {}) {\n  if (!isJsonRpcError(fallbackError)) {\n    throw new Error(\n      \"Must provide fallback error with integer number code and string message.\"\n    );\n  }\n  const serialized = buildError(error, fallbackError);\n  if (!shouldIncludeStack) {\n    delete serialized.stack;\n  }\n  return serialized;\n}\nfunction buildError(error, fallbackError) {\n  if (error && typeof error === \"object\" && \"serialize\" in error && typeof error.serialize === \"function\") {\n    return error.serialize();\n  }\n  if (isJsonRpcError(error)) {\n    return error;\n  }\n  const cause = serializeCause(error);\n  const fallbackWithCause = {\n    ...fallbackError,\n    data: { cause }\n  };\n  return fallbackWithCause;\n}\nfunction isJsonRpcServerError(code) {\n  return code >= -32099 && code <= -32e3;\n}\nfunction serializeCause(error) {\n  if (Array.isArray(error)) {\n    return error.map((entry) => {\n      if (isValidJson(entry)) {\n        return entry;\n      } else if (isObject(entry)) {\n        return serializeObject(entry);\n      }\n      return null;\n    });\n  } else if (isObject(error)) {\n    return serializeObject(error);\n  }\n  if (isValidJson(error)) {\n    return error;\n  }\n  return null;\n}\nfunction serializeObject(object) {\n  return Object.getOwnPropertyNames(object).reduce(\n    (acc, key) => {\n      const value = object[key];\n      if (isValidJson(value)) {\n        acc[key] = value;\n      }\n      return acc;\n    },\n    {}\n  );\n}\n\nexport {\n  JSON_RPC_SERVER_ERROR_MESSAGE,\n  getMessageFromCode,\n  isValidCode,\n  serializeError,\n  serializeCause\n};\n//# sourceMappingURL=chunk-MPU3CVX3.mjs.map","import {\n  serializeCause\n} from \"./chunk-MPU3CVX3.mjs\";\n\n// src/classes.ts\nimport { isPlainObject } from \"@metamask/utils\";\nimport safeStringify from \"fast-safe-stringify\";\nvar JsonRpcError = class extends Error {\n  constructor(code, message, data) {\n    if (!Number.isInteger(code)) {\n      throw new Error('\"code\" must be an integer.');\n    }\n    if (!message || typeof message !== \"string\") {\n      throw new Error('\"message\" must be a non-empty string.');\n    }\n    super(message);\n    this.code = code;\n    if (data !== void 0) {\n      this.data = data;\n    }\n  }\n  /**\n   * Get the error as JSON-serializable object.\n   *\n   * @returns A plain object with all public class properties.\n   */\n  serialize() {\n    const serialized = {\n      code: this.code,\n      message: this.message\n    };\n    if (this.data !== void 0) {\n      serialized.data = this.data;\n      if (isPlainObject(this.data)) {\n        serialized.data.cause = serializeCause(this.data.cause);\n      }\n    }\n    if (this.stack) {\n      serialized.stack = this.stack;\n    }\n    return serialized;\n  }\n  /**\n   * Get a string representation of the serialized error, omitting any circular\n   * references.\n   *\n   * @returns A string representation of the serialized error.\n   */\n  toString() {\n    return safeStringify(this.serialize(), stringifyReplacer, 2);\n  }\n};\nvar EthereumProviderError = class extends JsonRpcError {\n  /**\n   * Create an Ethereum Provider JSON-RPC error.\n   *\n   * @param code - The JSON-RPC error code. Must be an integer in the\n   * `1000 <= n <= 4999` range.\n   * @param message - The JSON-RPC error message.\n   * @param data - Optional data to include in the error.\n   */\n  constructor(code, message, data) {\n    if (!isValidEthProviderCode(code)) {\n      throw new Error(\n        '\"code\" must be an integer such that: 1000 <= code <= 4999'\n      );\n    }\n    super(code, message, data);\n  }\n};\nfunction isValidEthProviderCode(code) {\n  return Number.isInteger(code) && code >= 1e3 && code <= 4999;\n}\nfunction stringifyReplacer(_, value) {\n  if (value === \"[Circular]\") {\n    return void 0;\n  }\n  return value;\n}\n\nexport {\n  JsonRpcError,\n  EthereumProviderError\n};\n//# sourceMappingURL=chunk-XSKO3GXZ.mjs.map","import {\n  EthereumProviderError,\n  JsonRpcError\n} from \"./chunk-XSKO3GXZ.mjs\";\nimport {\n  getMessageFromCode\n} from \"./chunk-MPU3CVX3.mjs\";\nimport {\n  errorCodes\n} from \"./chunk-MIW4NMY6.mjs\";\n\n// src/errors.ts\nvar rpcErrors = {\n  /**\n   * Get a JSON RPC 2.0 Parse (-32700) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  parse: (arg) => getJsonRpcError(errorCodes.rpc.parse, arg),\n  /**\n   * Get a JSON RPC 2.0 Invalid Request (-32600) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  invalidRequest: (arg) => getJsonRpcError(errorCodes.rpc.invalidRequest, arg),\n  /**\n   * Get a JSON RPC 2.0 Invalid Params (-32602) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  invalidParams: (arg) => getJsonRpcError(errorCodes.rpc.invalidParams, arg),\n  /**\n   * Get a JSON RPC 2.0 Method Not Found (-32601) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  methodNotFound: (arg) => getJsonRpcError(errorCodes.rpc.methodNotFound, arg),\n  /**\n   * Get a JSON RPC 2.0 Internal (-32603) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  internal: (arg) => getJsonRpcError(errorCodes.rpc.internal, arg),\n  /**\n   * Get a JSON RPC 2.0 Server error.\n   * Permits integer error codes in the [ -32099 <= -32005 ] range.\n   * Codes -32000 through -32004 are reserved by EIP-1474.\n   *\n   * @param opts - The error options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  server: (opts) => {\n    if (!opts || typeof opts !== \"object\" || Array.isArray(opts)) {\n      throw new Error(\n        \"Ethereum RPC Server errors must provide single object argument.\"\n      );\n    }\n    const { code } = opts;\n    if (!Number.isInteger(code) || code > -32005 || code < -32099) {\n      throw new Error(\n        '\"code\" must be an integer such that: -32099 <= code <= -32005'\n      );\n    }\n    return getJsonRpcError(code, opts);\n  },\n  /**\n   * Get an Ethereum JSON RPC Invalid Input (-32000) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  invalidInput: (arg) => getJsonRpcError(errorCodes.rpc.invalidInput, arg),\n  /**\n   * Get an Ethereum JSON RPC Resource Not Found (-32001) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  resourceNotFound: (arg) => getJsonRpcError(errorCodes.rpc.resourceNotFound, arg),\n  /**\n   * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  resourceUnavailable: (arg) => getJsonRpcError(errorCodes.rpc.resourceUnavailable, arg),\n  /**\n   * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  transactionRejected: (arg) => getJsonRpcError(errorCodes.rpc.transactionRejected, arg),\n  /**\n   * Get an Ethereum JSON RPC Method Not Supported (-32004) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  methodNotSupported: (arg) => getJsonRpcError(errorCodes.rpc.methodNotSupported, arg),\n  /**\n   * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  limitExceeded: (arg) => getJsonRpcError(errorCodes.rpc.limitExceeded, arg)\n};\nvar providerErrors = {\n  /**\n   * Get an Ethereum Provider User Rejected Request (4001) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link EthereumProviderError} class.\n   */\n  userRejectedRequest: (arg) => {\n    return getEthProviderError(errorCodes.provider.userRejectedRequest, arg);\n  },\n  /**\n   * Get an Ethereum Provider Unauthorized (4100) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link EthereumProviderError} class.\n   */\n  unauthorized: (arg) => {\n    return getEthProviderError(errorCodes.provider.unauthorized, arg);\n  },\n  /**\n   * Get an Ethereum Provider Unsupported Method (4200) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link EthereumProviderError} class.\n   */\n  unsupportedMethod: (arg) => {\n    return getEthProviderError(errorCodes.provider.unsupportedMethod, arg);\n  },\n  /**\n   * Get an Ethereum Provider Not Connected (4900) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link EthereumProviderError} class.\n   */\n  disconnected: (arg) => {\n    return getEthProviderError(errorCodes.provider.disconnected, arg);\n  },\n  /**\n   * Get an Ethereum Provider Chain Not Connected (4901) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link EthereumProviderError} class.\n   */\n  chainDisconnected: (arg) => {\n    return getEthProviderError(errorCodes.provider.chainDisconnected, arg);\n  },\n  /**\n   * Get a custom Ethereum Provider error.\n   *\n   * @param opts - The error options bag.\n   * @returns An instance of the {@link EthereumProviderError} class.\n   */\n  custom: (opts) => {\n    if (!opts || typeof opts !== \"object\" || Array.isArray(opts)) {\n      throw new Error(\n        \"Ethereum Provider custom errors must provide single object argument.\"\n      );\n    }\n    const { code, message, data } = opts;\n    if (!message || typeof message !== \"string\") {\n      throw new Error('\"message\" must be a nonempty string');\n    }\n    return new EthereumProviderError(code, message, data);\n  }\n};\nfunction getJsonRpcError(code, arg) {\n  const [message, data] = parseOpts(arg);\n  return new JsonRpcError(code, message ?? getMessageFromCode(code), data);\n}\nfunction getEthProviderError(code, arg) {\n  const [message, data] = parseOpts(arg);\n  return new EthereumProviderError(\n    code,\n    message ?? getMessageFromCode(code),\n    data\n  );\n}\nfunction parseOpts(arg) {\n  if (arg) {\n    if (typeof arg === \"string\") {\n      return [arg];\n    } else if (typeof arg === \"object\" && !Array.isArray(arg)) {\n      const { message, data } = arg;\n      if (message && typeof message !== \"string\") {\n        throw new Error(\"Must specify string message.\");\n      }\n      return [message ?? void 0, data];\n    }\n  }\n  return [];\n}\n\nexport {\n  rpcErrors,\n  providerErrors\n};\n//# sourceMappingURL=chunk-KYP27U3C.mjs.map","import { is, pattern, string } from \"@metamask/superstruct\";\nimport { keccak_256 as keccak256 } from \"@noble/hashes/sha3\";\nimport { assert } from \"./assert.mjs\";\nimport { bytesToHex } from \"./bytes.mjs\";\nexport const HexStruct = pattern(string(), /^(?:0x)?[0-9a-f]+$/iu);\nexport const StrictHexStruct = pattern(string(), /^0x[0-9a-f]+$/iu);\nexport const HexAddressStruct = pattern(string(), /^0x[0-9a-f]{40}$/u);\nexport const HexChecksumAddressStruct = pattern(string(), /^0x[0-9a-fA-F]{40}$/u);\n/**\n * Check if a string is a valid hex string.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid hex string.\n */\nexport function isHexString(value) {\n    return is(value, HexStruct);\n}\n/**\n * Strictly check if a string is a valid hex string. A valid hex string must\n * start with the \"0x\"-prefix.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid hex string.\n */\nexport function isStrictHexString(value) {\n    return is(value, StrictHexStruct);\n}\n/**\n * Assert that a value is a valid hex string.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid hex string.\n */\nexport function assertIsHexString(value) {\n    assert(isHexString(value), 'Value must be a hexadecimal string.');\n}\n/**\n * Assert that a value is a valid hex string. A valid hex string must start with\n * the \"0x\"-prefix.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid hex string.\n */\nexport function assertIsStrictHexString(value) {\n    assert(isStrictHexString(value), 'Value must be a hexadecimal string, starting with \"0x\".');\n}\n/**\n * Validate that the passed prefixed hex string is an all-lowercase\n * hex address, or a valid mixed-case checksum address.\n *\n * @param possibleAddress - Input parameter to check against.\n * @returns Whether or not the input is a valid hex address.\n */\nexport function isValidHexAddress(possibleAddress) {\n    return (is(possibleAddress, HexAddressStruct) ||\n        isValidChecksumAddress(possibleAddress));\n}\n/**\n * Encode a passed hex string as an ERC-55 mixed-case checksum address.\n *\n * @param address - The hex address to encode.\n * @returns The address encoded according to ERC-55.\n * @see https://eips.ethereum.org/EIPS/eip-55\n */\nexport function getChecksumAddress(address) {\n    assert(is(address, HexChecksumAddressStruct), 'Invalid hex address.');\n    const unPrefixed = remove0x(address.toLowerCase());\n    const unPrefixedHash = remove0x(bytesToHex(keccak256(unPrefixed)));\n    return `0x${unPrefixed\n        .split('')\n        .map((character, nibbleIndex) => {\n        const hashCharacter = unPrefixedHash[nibbleIndex];\n        assert(is(hashCharacter, string()), 'Hash shorter than address.');\n        return parseInt(hashCharacter, 16) > 7\n            ? character.toUpperCase()\n            : character;\n    })\n        .join('')}`;\n}\n/**\n * Validate that the passed hex string is a valid ERC-55 mixed-case\n * checksum address.\n *\n * @param possibleChecksum - The hex address to check.\n * @returns True if the address is a checksum address.\n */\nexport function isValidChecksumAddress(possibleChecksum) {\n    if (!is(possibleChecksum, HexChecksumAddressStruct)) {\n        return false;\n    }\n    return getChecksumAddress(possibleChecksum) === possibleChecksum;\n}\n/**\n * Add the `0x`-prefix to a hexadecimal string. If the string already has the\n * prefix, it is returned as-is.\n *\n * @param hexadecimal - The hexadecimal string to add the prefix to.\n * @returns The prefixed hexadecimal string.\n */\nexport function add0x(hexadecimal) {\n    if (hexadecimal.startsWith('0x')) {\n        return hexadecimal;\n    }\n    if (hexadecimal.startsWith('0X')) {\n        return `0x${hexadecimal.substring(2)}`;\n    }\n    return `0x${hexadecimal}`;\n}\n/**\n * Remove the `0x`-prefix from a hexadecimal string. If the string doesn't have\n * the prefix, it is returned as-is.\n *\n * @param hexadecimal - The hexadecimal string to remove the prefix from.\n * @returns The un-prefixed hexadecimal string.\n */\nexport function remove0x(hexadecimal) {\n    if (hexadecimal.startsWith('0x') || hexadecimal.startsWith('0X')) {\n        return hexadecimal.substring(2);\n    }\n    return hexadecimal;\n}\n//# sourceMappingURL=hex.mjs.map","var __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\n\n// src/errors.ts\nvar _code, _message, _data, _stack;\nvar SnapError = class extends Error {\n  /**\n   * Create a new `SnapError`.\n   *\n   * @param error - The error to create the `SnapError` from. If this is a\n   * `string`, it will be used as the error message. If this is an `Error`, its\n   * `message` property will be used as the error message. If this is a\n   * `JsonRpcError`, its `message` property will be used as the error message\n   * and its `code` property will be used as the error code. Otherwise, the\n   * error will be converted to a string and used as the error message.\n   * @param data - Additional data to include in the error. This will be merged\n   * with the error data, if any.\n   */\n  constructor(error, data = {}) {\n    const message = getErrorMessage(error);\n    super(message);\n    __privateAdd(this, _code, void 0);\n    __privateAdd(this, _message, void 0);\n    __privateAdd(this, _data, void 0);\n    __privateAdd(this, _stack, void 0);\n    __privateSet(this, _message, message);\n    __privateSet(this, _code, getErrorCode(error));\n    const mergedData = { ...getErrorData(error), ...data };\n    if (Object.keys(mergedData).length > 0) {\n      __privateSet(this, _data, mergedData);\n    }\n    __privateSet(this, _stack, super.stack);\n  }\n  /**\n   * The error name.\n   *\n   * @returns The error name.\n   */\n  get name() {\n    return \"SnapError\";\n  }\n  /**\n   * The error code.\n   *\n   * @returns The error code.\n   */\n  get code() {\n    return __privateGet(this, _code);\n  }\n  /**\n   * The error message.\n   *\n   * @returns The error message.\n   */\n  // This line is covered, but Jest doesn't pick it up for some reason.\n  /* istanbul ignore next */\n  get message() {\n    return __privateGet(this, _message);\n  }\n  /**\n   * Additional data for the error.\n   *\n   * @returns Additional data for the error.\n   */\n  get data() {\n    return __privateGet(this, _data);\n  }\n  /**\n   * The error stack.\n   *\n   * @returns The error stack.\n   */\n  // This line is covered, but Jest doesn't pick it up for some reason.\n  /* istanbul ignore next */\n  get stack() {\n    return __privateGet(this, _stack);\n  }\n  /**\n   * Convert the error to a JSON object.\n   *\n   * @returns The JSON object.\n   */\n  toJSON() {\n    return {\n      code: SNAP_ERROR_CODE,\n      message: SNAP_ERROR_MESSAGE,\n      data: {\n        cause: {\n          code: this.code,\n          message: this.message,\n          stack: this.stack,\n          ...this.data ? { data: this.data } : {}\n        }\n      }\n    };\n  }\n  /**\n   * Serialize the error to a JSON object. This is called by\n   * `@metamask/rpc-errors` when serializing the error.\n   *\n   * @returns The JSON object.\n   */\n  serialize() {\n    return this.toJSON();\n  }\n};\n_code = new WeakMap();\n_message = new WeakMap();\n_data = new WeakMap();\n_stack = new WeakMap();\n\n// src/internals/error-wrappers.ts\nfunction createSnapError(fn) {\n  return class SnapJsonRpcError extends SnapError {\n    /**\n     * Create a new `SnapJsonRpcError` from a message and data.\n     *\n     * @param message - The message to create the error from.\n     * @param data - The data to create the error from.\n     */\n    constructor(message, data) {\n      if (typeof message === \"object\") {\n        const error2 = fn();\n        super({\n          code: error2.code,\n          message: error2.message,\n          data: message\n        });\n        return;\n      }\n      const error = fn(message);\n      super({\n        code: error.code,\n        message: error.message,\n        data\n      });\n    }\n  };\n}\n\n// src/internals/errors.ts\nimport { hasProperty, isObject, isValidJson } from \"@metamask/utils\";\nvar SNAP_ERROR_CODE = -31002;\nvar SNAP_ERROR_MESSAGE = \"Snap Error\";\nfunction getErrorMessage(error) {\n  if (isObject(error) && hasProperty(error, \"message\") && typeof error.message === \"string\") {\n    return error.message;\n  }\n  return String(error);\n}\nfunction getErrorStack(error) {\n  if (isObject(error) && hasProperty(error, \"stack\") && typeof error.stack === \"string\") {\n    return error.stack;\n  }\n  return void 0;\n}\nfunction getErrorCode(error) {\n  if (isObject(error) && hasProperty(error, \"code\") && typeof error.code === \"number\" && Number.isInteger(error.code)) {\n    return error.code;\n  }\n  return -32603;\n}\nfunction getErrorData(error) {\n  if (isObject(error) && hasProperty(error, \"data\") && typeof error.data === \"object\" && error.data !== null && isValidJson(error.data) && !Array.isArray(error.data)) {\n    return error.data;\n  }\n  return {};\n}\n\n// src/internals/structs.ts\nimport {\n  Struct,\n  define,\n  literal as superstructLiteral,\n  union as superstructUnion\n} from \"@metamask/superstruct\";\nfunction literal(value) {\n  return define(\n    JSON.stringify(value),\n    superstructLiteral(value).validator\n  );\n}\nfunction union([\n  head,\n  ...tail\n]) {\n  const struct = superstructUnion([head, ...tail]);\n  return new Struct({\n    ...struct,\n    schema: [head, ...tail]\n  });\n}\nfunction enumValue(constant) {\n  return literal(constant);\n}\n\n// src/internals/jsx.ts\nfunction nullUnion(structs) {\n  return union(structs);\n}\n\n// src/internals/svg.ts\nimport { refine, string } from \"@metamask/superstruct\";\nfunction svg() {\n  return refine(string(), \"SVG\", (value) => {\n    if (!value.includes(\"<svg\")) {\n      return \"Value is not a valid SVG.\";\n    }\n    return true;\n  });\n}\n\n// src/index.ts\nimport { assert as assert2 } from \"@metamask/utils\";\n\n// src/error-wrappers.ts\nimport { providerErrors, rpcErrors } from \"@metamask/rpc-errors\";\nvar InternalError = createSnapError(rpcErrors.internal);\nvar InvalidInputError = createSnapError(rpcErrors.invalidInput);\nvar InvalidParamsError = createSnapError(rpcErrors.invalidParams);\nvar InvalidRequestError = createSnapError(rpcErrors.invalidRequest);\nvar LimitExceededError = createSnapError(rpcErrors.limitExceeded);\nvar MethodNotFoundError = createSnapError(rpcErrors.methodNotFound);\nvar MethodNotSupportedError = createSnapError(\n  rpcErrors.methodNotSupported\n);\nvar ParseError = createSnapError(rpcErrors.parse);\nvar ResourceNotFoundError = createSnapError(\n  rpcErrors.resourceNotFound\n);\nvar ResourceUnavailableError = createSnapError(\n  rpcErrors.resourceUnavailable\n);\nvar TransactionRejected = createSnapError(\n  rpcErrors.transactionRejected\n);\nvar ChainDisconnectedError = createSnapError(\n  providerErrors.chainDisconnected\n);\nvar DisconnectedError = createSnapError(providerErrors.disconnected);\nvar UnauthorizedError = createSnapError(providerErrors.unauthorized);\nvar UnsupportedMethodError = createSnapError(\n  providerErrors.unsupportedMethod\n);\nvar UserRejectedRequestError = createSnapError(\n  providerErrors.userRejectedRequest\n);\n\n// src/images.ts\nimport { assert, bytesToBase64 } from \"@metamask/utils\";\n\n// src/ui/components/address.ts\nimport { assign as assign2, literal as literal2, object as object2 } from \"@metamask/superstruct\";\nimport { HexChecksumAddressStruct } from \"@metamask/utils\";\n\n// src/ui/builder.ts\nimport { assertStruct, isPlainObject } from \"@metamask/utils\";\nfunction createBuilder(type, struct, keys = []) {\n  return (...args) => {\n    if (args.length === 1 && isPlainObject(args[0])) {\n      const node2 = { ...args[0], type };\n      assertStruct(node2, struct, `Invalid ${type} component`);\n      return node2;\n    }\n    const node = keys.reduce(\n      (partialNode, key, index) => {\n        if (args[index] !== void 0) {\n          return {\n            ...partialNode,\n            [key]: args[index]\n          };\n        }\n        return partialNode;\n      },\n      { type }\n    );\n    assertStruct(node, struct, `Invalid ${type} component`);\n    return node;\n  };\n}\n\n// src/ui/nodes.ts\nimport { assign, object, string as string2, unknown } from \"@metamask/superstruct\";\nvar NodeType = /* @__PURE__ */ ((NodeType2) => {\n  NodeType2[\"Copyable\"] = \"copyable\";\n  NodeType2[\"Divider\"] = \"divider\";\n  NodeType2[\"Heading\"] = \"heading\";\n  NodeType2[\"Panel\"] = \"panel\";\n  NodeType2[\"Spinner\"] = \"spinner\";\n  NodeType2[\"Text\"] = \"text\";\n  NodeType2[\"Image\"] = \"image\";\n  NodeType2[\"Row\"] = \"row\";\n  NodeType2[\"Address\"] = \"address\";\n  NodeType2[\"Button\"] = \"button\";\n  NodeType2[\"Input\"] = \"input\";\n  NodeType2[\"Form\"] = \"form\";\n  return NodeType2;\n})(NodeType || {});\nvar NodeStruct = object({\n  type: string2()\n});\nvar LiteralStruct = assign(\n  NodeStruct,\n  object({\n    value: unknown()\n  })\n);\n\n// src/ui/components/address.ts\nvar AddressStruct = assign2(\n  LiteralStruct,\n  object2({\n    type: literal2(\"address\" /* Address */),\n    value: HexChecksumAddressStruct\n  })\n);\nvar address = createBuilder(\"address\" /* Address */, AddressStruct, [\n  \"value\"\n]);\n\n// src/ui/components/copyable.ts\nimport {\n  assign as assign3,\n  boolean,\n  literal as literal3,\n  object as object3,\n  optional,\n  string as string3\n} from \"@metamask/superstruct\";\nvar CopyableStruct = assign3(\n  LiteralStruct,\n  object3({\n    type: literal3(\"copyable\" /* Copyable */),\n    value: string3(),\n    sensitive: optional(boolean())\n  })\n);\nvar copyable = createBuilder(\"copyable\" /* Copyable */, CopyableStruct, [\n  \"value\",\n  \"sensitive\"\n]);\n\n// src/ui/components/divider.ts\nimport { assign as assign4, literal as literal4, object as object4 } from \"@metamask/superstruct\";\nvar DividerStruct = assign4(\n  NodeStruct,\n  object4({\n    type: literal4(\"divider\" /* Divider */)\n  })\n);\nvar divider = createBuilder(\"divider\" /* Divider */, DividerStruct);\n\n// src/ui/components/heading.ts\nimport { assign as assign5, literal as literal5, object as object5, string as string4 } from \"@metamask/superstruct\";\nvar HeadingStruct = assign5(\n  LiteralStruct,\n  object5({\n    type: literal5(\"heading\" /* Heading */),\n    value: string4()\n  })\n);\nvar heading = createBuilder(\"heading\" /* Heading */, HeadingStruct, [\n  \"value\"\n]);\n\n// src/ui/components/image.ts\nimport { assign as assign6, literal as literal6, object as object6 } from \"@metamask/superstruct\";\nvar ImageStruct = assign6(\n  NodeStruct,\n  object6({\n    type: literal6(\"image\" /* Image */),\n    value: svg()\n  })\n);\nvar image = createBuilder(\"image\" /* Image */, ImageStruct, [\"value\"]);\n\n// src/ui/components/panel.ts\nimport {\n  array as array2,\n  assign as assign13,\n  lazy,\n  literal as literal13,\n  object as object13,\n  union as union6\n} from \"@metamask/superstruct\";\n\n// src/ui/components/button.ts\nimport {\n  assign as assign7,\n  literal as literal7,\n  object as object7,\n  optional as optional2,\n  string as string5,\n  union as union2\n} from \"@metamask/superstruct\";\nvar ButtonVariant = /* @__PURE__ */ ((ButtonVariant2) => {\n  ButtonVariant2[\"Primary\"] = \"primary\";\n  ButtonVariant2[\"Secondary\"] = \"secondary\";\n  return ButtonVariant2;\n})(ButtonVariant || {});\nvar ButtonType = /* @__PURE__ */ ((ButtonType2) => {\n  ButtonType2[\"Button\"] = \"button\";\n  ButtonType2[\"Submit\"] = \"submit\";\n  return ButtonType2;\n})(ButtonType || {});\nvar ButtonStruct = assign7(\n  LiteralStruct,\n  object7({\n    type: literal7(\"button\" /* Button */),\n    value: string5(),\n    variant: optional2(\n      union2([\n        enumValue(\"primary\" /* Primary */),\n        enumValue(\"secondary\" /* Secondary */)\n      ])\n    ),\n    buttonType: optional2(\n      union2([enumValue(\"button\" /* Button */), enumValue(\"submit\" /* Submit */)])\n    ),\n    name: optional2(string5())\n  })\n);\nvar button = createBuilder(\"button\" /* Button */, ButtonStruct, [\n  \"value\",\n  \"buttonType\",\n  \"name\",\n  \"variant\"\n]);\n\n// src/ui/components/form.ts\nimport {\n  array,\n  assign as assign9,\n  literal as literal9,\n  object as object9,\n  string as string7,\n  union as union4\n} from \"@metamask/superstruct\";\n\n// src/ui/components/input.ts\nimport {\n  assign as assign8,\n  literal as literal8,\n  object as object8,\n  optional as optional3,\n  string as string6,\n  union as union3\n} from \"@metamask/superstruct\";\nvar InputType = /* @__PURE__ */ ((InputType2) => {\n  InputType2[\"Text\"] = \"text\";\n  InputType2[\"Number\"] = \"number\";\n  InputType2[\"Password\"] = \"password\";\n  return InputType2;\n})(InputType || {});\nvar InputStruct = assign8(\n  LiteralStruct,\n  object8({\n    type: literal8(\"input\" /* Input */),\n    value: optional3(string6()),\n    name: string6(),\n    inputType: optional3(\n      union3([\n        enumValue(\"text\" /* Text */),\n        enumValue(\"password\" /* Password */),\n        enumValue(\"number\" /* Number */)\n      ])\n    ),\n    placeholder: optional3(string6()),\n    label: optional3(string6()),\n    error: optional3(string6())\n  })\n);\nvar input = createBuilder(\"input\" /* Input */, InputStruct, [\n  \"name\",\n  \"inputType\",\n  \"placeholder\",\n  \"value\",\n  \"label\"\n]);\n\n// src/ui/components/form.ts\nvar FormComponentStruct = union4([InputStruct, ButtonStruct]);\nvar FormStruct = assign9(\n  NodeStruct,\n  object9({\n    type: literal9(\"form\" /* Form */),\n    children: array(FormComponentStruct),\n    name: string7()\n  })\n);\nvar form = createBuilder(\"form\" /* Form */, FormStruct, [\n  \"name\",\n  \"children\"\n]);\n\n// src/ui/components/row.ts\nimport {\n  assign as assign11,\n  literal as literal11,\n  object as object11,\n  string as string9,\n  optional as optional5,\n  union as union5\n} from \"@metamask/superstruct\";\n\n// src/ui/components/text.ts\nimport {\n  assign as assign10,\n  boolean as boolean2,\n  literal as literal10,\n  object as object10,\n  optional as optional4,\n  string as string8\n} from \"@metamask/superstruct\";\nvar TextStruct = assign10(\n  LiteralStruct,\n  object10({\n    type: literal10(\"text\" /* Text */),\n    value: string8(),\n    markdown: optional4(boolean2())\n  })\n);\nvar text = createBuilder(\"text\" /* Text */, TextStruct, [\n  \"value\",\n  \"markdown\"\n]);\n\n// src/ui/components/row.ts\nvar RowVariant = /* @__PURE__ */ ((RowVariant2) => {\n  RowVariant2[\"Default\"] = \"default\";\n  RowVariant2[\"Critical\"] = \"critical\";\n  RowVariant2[\"Warning\"] = \"warning\";\n  return RowVariant2;\n})(RowVariant || {});\nvar RowComponentStruct = union5([ImageStruct, TextStruct, AddressStruct]);\nvar RowStruct = assign11(\n  LiteralStruct,\n  object11({\n    type: literal11(\"row\" /* Row */),\n    variant: optional5(\n      union5([\n        enumValue(\"default\" /* Default */),\n        enumValue(\"critical\" /* Critical */),\n        enumValue(\"warning\" /* Warning */)\n      ])\n    ),\n    label: string9(),\n    value: RowComponentStruct\n  })\n);\nvar row = createBuilder(\"row\" /* Row */, RowStruct, [\n  \"label\",\n  \"value\",\n  \"variant\"\n]);\n\n// src/ui/components/spinner.ts\nimport { assign as assign12, literal as literal12, object as object12 } from \"@metamask/superstruct\";\nvar SpinnerStruct = assign12(\n  NodeStruct,\n  object12({\n    type: literal12(\"spinner\" /* Spinner */)\n  })\n);\nvar spinner = createBuilder(\"spinner\" /* Spinner */, SpinnerStruct);\n\n// src/ui/components/panel.ts\nvar ParentStruct = assign13(\n  NodeStruct,\n  object13({\n    // This node references itself indirectly, so we need to use `lazy()`.\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    children: array2(lazy(() => ComponentStruct))\n  })\n);\nvar PanelStruct = assign13(\n  ParentStruct,\n  object13({\n    type: literal13(\"panel\" /* Panel */)\n  })\n);\nvar panel = createBuilder(\"panel\" /* Panel */, PanelStruct, [\"children\"]);\nvar ComponentStruct = union6([\n  CopyableStruct,\n  DividerStruct,\n  HeadingStruct,\n  ImageStruct,\n  PanelStruct,\n  SpinnerStruct,\n  TextStruct,\n  RowStruct,\n  AddressStruct,\n  InputStruct,\n  FormStruct,\n  ButtonStruct\n]);\n\n// src/ui/component.ts\nimport { is } from \"@metamask/superstruct\";\nimport { assertStruct as assertStruct2 } from \"@metamask/utils\";\nfunction isComponent(value) {\n  return is(value, ComponentStruct);\n}\nfunction assertIsComponent(value) {\n  assertStruct2(value, ComponentStruct, \"Invalid component\");\n}\n\n// src/images.ts\nasync function getRawImageData(url, options) {\n  if (typeof fetch !== \"function\") {\n    throw new Error(\n      `Failed to fetch image data from \"${url}\": Using this function requires the \"endowment:network-access\" permission.`\n    );\n  }\n  return fetch(url, options).then(async (response) => {\n    if (!response.ok) {\n      throw new Error(\n        `Failed to fetch image data from \"${url}\": ${response.status} ${response.statusText}`\n      );\n    }\n    const blob = await response.blob();\n    assert(\n      blob.type === \"image/jpeg\" || blob.type === \"image/png\",\n      \"Expected image data to be a JPEG or PNG image.\"\n    );\n    return blob;\n  });\n}\nasync function getImageData(url, options) {\n  const blob = await getRawImageData(url, options);\n  const bytes = new Uint8Array(await blob.arrayBuffer());\n  return `data:${blob.type};base64,${bytesToBase64(bytes)}`;\n}\nasync function getImageComponent(url, { width, height = width, request }) {\n  assert(\n    typeof width === \"number\" && width > 0,\n    \"Expected width to be a number greater than 0.\"\n  );\n  assert(\n    typeof height === \"number\" && height > 0,\n    \"Expected height to be a number greater than 0.\"\n  );\n  const imageData = await getImageData(url, request);\n  const size = `width=\"${width}\" height=\"${height}\"`;\n  return image(\n    `<svg ${size.trim()} xmlns=\"http://www.w3.org/2000/svg\"><image ${size.trim()} href=\"${imageData}\" /></svg>`\n  );\n}\n\n// src/types/handlers/transaction.ts\nvar SeverityLevel = /* @__PURE__ */ ((SeverityLevel2) => {\n  SeverityLevel2[\"Critical\"] = \"critical\";\n  return SeverityLevel2;\n})(SeverityLevel || {});\n\n// src/types/handlers/user-input.ts\nimport {\n  number,\n  assign as assign14,\n  literal as literal14,\n  nullable,\n  object as object14,\n  optional as optional6,\n  record,\n  string as string10,\n  union as union7,\n  boolean as boolean3\n} from \"@metamask/superstruct\";\nvar UserInputEventType = /* @__PURE__ */ ((UserInputEventType2) => {\n  UserInputEventType2[\"ButtonClickEvent\"] = \"ButtonClickEvent\";\n  UserInputEventType2[\"FormSubmitEvent\"] = \"FormSubmitEvent\";\n  UserInputEventType2[\"InputChangeEvent\"] = \"InputChangeEvent\";\n  UserInputEventType2[\"FileUploadEvent\"] = \"FileUploadEvent\";\n  return UserInputEventType2;\n})(UserInputEventType || {});\nvar GenericEventStruct = object14({\n  type: string10(),\n  name: optional6(string10())\n});\nvar ButtonClickEventStruct = assign14(\n  GenericEventStruct,\n  object14({\n    type: literal14(\"ButtonClickEvent\" /* ButtonClickEvent */),\n    name: optional6(string10())\n  })\n);\nvar FileStruct = object14({\n  name: string10(),\n  size: number(),\n  contentType: string10(),\n  contents: string10()\n});\nvar FormSubmitEventStruct = assign14(\n  GenericEventStruct,\n  object14({\n    type: literal14(\"FormSubmitEvent\" /* FormSubmitEvent */),\n    value: record(string10(), nullable(union7([string10(), FileStruct, boolean3()]))),\n    name: string10()\n  })\n);\nvar InputChangeEventStruct = assign14(\n  GenericEventStruct,\n  object14({\n    type: literal14(\"InputChangeEvent\" /* InputChangeEvent */),\n    name: string10(),\n    value: union7([string10(), boolean3()])\n  })\n);\nvar FileUploadEventStruct = assign14(\n  GenericEventStruct,\n  object14({\n    type: literal14(\"FileUploadEvent\" /* FileUploadEvent */),\n    name: string10(),\n    file: nullable(FileStruct)\n  })\n);\nvar UserInputEventStruct = union7([\n  ButtonClickEventStruct,\n  FormSubmitEventStruct,\n  InputChangeEventStruct,\n  FileUploadEventStruct\n]);\n\n// src/types/methods/dialog.ts\nvar DialogType = /* @__PURE__ */ ((DialogType2) => {\n  DialogType2[\"Alert\"] = \"alert\";\n  DialogType2[\"Confirmation\"] = \"confirmation\";\n  DialogType2[\"Prompt\"] = \"prompt\";\n  return DialogType2;\n})(DialogType || {});\n\n// src/types/methods/get-file.ts\nvar AuxiliaryFileEncoding = /* @__PURE__ */ ((AuxiliaryFileEncoding2) => {\n  AuxiliaryFileEncoding2[\"Base64\"] = \"base64\";\n  AuxiliaryFileEncoding2[\"Hex\"] = \"hex\";\n  AuxiliaryFileEncoding2[\"Utf8\"] = \"utf8\";\n  return AuxiliaryFileEncoding2;\n})(AuxiliaryFileEncoding || {});\n\n// src/types/methods/manage-state.ts\nvar ManageStateOperation = /* @__PURE__ */ ((ManageStateOperation2) => {\n  ManageStateOperation2[\"ClearState\"] = \"clear\";\n  ManageStateOperation2[\"GetState\"] = \"get\";\n  ManageStateOperation2[\"UpdateState\"] = \"update\";\n  return ManageStateOperation2;\n})(ManageStateOperation || {});\n\n// src/types/methods/notify.ts\nvar NotificationType = /* @__PURE__ */ ((NotificationType2) => {\n  NotificationType2[\"InApp\"] = \"inApp\";\n  NotificationType2[\"Native\"] = \"native\";\n  return NotificationType2;\n})(NotificationType || {});\n\n// src/types/interface.ts\nimport {\n  boolean as boolean5,\n  nullable as nullable3,\n  record as record3,\n  string as string12,\n  union as union8\n} from \"@metamask/superstruct\";\nimport { JsonStruct as JsonStruct2 } from \"@metamask/utils\";\n\n// src/jsx/validation.ts\nimport {\n  is as is2,\n  boolean as boolean4,\n  optional as optional7,\n  array as array3,\n  lazy as lazy2,\n  nullable as nullable2,\n  number as number2,\n  object as object15,\n  record as record2,\n  string as string11,\n  tuple\n} from \"@metamask/superstruct\";\nimport {\n  hasProperty as hasProperty2,\n  HexChecksumAddressStruct as HexChecksumAddressStruct2,\n  isPlainObject as isPlainObject2,\n  JsonStruct\n} from \"@metamask/utils\";\nvar KeyStruct = nullUnion([string11(), number2()]);\nvar StringElementStruct = children([\n  string11()\n]);\nvar ElementStruct = object15({\n  type: string11(),\n  props: record2(string11(), JsonStruct),\n  key: nullable2(KeyStruct)\n});\nfunction nestable(struct) {\n  const nestableStruct = nullUnion([\n    struct,\n    array3(lazy2(() => nestableStruct))\n  ]);\n  return nestableStruct;\n}\nfunction children(structs) {\n  return nestable(nullable2(nullUnion([...structs, boolean4()])));\n}\nfunction element(name, props = {}) {\n  return object15({\n    type: literal(name),\n    props: object15(props),\n    key: nullable2(KeyStruct)\n  });\n}\nvar ButtonStruct2 = element(\"Button\", {\n  children: StringElementStruct,\n  name: optional7(string11()),\n  type: optional7(nullUnion([literal(\"button\"), literal(\"submit\")])),\n  variant: optional7(nullUnion([literal(\"primary\"), literal(\"destructive\")])),\n  disabled: optional7(boolean4())\n});\nvar CheckboxStruct = element(\"Checkbox\", {\n  name: string11(),\n  checked: optional7(boolean4()),\n  label: optional7(string11()),\n  variant: optional7(nullUnion([literal(\"default\"), literal(\"toggle\")]))\n});\nvar InputStruct2 = element(\"Input\", {\n  name: string11(),\n  type: optional7(\n    nullUnion([literal(\"text\"), literal(\"password\"), literal(\"number\")])\n  ),\n  value: optional7(string11()),\n  placeholder: optional7(string11())\n});\nvar OptionStruct = element(\"Option\", {\n  value: string11(),\n  children: string11()\n});\nvar DropdownStruct = element(\"Dropdown\", {\n  name: string11(),\n  value: optional7(string11()),\n  children: children([OptionStruct])\n});\nvar FileInputStruct = element(\n  \"FileInput\",\n  {\n    name: string11(),\n    accept: nullUnion([optional7(array3(string11()))]),\n    compact: optional7(boolean4())\n  }\n);\nvar BUTTON_INPUT = [InputStruct2, ButtonStruct2];\nvar FIELD_CHILDREN_ARRAY = [\n  InputStruct2,\n  DropdownStruct,\n  FileInputStruct,\n  CheckboxStruct\n];\nvar FieldChildUnionStruct = nullUnion([\n  ...FIELD_CHILDREN_ARRAY,\n  ...BUTTON_INPUT\n]);\nvar FieldChildStruct = nullUnion([\n  tuple(BUTTON_INPUT),\n  ...FIELD_CHILDREN_ARRAY\n]);\nvar FieldStruct = element(\"Field\", {\n  label: optional7(string11()),\n  error: optional7(string11()),\n  children: FieldChildStruct\n});\nvar FormChildStruct = children(\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  [FieldStruct, lazy2(() => BoxChildStruct)]\n);\nvar FormStruct2 = element(\"Form\", {\n  children: FormChildStruct,\n  name: string11()\n});\nvar BoldStruct = element(\"Bold\", {\n  children: children([\n    string11(),\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    lazy2(() => ItalicStruct)\n  ])\n});\nvar ItalicStruct = element(\"Italic\", {\n  children: children([\n    string11(),\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    lazy2(() => BoldStruct)\n  ])\n});\nvar FormattingStruct = nullUnion([\n  BoldStruct,\n  ItalicStruct\n]);\nvar AddressStruct2 = element(\"Address\", {\n  address: HexChecksumAddressStruct2\n});\nvar BoxChildrenStruct = children(\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  [lazy2(() => BoxChildStruct)]\n);\nvar BoxStruct = element(\"Box\", {\n  children: BoxChildrenStruct,\n  direction: optional7(nullUnion([literal(\"horizontal\"), literal(\"vertical\")])),\n  alignment: optional7(\n    nullUnion([\n      literal(\"start\"),\n      literal(\"center\"),\n      literal(\"end\"),\n      literal(\"space-between\"),\n      literal(\"space-around\")\n    ])\n  )\n});\nvar FooterChildStruct = nullUnion([\n  tuple([ButtonStruct2, ButtonStruct2]),\n  ButtonStruct2\n]);\nvar FooterStruct = element(\"Footer\", {\n  children: FooterChildStruct\n});\nvar ContainerChildStruct = nullUnion([\n  tuple([BoxStruct, FooterStruct]),\n  BoxStruct\n]);\nvar ContainerStruct = element(\n  \"Container\",\n  {\n    children: ContainerChildStruct\n  }\n);\nvar CopyableStruct2 = element(\"Copyable\", {\n  value: string11(),\n  sensitive: optional7(boolean4())\n});\nvar DividerStruct2 = element(\"Divider\");\nvar ValueStruct = element(\"Value\", {\n  value: string11(),\n  extra: string11()\n});\nvar HeadingStruct2 = element(\"Heading\", {\n  children: StringElementStruct\n});\nvar ImageStruct2 = element(\"Image\", {\n  src: svg(),\n  alt: optional7(string11())\n});\nvar LinkStruct = element(\"Link\", {\n  href: string11(),\n  children: children([FormattingStruct, string11()])\n});\nvar TextStruct2 = element(\"Text\", {\n  children: children([string11(), BoldStruct, ItalicStruct, LinkStruct]),\n  alignment: optional7(\n    nullUnion([literal(\"start\"), literal(\"center\"), literal(\"end\")])\n  )\n});\nvar TooltipChildStruct = nullUnion([\n  TextStruct2,\n  BoldStruct,\n  ItalicStruct,\n  LinkStruct,\n  ImageStruct2,\n  boolean4()\n]);\nvar TooltipContentStruct = nullUnion([\n  TextStruct2,\n  BoldStruct,\n  ItalicStruct,\n  LinkStruct,\n  string11()\n]);\nvar TooltipStruct = element(\"Tooltip\", {\n  children: nullable2(TooltipChildStruct),\n  content: TooltipContentStruct\n});\nvar RowStruct2 = element(\"Row\", {\n  label: string11(),\n  children: nullUnion([AddressStruct2, ImageStruct2, TextStruct2, ValueStruct]),\n  variant: optional7(\n    nullUnion([literal(\"default\"), literal(\"warning\"), literal(\"critical\")])\n  ),\n  tooltip: optional7(string11())\n});\nvar SpinnerStruct2 = element(\"Spinner\");\nvar BoxChildStruct = nullUnion([\n  AddressStruct2,\n  BoldStruct,\n  BoxStruct,\n  ButtonStruct2,\n  CopyableStruct2,\n  DividerStruct2,\n  DropdownStruct,\n  FileInputStruct,\n  FormStruct2,\n  HeadingStruct2,\n  InputStruct2,\n  ImageStruct2,\n  ItalicStruct,\n  LinkStruct,\n  RowStruct2,\n  SpinnerStruct2,\n  TextStruct2,\n  TooltipStruct,\n  CheckboxStruct\n]);\nvar RootJSXElementStruct = BoxChildStruct;\nvar JSXElementStruct = nullUnion([\n  ButtonStruct2,\n  InputStruct2,\n  FileInputStruct,\n  FieldStruct,\n  FormStruct2,\n  BoldStruct,\n  ItalicStruct,\n  AddressStruct2,\n  BoxStruct,\n  CopyableStruct2,\n  DividerStruct2,\n  HeadingStruct2,\n  ImageStruct2,\n  LinkStruct,\n  RowStruct2,\n  SpinnerStruct2,\n  TextStruct2,\n  DropdownStruct,\n  OptionStruct,\n  ValueStruct,\n  TooltipStruct,\n  CheckboxStruct,\n  FooterStruct,\n  ContainerStruct\n]);\n\n// src/types/interface.ts\nvar StateStruct = union8([FileStruct, string12(), boolean5()]);\nvar FormStateStruct = record3(string12(), nullable3(StateStruct));\nvar InterfaceStateStruct = record3(\n  string12(),\n  union8([FormStateStruct, nullable3(StateStruct)])\n);\nvar ComponentOrElementStruct = union8([\n  ComponentStruct,\n  RootJSXElementStruct\n]);\nvar InterfaceContextStruct = record3(string12(), JsonStruct2);\nexport {\n  AddressStruct,\n  AuxiliaryFileEncoding,\n  ButtonClickEventStruct,\n  ButtonStruct,\n  ButtonType,\n  ButtonVariant,\n  ChainDisconnectedError,\n  ComponentOrElementStruct,\n  ComponentStruct,\n  CopyableStruct,\n  DialogType,\n  DisconnectedError,\n  DividerStruct,\n  FileStruct,\n  FileUploadEventStruct,\n  FormComponentStruct,\n  FormStateStruct,\n  FormStruct,\n  FormSubmitEventStruct,\n  GenericEventStruct,\n  HeadingStruct,\n  ImageStruct,\n  InputChangeEventStruct,\n  InputStruct,\n  InputType,\n  InterfaceContextStruct,\n  InterfaceStateStruct,\n  InternalError,\n  InvalidInputError,\n  InvalidParamsError,\n  InvalidRequestError,\n  LimitExceededError,\n  ManageStateOperation,\n  MethodNotFoundError,\n  MethodNotSupportedError,\n  NodeType,\n  NotificationType,\n  PanelStruct,\n  ParseError,\n  ResourceNotFoundError,\n  ResourceUnavailableError,\n  RowStruct,\n  RowVariant,\n  SNAP_ERROR_CODE,\n  SNAP_ERROR_MESSAGE,\n  SeverityLevel,\n  SnapError,\n  SpinnerStruct,\n  StateStruct,\n  TextStruct,\n  TransactionRejected,\n  UnauthorizedError,\n  UnsupportedMethodError,\n  UserInputEventStruct,\n  UserInputEventType,\n  UserRejectedRequestError,\n  address,\n  assert2 as assert,\n  assertIsComponent,\n  button,\n  copyable,\n  divider,\n  enumValue,\n  form,\n  getErrorData,\n  getErrorMessage,\n  getErrorStack,\n  getImageComponent,\n  getImageData,\n  heading,\n  image,\n  input,\n  isComponent,\n  literal,\n  panel,\n  row,\n  spinner,\n  text,\n  union\n};\n//# sourceMappingURL=index.mjs.map","import {\n  MethodNotFoundError,\n  type OnRpcRequestHandler,\n} from '@metamask/snaps-sdk';\n\n/**\n * Handle incoming JSON-RPC requests from the dapp, sent through the\n * `wallet_invokeSnap` method. This handler handles a single method:\n *\n * - `hello`: Returns a static message, \"Hello from Webpack!\". This is just\n * for demonstration purposes, showing that a snap can be built with\n * Webpack.\n *\n * @param params - The request parameters.\n * @param params.request - The JSON-RPC request object.\n * @returns The JSON-RPC response.\n * @see https://docs.metamask.io/snaps/reference/exports/#onrpcrequest\n * @see https://docs.metamask.io/snaps/reference/rpc-api/#wallet_invokesnap\n */\nexport const onRpcRequest: OnRpcRequestHandler = async ({ request }) => {\n  switch (request.method) {\n    case 'hello':\n      return 'Hello from Webpack!';\n\n    default:\n      throw new MethodNotFoundError({ method: request.method });\n  }\n};\n"],"names":["module","exports","stringify","default","stable","deterministicStringify","stableStringify","LIMIT_REPLACE_NODE","CIRCULAR_REPLACE_NODE","arr","replacerStack","defaultOptions","depthLimit","Number","MAX_SAFE_INTEGER","edgesLimit","obj","replacer","spacer","options","res","decirc","undefined","length","JSON","replaceGetterValues","_","part","pop","Object","defineProperty","setReplace","replace","val","k","parent","propertyDescriptor","getOwnPropertyDescriptor","get","configurable","value","push","edgeIndex","stack","depth","i","Array","isArray","keys","key","compareFunction","a","b","tmp","deterministicDecirc","toJSON","sort","v","splice","call","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","d","definition","o","enumerable","prop","prototype","hasOwnProperty","r","Symbol","toStringTag","misc_isObject","Boolean","misc_hasProperty","objectToCheck","name","JsonSize","misc_isPlainObject","proto","getPrototypeOf","StructError","TypeError","constructor","failure","failures","cached","message","explanation","rest","path","cause","join","assign","utils_isObject","utils_print","toString","toFailure","result","context","struct","branch","type","refinement","toFailures","iterator","isIterable","validationResult","run","coerce","mask","coercer","schema","status","validator","innerKey","innerValue","innerStruct","entries","iterable","Map","set","Set","add","refiner","struct_Struct","props","assert","struct_assert","create","is","struct_is","validate","tuples","tuple","input","done","next","shiftIterator","innerTuple","utilities_assign","Structs","isType","schemas","map","types_type","types_object","utilities_define","lazy","fn","ctx","array","Element","index","arrayValue","slice","types_boolean","literal","constant","description","valueType","never","nullable","number","isNaN","knowns","Never","unknowns","delete","types_optional","record","Key","Value","objectKey","objectValue","types_string","Math","max","union","InnerStruct","error","coerced","first","types_unknown","condition","getErrorMessageWithoutTrailingPeriod","isErrorWithMessage","String","getErrorMessage","getError","ErrorWrapper","AssertionError","Error","code","assert_assertStruct","errorPrefix","json_object","hasOptional","field","exactOptional","UnsafeJsonStruct","isFinite","JsonStruct","parse","propKey","propValue","isValidJson","getSafeJson","JsonRpcVersionStruct","JsonRpcIdStruct","JsonRpcErrorStruct","isInteger","data","JsonRpcParamsStruct","id","jsonrpc","method","params","JsonRpcSuccessStruct","JsonRpcFailureStruct","pattern","regexp","refine","test","source","errorCodes","invalidInput","resourceNotFound","resourceUnavailable","transactionRejected","methodNotSupported","limitExceeded","invalidRequest","methodNotFound","invalidParams","internal","userRejectedRequest","unauthorized","unsupportedMethod","disconnected","chainDisconnected","errorValues","standard","FALLBACK_ERROR_CODE","FALLBACK_MESSAGE","JSON_RPC_SERVER_ERROR_MESSAGE","getMessageFromCode","fallbackMessage","isValidCode","codeString","isJsonRpcServerError","serializeCause","entry","serializeObject","object","getOwnPropertyNames","reduce","acc","JsonRpcError","serialize","serialized","this","fast_safe_stringify","stringifyReplacer","EthereumProviderError","isValidEthProviderCode","rpcErrors","arg","getJsonRpcError","providerErrors","getEthProviderError","parseOpts","HexChecksumAddressStruct","_code","_message","_data","_stack","__accessCheck","member","msg","has","__privateGet","getter","__privateAdd","WeakSet","__privateSet","setter","SnapError","dist_getErrorMessage","getErrorCode","mergedData","getErrorData","SNAP_ERROR_CODE","SNAP_ERROR_MESSAGE","createSnapError","error2","WeakMap","dist_literal","enumValue","nullUnion","structs","head","tail","dist_union","svg","includes","MethodNotFoundError","createBuilder","args","node2","node","partialNode","NodeType2","ButtonVariant2","ButtonType2","InputType2","RowVariant2","NodeType","NodeStruct","LiteralStruct","AddressStruct","CopyableStruct","sensitive","DividerStruct","HeadingStruct","ImageStruct","ButtonVariant","ButtonType","ButtonStruct","variant","buttonType","InputType","InputStruct","inputType","placeholder","label","FormComponentStruct","FormStruct","children","TextStruct","markdown","RowVariant","RowComponentStruct","RowStruct","SpinnerStruct","ParentStruct","ComponentStruct","PanelStruct","SeverityLevel2","UserInputEventType2","DialogType2","AuxiliaryFileEncoding2","ManageStateOperation2","NotificationType2","SeverityLevel","UserInputEventType","GenericEventStruct","ButtonClickEventStruct","FileStruct","size","contentType","contents","FormSubmitEventStruct","InputChangeEventStruct","DialogType","file","AuxiliaryFileEncoding","ManageStateOperation","NotificationType","KeyStruct","StringElementStruct","nestableStruct","nestable","dist_element","ButtonStruct2","disabled","CheckboxStruct","checked","InputStruct2","OptionStruct","DropdownStruct","FileInputStruct","accept","compact","BUTTON_INPUT","FIELD_CHILDREN_ARRAY","FieldChildStruct","FieldStruct","FormStruct2","BoxChildStruct","BoldStruct","ItalicStruct","FormattingStruct","AddressStruct2","address","BoxStruct","direction","alignment","FooterStruct","ContainerStruct","CopyableStruct2","DividerStruct2","ValueStruct","extra","HeadingStruct2","ImageStruct2","src","alt","LinkStruct","href","TextStruct2","TooltipChildStruct","TooltipContentStruct","TooltipStruct","content","RowStruct2","tooltip","SpinnerStruct2","RootJSXElementStruct","StateStruct","FormStateStruct","onRpcRequest","async","request"],"sourceRoot":""}