{"version":3,"file":"bundle.js","sources":["../../../../../node_modules/@metamask/superstruct/dist/error.mjs","../../../../../node_modules/@metamask/superstruct/dist/utils.mjs","../../../../../node_modules/@metamask/superstruct/dist/struct.mjs","../../../../../node_modules/@metamask/superstruct/dist/structs/utilities.mjs","../../../../../node_modules/@metamask/superstruct/dist/structs/types.mjs","../../../../../node_modules/@metamask/superstruct/dist/structs/refinements.mjs","../../../../../node_modules/@metamask/utils/dist/misc.mjs","../../../../../node_modules/@metamask/utils/dist/assert.mjs","../../../../../node_modules/@metamask/utils/dist/errors.mjs","../../../../../node_modules/@metamask/utils/dist/hex.mjs","../../../../../node_modules/@metamask/utils/dist/json.mjs","../../../../../node_modules/@metamask/superstruct/dist/structs/coercions.mjs","../../../../../node_modules/@metamask/rpc-errors/dist/chunk-MIW4NMY6.mjs","../../../../../node_modules/@metamask/rpc-errors/dist/chunk-HHE56EX3.mjs","../../../../../node_modules/fast-safe-stringify/index.js","../../../../../node_modules/@metamask/rpc-errors/dist/chunk-ROLUROML.mjs","../../../../../node_modules/@metamask/rpc-errors/dist/chunk-22ZLYCIT.mjs","../../../../snaps-sdk/dist/index.mjs","../src/index.ts"],"sourcesContent":["/**\n * A `StructFailure` represents a single specific failure in validation.\n */\n/**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */\nexport class StructError extends TypeError {\n    constructor(failure, failures) {\n        let cached;\n        const { message, explanation, ...rest } = failure;\n        const { path } = failure;\n        const cause = path.length === 0 ? message : `At path: ${path.join('.')} -- ${message}`;\n        super(explanation ?? cause);\n        if (explanation !== null && explanation !== undefined) {\n            this.cause = cause;\n        }\n        Object.assign(this, rest);\n        this.name = this.constructor.name;\n        this.failures = () => {\n            return (cached ?? (cached = [failure, ...failures()]));\n        };\n    }\n}\n//# sourceMappingURL=error.mjs.map","/**\n * Check if a value is an iterator.\n *\n * @param value - The value to check.\n * @returns Whether the value is an iterator.\n */\nfunction isIterable(value) {\n    return isObject(value) && typeof value[Symbol.iterator] === 'function';\n}\n/**\n * Check if a value is a plain object.\n *\n * @param value - The value to check.\n * @returns Whether the value is a plain object.\n */\nexport function isObject(value) {\n    return typeof value === 'object' && value !== null;\n}\n/**\n * Check if a value is a plain object.\n *\n * @param value - The value to check.\n * @returns Whether the value is a plain object.\n */\nexport function isPlainObject(value) {\n    if (Object.prototype.toString.call(value) !== '[object Object]') {\n        return false;\n    }\n    const prototype = Object.getPrototypeOf(value);\n    return prototype === null || prototype === Object.prototype;\n}\n/**\n * Return a value as a printable string.\n *\n * @param value - The value to print.\n * @returns The value as a string.\n */\nexport function print(value) {\n    if (typeof value === 'symbol') {\n        return value.toString();\n    }\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    return typeof value === 'string' ? JSON.stringify(value) : `${value}`;\n}\n/**\n * Shift (remove and return) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n *\n * @param input - The iterator to shift.\n * @returns The first value of the iterator, or `undefined` if the iterator is\n * empty.\n */\nexport function shiftIterator(input) {\n    const { done, value } = input.next();\n    return done ? undefined : value;\n}\n/**\n * Convert a single validation result to a failure.\n *\n * @param result - The result to convert.\n * @param context - The context of the validation.\n * @param struct - The struct being validated.\n * @param value - The value being validated.\n * @returns A failure if the result is a failure, or `undefined` if the result\n * is a success.\n */\nexport function toFailure(result, context, struct, value) {\n    if (result === true) {\n        return undefined;\n    }\n    else if (result === false) {\n        // eslint-disable-next-line no-param-reassign\n        result = {};\n    }\n    else if (typeof result === 'string') {\n        // eslint-disable-next-line no-param-reassign\n        result = { message: result };\n    }\n    const { path, branch } = context;\n    const { type } = struct;\n    const { refinement, message = `Expected a value of type \\`${type}\\`${refinement ? ` with refinement \\`${refinement}\\`` : ''}, but received: \\`${print(value)}\\``, } = result;\n    return {\n        value,\n        type,\n        refinement,\n        key: path[path.length - 1],\n        path,\n        branch,\n        ...result,\n        message,\n    };\n}\n/**\n * Convert a validation result to an iterable of failures.\n *\n * @param result - The result to convert.\n * @param context - The context of the validation.\n * @param struct - The struct being validated.\n * @param value - The value being validated.\n * @yields The failures.\n * @returns An iterable of failures.\n */\nexport function* toFailures(result, context, struct, value) {\n    if (!isIterable(result)) {\n        // eslint-disable-next-line no-param-reassign\n        result = [result];\n    }\n    for (const validationResult of result) {\n        const failure = toFailure(validationResult, context, struct, value);\n        if (failure) {\n            yield failure;\n        }\n    }\n}\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n *\n * @param value - The value to check.\n * @param struct - The struct to check against.\n * @param options - Optional settings.\n * @param options.path - The path to the value in the input data.\n * @param options.branch - The branch of the value in the input data.\n * @param options.coerce - Whether to coerce the value before validating it.\n * @param options.mask - Whether to mask the value before validating it.\n * @param options.message - An optional message to include in the error.\n * @yields An iterator of failures or success.\n * @returns An iterator of failures or success.\n */\nexport function* run(value, struct, options = {}) {\n    const { path = [], branch = [value], coerce = false, mask = false } = options;\n    const context = { path, branch };\n    if (coerce) {\n        // eslint-disable-next-line no-param-reassign\n        value = struct.coercer(value, context);\n        if (mask &&\n            struct.type !== 'type' &&\n            isObject(struct.schema) &&\n            isObject(value) &&\n            !Array.isArray(value)) {\n            for (const key in value) {\n                if (struct.schema[key] === undefined) {\n                    delete value[key];\n                }\n            }\n        }\n    }\n    let status = 'valid';\n    for (const failure of struct.validator(value, context)) {\n        failure.explanation = options.message;\n        status = 'not_valid';\n        yield [failure, undefined];\n    }\n    // eslint-disable-next-line prefer-const\n    for (let [innerKey, innerValue, innerStruct] of struct.entries(value, context)) {\n        const iterable = run(innerValue, innerStruct, {\n            path: innerKey === undefined ? path : [...path, innerKey],\n            branch: innerKey === undefined ? branch : [...branch, innerValue],\n            coerce,\n            mask,\n            message: options.message,\n        });\n        for (const result of iterable) {\n            if (result[0]) {\n                status =\n                    result[0].refinement === null || result[0].refinement === undefined\n                        ? 'not_valid'\n                        : 'not_refined';\n                yield [result[0], undefined];\n            }\n            else if (coerce) {\n                innerValue = result[1];\n                if (innerKey === undefined) {\n                    // eslint-disable-next-line no-param-reassign\n                    value = innerValue;\n                }\n                else if (value instanceof Map) {\n                    value.set(innerKey, innerValue);\n                }\n                else if (value instanceof Set) {\n                    value.add(innerValue);\n                }\n                else if (isObject(value)) {\n                    if (innerValue !== undefined || innerKey in value) {\n                        value[innerKey] = innerValue;\n                    }\n                }\n            }\n        }\n    }\n    if (status !== 'not_valid') {\n        for (const failure of struct.refiner(value, context)) {\n            failure.explanation = options.message;\n            status = 'not_refined';\n            yield [failure, undefined];\n        }\n    }\n    if (status === 'valid') {\n        yield [undefined, value];\n    }\n}\n//# sourceMappingURL=utils.mjs.map","import { StructError } from \"./error.mjs\";\nimport { toFailures, shiftIterator, run } from \"./utils.mjs\";\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */\nexport class Struct {\n    constructor(props) {\n        const { type, schema, validator, refiner, coercer = (value) => value, entries = function* () {\n            /* noop */\n        }, } = props;\n        this.type = type;\n        this.schema = schema;\n        this.entries = entries;\n        this.coercer = coercer;\n        if (validator) {\n            this.validator = (value, context) => {\n                const result = validator(value, context);\n                return toFailures(result, context, this, value);\n            };\n        }\n        else {\n            this.validator = () => [];\n        }\n        if (refiner) {\n            this.refiner = (value, context) => {\n                const result = refiner(value, context);\n                return toFailures(result, context, this, value);\n            };\n        }\n        else {\n            this.refiner = () => [];\n        }\n    }\n    /**\n     * Assert that a value passes the struct's validation, throwing if it doesn't.\n     */\n    assert(value, message) {\n        return assert(value, this, message);\n    }\n    /**\n     * Create a value with the struct's coercion logic, then validate it.\n     */\n    create(value, message) {\n        return create(value, this, message);\n    }\n    /**\n     * Check if a value passes the struct's validation.\n     */\n    is(value) {\n        return is(value, this);\n    }\n    /**\n     * Mask a value, coercing and validating it, but returning only the subset of\n     * properties defined by the struct's schema.\n     */\n    mask(value, message) {\n        return mask(value, this, message);\n    }\n    /**\n     * Validate a value with the struct's validation logic, returning a tuple\n     * representing the result.\n     *\n     * You may optionally pass `true` for the `withCoercion` argument to coerce\n     * the value before attempting to validate it. If you do, the result will\n     * contain the coerced result when successful.\n     */\n    validate(value, options = {}) {\n        return validate(value, this, options);\n    }\n}\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n *\n * @param value - The value to validate.\n * @param struct - The struct to validate against.\n * @param message - An optional message to include in the error.\n */\nexport function assert(value, struct, message) {\n    const result = validate(value, struct, { message });\n    if (result[0]) {\n        throw result[0];\n    }\n}\n/**\n * Create a value with the coercion logic of struct and validate it.\n *\n * @param value - The value to coerce and validate.\n * @param struct - The struct to validate against.\n * @param message - An optional message to include in the error.\n * @returns The coerced and validated value.\n */\nexport function create(value, struct, message) {\n    const result = validate(value, struct, { coerce: true, message });\n    if (result[0]) {\n        throw result[0];\n    }\n    else {\n        return result[1];\n    }\n}\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n *\n * @param value - The value to mask.\n * @param struct - The struct to mask against.\n * @param message - An optional message to include in the error.\n * @returns The masked value.\n */\nexport function mask(value, struct, message) {\n    const result = validate(value, struct, { coerce: true, mask: true, message });\n    if (result[0]) {\n        throw result[0];\n    }\n    else {\n        return result[1];\n    }\n}\n/**\n * Check if a value passes a struct.\n *\n * @param value - The value to validate.\n * @param struct - The struct to validate against.\n * @returns `true` if the value passes the struct, `false` otherwise.\n */\nexport function is(value, struct) {\n    const result = validate(value, struct);\n    return !result[0];\n}\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n *\n * @param value - The value to validate.\n * @param struct - The struct to validate against.\n * @param options - Optional settings.\n * @param options.coerce - Whether to coerce the value before validating it.\n * @param options.mask - Whether to mask the value before validating it.\n * @param options.message - An optional message to include in the error.\n * @returns A tuple containing the error (if invalid) and the validated value.\n */\nexport function validate(value, struct, options = {}) {\n    const tuples = run(value, struct, options);\n    const tuple = shiftIterator(tuples);\n    if (tuple[0]) {\n        const error = new StructError(tuple[0], function* () {\n            for (const innerTuple of tuples) {\n                if (innerTuple[0]) {\n                    yield innerTuple[0];\n                }\n            }\n        });\n        return [error, undefined];\n    }\n    const validatedValue = tuple[1];\n    return [undefined, validatedValue];\n}\n//# sourceMappingURL=struct.mjs.map","import { Struct } from \"../struct.mjs\";\nimport { object, optional, type } from \"./types.mjs\";\n/**\n * Create a new struct that combines the properties from multiple object or type\n * structs. Its return type will match the first parameter's type.\n *\n * @param Structs - The structs to combine.\n * @returns A new struct that combines the properties of the input structs.\n */\nexport function assign(...Structs) {\n    const isType = Structs[0]?.type === 'type';\n    const schemas = Structs.map(({ schema }) => schema);\n    const schema = Object.assign({}, ...schemas);\n    return isType ? type(schema) : object(schema);\n}\n/**\n * Define a new struct type with a custom validation function.\n *\n * @param name - The name of the struct type.\n * @param validator - The validation function.\n * @returns A new struct type.\n */\nexport function define(name, validator) {\n    return new Struct({ type: name, schema: null, validator });\n}\n/**\n * Create a new struct based on an existing struct, but the value is allowed to\n * be `undefined`. `log` will be called if the value is not `undefined`.\n *\n * @param struct - The struct to augment.\n * @param log - The function to call when the value is not `undefined`.\n * @returns A new struct that will only accept `undefined` or values that pass\n * the input struct.\n */\nexport function deprecated(struct, log) {\n    return new Struct({\n        ...struct,\n        refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n        validator(value, ctx) {\n            if (value === undefined) {\n                return true;\n            }\n            log(value, ctx);\n            return struct.validator(value, ctx);\n        },\n    });\n}\n/**\n * Create a struct with dynamic validation logic.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n *\n * @param fn - The callback to create the struct.\n * @returns A new struct with dynamic validation logic.\n */\nexport function dynamic(fn) {\n    return new Struct({\n        type: 'dynamic',\n        schema: null,\n        *entries(value, ctx) {\n            const struct = fn(value, ctx);\n            yield* struct.entries(value, ctx);\n        },\n        validator(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.validator(value, ctx);\n        },\n        coercer(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.coercer(value, ctx);\n        },\n        refiner(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.refiner(value, ctx);\n        },\n    });\n}\n/**\n * Create a struct with lazily evaluated validation logic.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n *\n * @param fn - The callback to create the struct.\n * @returns A new struct with lazily evaluated validation logic.\n */\nexport function lazy(fn) {\n    let struct;\n    return new Struct({\n        type: 'lazy',\n        schema: null,\n        *entries(value, ctx) {\n            struct ?? (struct = fn());\n            yield* struct.entries(value, ctx);\n        },\n        validator(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.validator(value, ctx);\n        },\n        coercer(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.coercer(value, ctx);\n        },\n        refiner(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.refiner(value, ctx);\n        },\n    });\n}\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n *\n * @param struct - The struct to augment.\n * @param keys - The keys to omit.\n * @returns A new struct that will not accept the input keys.\n */\nexport function omit(struct, keys) {\n    const { schema } = struct;\n    const subschema = { ...schema };\n    for (const key of keys) {\n        delete subschema[key];\n    }\n    switch (struct.type) {\n        case 'type':\n            return type(subschema);\n        default:\n            return object(subschema);\n    }\n}\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that will accept the input keys as `undefined`.\n */\nexport function partial(struct) {\n    const isStruct = struct instanceof Struct;\n    const schema = isStruct ? { ...struct.schema } : { ...struct };\n    // eslint-disable-next-line guard-for-in\n    for (const key in schema) {\n        schema[key] = optional(schema[key]);\n    }\n    if (isStruct && struct.type === 'type') {\n        return type(schema);\n    }\n    return object(schema);\n}\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n *\n * @param struct - The struct to augment.\n * @param keys - The keys to pick.\n * @returns A new struct that will only accept the input keys.\n */\nexport function pick(struct, keys) {\n    const { schema } = struct;\n    const subschema = {};\n    for (const key of keys) {\n        subschema[key] = schema[key];\n    }\n    switch (struct.type) {\n        case 'type':\n            return type(subschema);\n        default:\n            return object(subschema);\n    }\n}\n//# sourceMappingURL=utilities.mjs.map","import { Struct } from \"../struct.mjs\";\nimport { print, run, isObject } from \"../utils.mjs\";\nimport { define } from \"./utilities.mjs\";\n/**\n * Ensure that any value passes validation.\n *\n * @returns A struct that will always pass validation.\n */\nexport function any() {\n    return define('any', () => true);\n}\n/**\n * Ensure that a value is an array and that its elements are of a specific type.\n *\n * Note: If you omit the element struct, the arrays elements will not be\n * iterated at all. This can be helpful for cases where performance is critical,\n * and it is preferred to using `array(any())`.\n *\n * @param Element - The struct to validate each element in the array against.\n * @returns A new struct that will only accept arrays of the given type.\n */\nexport function array(Element) {\n    return new Struct({\n        type: 'array',\n        schema: Element,\n        *entries(value) {\n            if (Element && Array.isArray(value)) {\n                for (const [index, arrayValue] of value.entries()) {\n                    yield [index, arrayValue, Element];\n                }\n            }\n        },\n        coercer(value) {\n            return Array.isArray(value) ? value.slice() : value;\n        },\n        validator(value) {\n            return (Array.isArray(value) ||\n                `Expected an array value, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a bigint.\n *\n * @returns A new struct that will only accept bigints.\n */\nexport function bigint() {\n    return define('bigint', (value) => {\n        return typeof value === 'bigint';\n    });\n}\n/**\n * Ensure that a value is a boolean.\n *\n * @returns A new struct that will only accept booleans.\n */\nexport function boolean() {\n    return define('boolean', (value) => {\n        return typeof value === 'boolean';\n    });\n}\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n *\n * @returns A new struct that will only accept valid `Date` objects.\n */\nexport function date() {\n    return define('date', (value) => {\n        return ((value instanceof Date && !isNaN(value.getTime())) ||\n            `Expected a valid \\`Date\\` object, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is one of a set of potential values.\n *\n * Note: after creating the struct, you can access the definition of the\n * potential values as `struct.schema`.\n *\n * @param values - The potential values that the input can be.\n * @returns A new struct that will only accept the given values.\n */\nexport function enums(values) {\n    const schema = {};\n    const description = values.map((value) => print(value)).join();\n    for (const key of values) {\n        schema[key] = key;\n    }\n    return new Struct({\n        type: 'enums',\n        schema,\n        validator(value) {\n            return (values.includes(value) ||\n                `Expected one of \\`${description}\\`, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a function.\n *\n * @returns A new struct that will only accept functions.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function func() {\n    return define('func', (value) => {\n        return (typeof value === 'function' ||\n            `Expected a function, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is an instance of a specific class.\n *\n * @param Class - The class that the value must be an instance of.\n * @returns A new struct that will only accept instances of the given class.\n */\nexport function instance(Class) {\n    return define('instance', (value) => {\n        return (value instanceof Class ||\n            `Expected a \\`${Class.name}\\` instance, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is an integer.\n *\n * @returns A new struct that will only accept integers.\n */\nexport function integer() {\n    return define('integer', (value) => {\n        return ((typeof value === 'number' && !isNaN(value) && Number.isInteger(value)) ||\n            `Expected an integer, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value matches all of a set of types.\n *\n * @param Structs - The set of structs that the value must match.\n * @returns A new struct that will only accept values that match all of the\n * given structs.\n */\nexport function intersection(Structs) {\n    return new Struct({\n        type: 'intersection',\n        schema: null,\n        *entries(value, context) {\n            for (const { entries } of Structs) {\n                yield* entries(value, context);\n            }\n        },\n        *validator(value, context) {\n            for (const { validator } of Structs) {\n                yield* validator(value, context);\n            }\n        },\n        *refiner(value, context) {\n            for (const { refiner } of Structs) {\n                yield* refiner(value, context);\n            }\n        },\n    });\n}\n/**\n * Ensure that a value is an exact value, using `===` for comparison.\n *\n * @param constant - The exact value that the input must be.\n * @returns A new struct that will only accept the exact given value.\n */\nexport function literal(constant) {\n    const description = print(constant);\n    const valueType = typeof constant;\n    return new Struct({\n        type: 'literal',\n        schema: valueType === 'string' ||\n            valueType === 'number' ||\n            valueType === 'boolean'\n            ? constant\n            : null,\n        validator(value) {\n            return (value === constant ||\n                `Expected the literal \\`${description}\\`, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a `Map` object, and that its keys and values are of\n * specific types.\n *\n * @param Key - The struct to validate each key in the map against.\n * @param Value - The struct to validate each value in the map against.\n * @returns A new struct that will only accept `Map` objects.\n */\nexport function map(Key, Value) {\n    return new Struct({\n        type: 'map',\n        schema: null,\n        *entries(value) {\n            if (Key && Value && value instanceof Map) {\n                for (const [mapKey, mapValue] of value.entries()) {\n                    yield [mapKey, mapKey, Key];\n                    yield [mapKey, mapValue, Value];\n                }\n            }\n        },\n        coercer(value) {\n            return value instanceof Map ? new Map(value) : value;\n        },\n        validator(value) {\n            return (value instanceof Map ||\n                `Expected a \\`Map\\` object, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that no value ever passes validation.\n *\n * @returns A new struct that will never pass validation.\n */\nexport function never() {\n    return define('never', () => false);\n}\n/**\n * Augment an existing struct to allow `null` values.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that will accept `null` values.\n */\nexport function nullable(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx) => value === null || struct.validator(value, ctx),\n        refiner: (value, ctx) => value === null || struct.refiner(value, ctx),\n    });\n}\n/**\n * Ensure that a value is a number.\n *\n * @returns A new struct that will only accept numbers.\n */\nexport function number() {\n    return define('number', (value) => {\n        return ((typeof value === 'number' && !isNaN(value)) ||\n            `Expected a number, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is an object, that it has a known set of properties,\n * and that its properties are of specific types.\n *\n * Note: Unrecognized properties will fail validation.\n *\n * @param schema - An object that defines the structure of the object.\n * @returns A new struct that will only accept objects.\n */\nexport function object(schema) {\n    const knowns = schema ? Object.keys(schema) : [];\n    const Never = never();\n    return new Struct({\n        type: 'object',\n        schema: schema ?? null,\n        *entries(value) {\n            if (schema && isObject(value)) {\n                const unknowns = new Set(Object.keys(value));\n                for (const key of knowns) {\n                    unknowns.delete(key);\n                    yield [key, value[key], schema[key]];\n                }\n                for (const key of unknowns) {\n                    yield [key, value[key], Never];\n                }\n            }\n        },\n        validator(value) {\n            return (isObject(value) || `Expected an object, but received: ${print(value)}`);\n        },\n        coercer(value) {\n            return isObject(value) ? { ...value } : value;\n        },\n    });\n}\n/**\n * Augment a struct to allow `undefined` values.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that will accept `undefined` values.\n */\nexport function optional(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx) => value === undefined || struct.validator(value, ctx),\n        refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n    });\n}\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * @param Key - The struct to validate each key in the record against.\n * @param Value - The struct to validate each value in the record against.\n * @returns A new struct that will only accept objects.\n */\nexport function record(Key, Value) {\n    return new Struct({\n        type: 'record',\n        schema: null,\n        *entries(value) {\n            if (isObject(value)) {\n                // eslint-disable-next-line guard-for-in\n                for (const objectKey in value) {\n                    const objectValue = value[objectKey];\n                    yield [objectKey, objectKey, Key];\n                    yield [objectKey, objectValue, Value];\n                }\n            }\n        },\n        validator(value) {\n            return (isObject(value) || `Expected an object, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n *\n * @returns A new struct that will only accept `RegExp` objects.\n */\nexport function regexp() {\n    return define('regexp', (value) => {\n        return value instanceof RegExp;\n    });\n}\n/**\n * Ensure that a value is a `Set` object, and that its elements are of a\n * specific type.\n *\n * @param Element - The struct to validate each element in the set against.\n * @returns A new struct that will only accept `Set` objects.\n */\nexport function set(Element) {\n    return new Struct({\n        type: 'set',\n        schema: null,\n        *entries(value) {\n            if (Element && value instanceof Set) {\n                for (const setValue of value) {\n                    yield [setValue, setValue, Element];\n                }\n            }\n        },\n        coercer(value) {\n            return value instanceof Set ? new Set(value) : value;\n        },\n        validator(value) {\n            return (value instanceof Set ||\n                `Expected a \\`Set\\` object, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a string.\n *\n * @returns A new struct that will only accept strings.\n */\nexport function string() {\n    return define('string', (value) => {\n        return (typeof value === 'string' ||\n            `Expected a string, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is a tuple of a specific length, and that each of its\n * elements is of a specific type.\n *\n * @param Structs - The set of structs that the value must match.\n * @returns A new struct that will only accept tuples of the given types.\n */\nexport function tuple(Structs) {\n    const Never = never();\n    return new Struct({\n        type: 'tuple',\n        schema: null,\n        *entries(value) {\n            if (Array.isArray(value)) {\n                const length = Math.max(Structs.length, value.length);\n                for (let i = 0; i < length; i++) {\n                    yield [i, value[i], Structs[i] || Never];\n                }\n            }\n        },\n        validator(value) {\n            return (Array.isArray(value) ||\n                `Expected an array, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n *\n * @param schema - An object that defines the structure of the object.\n * @returns A new struct that will only accept objects.\n */\nexport function type(schema) {\n    const keys = Object.keys(schema);\n    return new Struct({\n        type: 'type',\n        schema,\n        *entries(value) {\n            if (isObject(value)) {\n                for (const k of keys) {\n                    yield [k, value[k], schema[k]];\n                }\n            }\n        },\n        validator(value) {\n            return (isObject(value) || `Expected an object, but received: ${print(value)}`);\n        },\n        coercer(value) {\n            return isObject(value) ? { ...value } : value;\n        },\n    });\n}\n/**\n * Ensure that a value matches one of a set of types.\n *\n * @param Structs - The set of structs that the value must match.\n * @returns A new struct that will only accept values that match one of the\n * given structs.\n */\nexport function union(Structs) {\n    const description = Structs.map((struct) => struct.type).join(' | ');\n    return new Struct({\n        type: 'union',\n        schema: null,\n        coercer(value) {\n            for (const InnerStruct of Structs) {\n                const [error, coerced] = InnerStruct.validate(value, { coerce: true });\n                if (!error) {\n                    return coerced;\n                }\n            }\n            return value;\n        },\n        validator(value, ctx) {\n            const failures = [];\n            for (const InnerStruct of Structs) {\n                const [...tuples] = run(value, InnerStruct, ctx);\n                const [first] = tuples;\n                if (!first?.[0]) {\n                    return [];\n                }\n                for (const [failure] of tuples) {\n                    if (failure) {\n                        failures.push(failure);\n                    }\n                }\n            }\n            return [\n                `Expected the value to satisfy a union of \\`${description}\\`, but received: ${print(value)}`,\n                ...failures,\n            ];\n        },\n    });\n}\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n *\n * @returns A struct that will always pass validation.\n */\nexport function unknown() {\n    return define('unknown', () => true);\n}\n//# sourceMappingURL=types.mjs.map","import { Struct } from \"../struct.mjs\";\nimport { toFailures } from \"../utils.mjs\";\n/**\n * Ensure that a string, array, map, or set is empty.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that will only accept empty values.\n */\nexport function empty(struct) {\n    return refine(struct, 'empty', (value) => {\n        // eslint-disable-next-line @typescript-eslint/no-shadow\n        const size = getSize(value);\n        return (size === 0 ||\n            `Expected an empty ${struct.type} but received one with a size of \\`${size}\\``);\n    });\n}\n/**\n * Get the size of a string, array, map, or set.\n *\n * @param value - The value to measure.\n * @returns The size of the value.\n */\nfunction getSize(value) {\n    if (value instanceof Map || value instanceof Set) {\n        return value.size;\n    }\n    return value.length;\n}\n/**\n * Ensure that a number or date is below a threshold.\n *\n * @param struct - The struct to augment.\n * @param threshold - The maximum value that the input can be.\n * @param options - An optional options object.\n * @param options.exclusive - When `true`, the input must be strictly less than\n * the threshold. When `false`, the input must be less than or equal to the\n * threshold.\n * @returns A new struct that will only accept values below the threshold.\n */\nexport function max(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, 'max', (value) => {\n        return exclusive\n            ? value < threshold\n            : value <= threshold ||\n                `Expected a ${struct.type} less than ${exclusive ? '' : 'or equal to '\n                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n                }${threshold} but received \\`${value}\\``;\n    });\n}\n/**\n * Ensure that a number or date is above a threshold.\n *\n * @param struct - The struct to augment.\n * @param threshold - The minimum value that the input can be.\n * @param options - An optional options object.\n * @param options.exclusive - When `true`, the input must be strictly greater\n * than the threshold. When `false`, the input must be greater than or equal to\n * the threshold.\n * @returns A new struct that will only accept values above the threshold.\n */\nexport function min(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, 'min', (value) => {\n        return exclusive\n            ? value > threshold\n            : value >= threshold ||\n                `Expected a ${struct.type} greater than ${exclusive ? '' : 'or equal to '\n                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n                }${threshold} but received \\`${value}\\``;\n    });\n}\n/**\n * Ensure that a string, array, map or set is not empty.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that will only accept non-empty values.\n */\nexport function nonempty(struct) {\n    return refine(struct, 'nonempty', (value) => {\n        // eslint-disable-next-line @typescript-eslint/no-shadow\n        const size = getSize(value);\n        return (size > 0 || `Expected a nonempty ${struct.type} but received an empty one`);\n    });\n}\n/**\n * Ensure that a string matches a regular expression.\n *\n * @param struct - The struct to augment.\n * @param regexp - The regular expression to match against.\n * @returns A new struct that will only accept strings matching the regular\n * expression.\n */\nexport function pattern(struct, regexp) {\n    return refine(struct, 'pattern', (value) => {\n        return (regexp.test(value) ||\n            `Expected a ${struct.type} matching \\`/${regexp.source}/\\` but received \"${value}\"`);\n    });\n}\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length,\n * or time) between `min` and `max`.\n *\n * @param struct - The struct to augment.\n * @param minimum - The minimum size that the input can be.\n * @param maximum - The maximum size that the input can be.\n * @returns A new struct that will only accept values within the given size\n * range.\n */\nexport function size(struct, minimum, maximum = minimum) {\n    const expected = `Expected a ${struct.type}`;\n    const of = minimum === maximum\n        ? `of \\`${minimum}\\``\n        : `between \\`${minimum}\\` and \\`${maximum}\\``;\n    return refine(struct, 'size', (value) => {\n        if (typeof value === 'number' || value instanceof Date) {\n            return ((minimum <= value && value <= maximum) ||\n                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n                `${expected} ${of} but received \\`${value}\\``);\n        }\n        else if (value instanceof Map || value instanceof Set) {\n            // eslint-disable-next-line @typescript-eslint/no-shadow\n            const { size } = value;\n            return ((minimum <= size && size <= maximum) ||\n                `${expected} with a size ${of} but received one with a size of \\`${size}\\``);\n        }\n        const { length } = value;\n        return ((minimum <= length && length <= maximum) ||\n            `${expected} with a length ${of} but received one with a length of \\`${length}\\``);\n    });\n}\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n *\n * @param struct - The struct to augment.\n * @param name - The name of the refinement.\n * @param refiner - The refiner function.\n * @returns A new struct that will run the refiner function after the existing\n * validation.\n */\nexport function refine(struct, name, refiner) {\n    return new Struct({\n        ...struct,\n        *refiner(value, ctx) {\n            yield* struct.refiner(value, ctx);\n            const result = refiner(value, ctx);\n            const failures = toFailures(result, ctx, struct, value);\n            for (const failure of failures) {\n                yield { ...failure, refinement: name };\n            }\n        },\n    });\n}\n//# sourceMappingURL=refinements.mjs.map","//\n// Types\n//\n//\n// Type Guards\n//\n/**\n * A {@link NonEmptyArray} type guard.\n *\n * @template Element - The non-empty array member type.\n * @param value - The value to check.\n * @returns Whether the value is a non-empty array.\n */\nexport function isNonEmptyArray(value) {\n    return Array.isArray(value) && value.length > 0;\n}\n/**\n * Type guard for \"nullishness\".\n *\n * @param value - Any value.\n * @returns `true` if the value is null or undefined, `false` otherwise.\n */\nexport function isNullOrUndefined(value) {\n    return value === null || value === undefined;\n}\n/**\n * A type guard for {@link RuntimeObject}.\n *\n * @param value - The value to check.\n * @returns Whether the specified value has a runtime type of `object` and is\n * neither `null` nor an `Array`.\n */\nexport function isObject(value) {\n    return Boolean(value) && typeof value === 'object' && !Array.isArray(value);\n}\n//\n// Other utility functions\n//\n/**\n * A type guard for ensuring an object has a property.\n *\n * @param objectToCheck - The object to check.\n * @param name - The property name to check for.\n * @returns Whether the specified object has an own property with the specified\n * name, regardless of whether it is enumerable or not.\n */\nexport const hasProperty = (objectToCheck, name) => Object.hasOwnProperty.call(objectToCheck, name);\n/**\n * `Object.getOwnPropertyNames()` is intentionally generic: it returns the\n * immediate property names of an object, but it cannot make guarantees about\n * the contents of that object, so the type of the property names is merely\n * `string[]`. While this is technically accurate, it is also unnecessary if we\n * have an object with a type that we own (such as an enum).\n *\n * @param object - The plain object.\n * @returns The own property names of the object which are assigned a type\n * derived from the object itself.\n */\nexport function getKnownPropertyNames(object) {\n    return Object.getOwnPropertyNames(object);\n}\n/**\n * Predefined sizes (in Bytes) of specific parts of JSON structure.\n */\nexport var JsonSize;\n(function (JsonSize) {\n    JsonSize[JsonSize[\"Null\"] = 4] = \"Null\";\n    JsonSize[JsonSize[\"Comma\"] = 1] = \"Comma\";\n    JsonSize[JsonSize[\"Wrapper\"] = 1] = \"Wrapper\";\n    JsonSize[JsonSize[\"True\"] = 4] = \"True\";\n    JsonSize[JsonSize[\"False\"] = 5] = \"False\";\n    JsonSize[JsonSize[\"Quote\"] = 1] = \"Quote\";\n    JsonSize[JsonSize[\"Colon\"] = 1] = \"Colon\";\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    JsonSize[JsonSize[\"Date\"] = 24] = \"Date\";\n})(JsonSize = JsonSize || (JsonSize = {}));\n/**\n * Regular expression with pattern matching for (special) escaped characters.\n */\nexport const ESCAPE_CHARACTERS_REGEXP = /\"|\\\\|\\n|\\r|\\t/gu;\n/**\n * Check if the value is plain object.\n *\n * @param value - Value to be checked.\n * @returns True if an object is the plain JavaScript object,\n * false if the object is not plain (e.g. function).\n */\nexport function isPlainObject(value) {\n    if (typeof value !== 'object' || value === null) {\n        return false;\n    }\n    try {\n        let proto = value;\n        while (Object.getPrototypeOf(proto) !== null) {\n            proto = Object.getPrototypeOf(proto);\n        }\n        return Object.getPrototypeOf(value) === proto;\n    }\n    catch (_) {\n        return false;\n    }\n}\n/**\n * Check if character is ASCII.\n *\n * @param character - Character.\n * @returns True if a character code is ASCII, false if not.\n */\nexport function isASCII(character) {\n    return character.charCodeAt(0) <= 127;\n}\n/**\n * Calculate string size.\n *\n * @param value - String value to calculate size.\n * @returns Number of bytes used to store whole string value.\n */\nexport function calculateStringSize(value) {\n    const size = value.split('').reduce((total, character) => {\n        if (isASCII(character)) {\n            return total + 1;\n        }\n        return total + 2;\n    }, 0);\n    // Also detect characters that need backslash escape\n    return size + (value.match(ESCAPE_CHARACTERS_REGEXP) ?? []).length;\n}\n/**\n * Calculate size of a number ofter JSON serialization.\n *\n * @param value - Number value to calculate size.\n * @returns Number of bytes used to store whole number in JSON.\n */\nexport function calculateNumberSize(value) {\n    return value.toString().length;\n}\n//# sourceMappingURL=misc.mjs.map","import { assert as assertSuperstruct } from \"@metamask/superstruct\";\nimport { getErrorMessage } from \"./errors.mjs\";\n/**\n * Check if a value is a constructor, i.e., a function that can be called with\n * the `new` keyword.\n *\n * @param fn - The value to check.\n * @returns `true` if the value is a constructor, or `false` otherwise.\n */\nfunction isConstructable(fn) {\n    /* istanbul ignore next */\n    return Boolean(typeof fn?.prototype?.constructor?.name === 'string');\n}\n/**\n * Attempts to obtain the message from a possible error object. If it is\n * possible to do so, any trailing period will be removed from the message;\n * otherwise an empty string is returned.\n *\n * @param error - The error object to get the message from.\n * @returns The message without any trailing period if `error` is an object\n * with a `message` property; the string version of `error` without any trailing\n * period if it is not `undefined` or `null`; otherwise an empty string.\n */\nfunction getErrorMessageWithoutTrailingPeriod(error) {\n    // We'll add our own period.\n    return getErrorMessage(error).replace(/\\.$/u, '');\n}\n/**\n * Initialise an {@link AssertionErrorConstructor} error.\n *\n * @param ErrorWrapper - The error class to use.\n * @param message - The error message.\n * @returns The error object.\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction getError(ErrorWrapper, message) {\n    if (isConstructable(ErrorWrapper)) {\n        return new ErrorWrapper({\n            message,\n        });\n    }\n    return ErrorWrapper({\n        message,\n    });\n}\n/**\n * The default error class that is thrown if an assertion fails.\n */\nexport class AssertionError extends Error {\n    constructor(options) {\n        super(options.message);\n        this.code = 'ERR_ASSERTION';\n    }\n}\n/**\n * Same as Node.js assert.\n * If the value is falsy, throws an error, does nothing otherwise.\n *\n * @throws {@link AssertionError} If value is falsy.\n * @param value - The test that should be truthy to pass.\n * @param message - Message to be passed to {@link AssertionError} or an\n * {@link Error} instance to throw.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}. If a custom error class is provided for\n * the `message` argument, this argument is ignored.\n */\nexport function assert(value, message = 'Assertion failed.', \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper = AssertionError) {\n    if (!value) {\n        if (message instanceof Error) {\n            throw message;\n        }\n        throw getError(ErrorWrapper, message);\n    }\n}\n/**\n * Assert a value against a Superstruct struct.\n *\n * @param value - The value to validate.\n * @param struct - The struct to validate against.\n * @param errorPrefix - A prefix to add to the error message. Defaults to\n * \"Assertion failed\".\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the value is not valid.\n */\nexport function assertStruct(value, struct, errorPrefix = 'Assertion failed', \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper = AssertionError) {\n    try {\n        assertSuperstruct(value, struct);\n    }\n    catch (error) {\n        throw getError(ErrorWrapper, `${errorPrefix}: ${getErrorMessageWithoutTrailingPeriod(error)}.`);\n    }\n}\n/**\n * Use in the default case of a switch that you want to be fully exhaustive.\n * Using this function forces the compiler to enforce exhaustivity during\n * compile-time.\n *\n * @example\n * ```\n * const number = 1;\n * switch (number) {\n *   case 0:\n *     ...\n *   case 1:\n *     ...\n *   default:\n *     assertExhaustive(snapPrefix);\n * }\n * ```\n * @param _object - The object on which the switch is being operated.\n */\nexport function assertExhaustive(_object) {\n    throw new Error('Invalid branch reached. Should be detected during compilation.');\n}\n//# sourceMappingURL=assert.mjs.map","import { ErrorWithCause } from \"pony-cause\";\nimport { isNullOrUndefined, isObject } from \"./misc.mjs\";\n/**\n * Type guard for determining whether the given value is an instance of Error.\n * For errors generated via `fs.promises`, `error instanceof Error` won't work,\n * so we have to come up with another way of testing.\n *\n * @param error - The object to check.\n * @returns A boolean.\n */\nfunction isError(error) {\n    return (error instanceof Error ||\n        (isObject(error) && error.constructor.name === 'Error'));\n}\n/**\n * Type guard for determining whether the given value is an error object with a\n * `code` property such as the type of error that Node throws for filesystem\n * operations, etc.\n *\n * @param error - The object to check.\n * @returns A boolean.\n */\nexport function isErrorWithCode(error) {\n    return typeof error === 'object' && error !== null && 'code' in error;\n}\n/**\n * Type guard for determining whether the given value is an error object with a\n * `message` property, such as an instance of Error.\n *\n * @param error - The object to check.\n * @returns A boolean.\n */\nexport function isErrorWithMessage(error) {\n    return typeof error === 'object' && error !== null && 'message' in error;\n}\n/**\n * Type guard for determining whether the given value is an error object with a\n * `stack` property, such as an instance of Error.\n *\n * @param error - The object to check.\n * @returns A boolean.\n */\nexport function isErrorWithStack(error) {\n    return typeof error === 'object' && error !== null && 'stack' in error;\n}\n/**\n * Attempts to obtain the message from a possible error object, defaulting to an\n * empty string if it is impossible to do so.\n *\n * @param error - The possible error to get the message from.\n * @returns The message if `error` is an object with a `message` property;\n * the string version of `error` if it is not `undefined` or `null`; otherwise\n * an empty string.\n */\nexport function getErrorMessage(error) {\n    if (isErrorWithMessage(error) && typeof error.message === 'string') {\n        return error.message;\n    }\n    if (isNullOrUndefined(error)) {\n        return '';\n    }\n    return String(error);\n}\n/**\n * Builds a new error object, linking it to the original error via the `cause`\n * property if it is an Error.\n *\n * This function is useful to reframe error messages in general, but is\n * _critical_ when interacting with any of Node's filesystem functions as\n * provided via `fs.promises`, because these do not produce stack traces in the\n * case of an I/O error (see <https://github.com/nodejs/node/issues/30944>).\n *\n * @param originalError - The error to be wrapped (something throwable).\n * @param message - The desired message of the new error.\n * @returns A new error object.\n */\nexport function wrapError(originalError, message) {\n    if (isError(originalError)) {\n        let error;\n        if (Error.length === 2) {\n            // for some reason `tsserver` is not complaining that the\n            // Error constructor doesn't support a second argument in the editor,\n            // but `tsc` does. Error causes are not supported by our current tsc target (ES2020, we need ES2022 to make this work)\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            error = new Error(message, { cause: originalError });\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            error = new ErrorWithCause(message, { cause: originalError });\n        }\n        if (isErrorWithCode(originalError)) {\n            error.code = originalError.code;\n        }\n        return error;\n    }\n    if (message.length > 0) {\n        return new Error(`${String(originalError)}: ${message}`);\n    }\n    return new Error(String(originalError));\n}\n//# sourceMappingURL=errors.mjs.map","import { is, pattern, string } from \"@metamask/superstruct\";\nimport { keccak_256 as keccak256 } from \"@noble/hashes/sha3\";\nimport { assert } from \"./assert.mjs\";\nimport { bytesToHex } from \"./bytes.mjs\";\nexport const HexStruct = pattern(string(), /^(?:0x)?[0-9a-f]+$/iu);\nexport const StrictHexStruct = pattern(string(), /^0x[0-9a-f]+$/iu);\nexport const HexAddressStruct = pattern(string(), /^0x[0-9a-f]{40}$/u);\nexport const HexChecksumAddressStruct = pattern(string(), /^0x[0-9a-fA-F]{40}$/u);\n/**\n * Check if a string is a valid hex string.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid hex string.\n */\nexport function isHexString(value) {\n    return is(value, HexStruct);\n}\n/**\n * Strictly check if a string is a valid hex string. A valid hex string must\n * start with the \"0x\"-prefix.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid hex string.\n */\nexport function isStrictHexString(value) {\n    return is(value, StrictHexStruct);\n}\n/**\n * Assert that a value is a valid hex string.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid hex string.\n */\nexport function assertIsHexString(value) {\n    assert(isHexString(value), 'Value must be a hexadecimal string.');\n}\n/**\n * Assert that a value is a valid hex string. A valid hex string must start with\n * the \"0x\"-prefix.\n *\n * @param value - The value to check.\n * @throws If the value is not a valid hex string.\n */\nexport function assertIsStrictHexString(value) {\n    assert(isStrictHexString(value), 'Value must be a hexadecimal string, starting with \"0x\".');\n}\n/**\n * Validate that the passed prefixed hex string is an all-lowercase\n * hex address, or a valid mixed-case checksum address.\n *\n * @param possibleAddress - Input parameter to check against.\n * @returns Whether or not the input is a valid hex address.\n */\nexport function isValidHexAddress(possibleAddress) {\n    return (is(possibleAddress, HexAddressStruct) ||\n        isValidChecksumAddress(possibleAddress));\n}\n/**\n * Encode a passed hex string as an ERC-55 mixed-case checksum address.\n *\n * @param address - The hex address to encode.\n * @returns The address encoded according to ERC-55.\n * @see https://eips.ethereum.org/EIPS/eip-55\n */\nexport function getChecksumAddress(address) {\n    assert(is(address, HexChecksumAddressStruct), 'Invalid hex address.');\n    const unPrefixed = remove0x(address.toLowerCase());\n    const unPrefixedHash = remove0x(bytesToHex(keccak256(unPrefixed)));\n    return `0x${unPrefixed\n        .split('')\n        .map((character, nibbleIndex) => {\n        const hashCharacter = unPrefixedHash[nibbleIndex];\n        assert(is(hashCharacter, string()), 'Hash shorter than address.');\n        return parseInt(hashCharacter, 16) > 7\n            ? character.toUpperCase()\n            : character;\n    })\n        .join('')}`;\n}\n/**\n * Validate that the passed hex string is a valid ERC-55 mixed-case\n * checksum address.\n *\n * @param possibleChecksum - The hex address to check.\n * @returns True if the address is a checksum address.\n */\nexport function isValidChecksumAddress(possibleChecksum) {\n    if (!is(possibleChecksum, HexChecksumAddressStruct)) {\n        return false;\n    }\n    return getChecksumAddress(possibleChecksum) === possibleChecksum;\n}\n/**\n * Add the `0x`-prefix to a hexadecimal string. If the string already has the\n * prefix, it is returned as-is.\n *\n * @param hexadecimal - The hexadecimal string to add the prefix to.\n * @returns The prefixed hexadecimal string.\n */\nexport function add0x(hexadecimal) {\n    if (hexadecimal.startsWith('0x')) {\n        return hexadecimal;\n    }\n    if (hexadecimal.startsWith('0X')) {\n        return `0x${hexadecimal.substring(2)}`;\n    }\n    return `0x${hexadecimal}`;\n}\n/**\n * Remove the `0x`-prefix from a hexadecimal string. If the string doesn't have\n * the prefix, it is returned as-is.\n *\n * @param hexadecimal - The hexadecimal string to remove the prefix from.\n * @returns The un-prefixed hexadecimal string.\n */\nexport function remove0x(hexadecimal) {\n    if (hexadecimal.startsWith('0x') || hexadecimal.startsWith('0X')) {\n        return hexadecimal.substring(2);\n    }\n    return hexadecimal;\n}\n//# sourceMappingURL=hex.mjs.map","import { any, array, boolean, coerce, create, define, integer, is, lazy, literal, nullable, number, object as superstructObject, optional, record, string, union, unknown, Struct } from \"@metamask/superstruct\";\nimport { assertStruct } from \"./assert.mjs\";\nimport { hasProperty } from \"./misc.mjs\";\n/**\n * A struct to check if the given value is a valid object, with support for\n * {@link exactOptional} types.\n *\n * @param schema - The schema of the object.\n * @returns A struct to check if the given value is an object.\n */\nexport const object = (schema) => \n// The type is slightly different from a regular object struct, because we\n// want to make properties with `undefined` in their type optional, but not\n// `undefined` itself. This means that we need a type cast.\nsuperstructObject(schema);\n/**\n * Check the last field of a path is present.\n *\n * @param context - The context to check.\n * @param context.path - The path to check.\n * @param context.branch - The branch to check.\n * @returns Whether the last field of a path is present.\n */\nfunction hasOptional({ path, branch }) {\n    const field = path[path.length - 1];\n    return hasProperty(branch[branch.length - 2], field);\n}\n/**\n * A struct which allows the property of an object to be absent, or to be present\n * as long as it's valid and not set to `undefined`.\n *\n * This struct should be used in conjunction with the {@link object} from this\n * library, to get proper type inference.\n *\n * @param struct - The struct to check the value against, if present.\n * @returns A struct to check if the given value is valid, or not present.\n * @example\n * ```ts\n * const struct = object({\n *   foo: exactOptional(string()),\n *   bar: exactOptional(number()),\n *   baz: optional(boolean()),\n *   qux: unknown(),\n * });\n *\n * type Type = Infer<typeof struct>;\n * // Type is equivalent to:\n * // {\n * //   foo?: string;\n * //   bar?: number;\n * //   baz?: boolean | undefined;\n * //   qux: unknown;\n * // }\n * ```\n */\nexport function exactOptional(struct) {\n    return new Struct({\n        ...struct,\n        type: `optional ${struct.type}`,\n        validator: (value, context) => !hasOptional(context) || struct.validator(value, context),\n        refiner: (value, context) => !hasOptional(context) || struct.refiner(value, context),\n    });\n}\n/**\n * A struct to check if the given value is finite number. Superstruct's\n * `number()` struct does not check if the value is finite.\n *\n * @returns A struct to check if the given value is finite number.\n */\nconst finiteNumber = () => define('finite number', (value) => {\n    return is(value, number()) && Number.isFinite(value);\n});\n/**\n * A struct to check if the given value is a valid JSON-serializable value.\n *\n * Note that this struct is unsafe. For safe validation, use {@link JsonStruct}.\n */\n// We cannot infer the type of the struct, because it is recursive.\nexport const UnsafeJsonStruct = union([\n    literal(null),\n    boolean(),\n    finiteNumber(),\n    string(),\n    array(lazy(() => UnsafeJsonStruct)),\n    record(string(), lazy(() => UnsafeJsonStruct)),\n]);\n/**\n * A struct to check if the given value is a valid JSON-serializable value.\n *\n * This struct sanitizes the value before validating it, so that it is safe to\n * use with untrusted input.\n */\nexport const JsonStruct = coerce(UnsafeJsonStruct, any(), (value) => {\n    assertStruct(value, UnsafeJsonStruct);\n    return JSON.parse(JSON.stringify(value, (propKey, propValue) => {\n        // Strip __proto__ and constructor properties to prevent prototype pollution.\n        if (propKey === '__proto__' || propKey === 'constructor') {\n            return undefined;\n        }\n        return propValue;\n    }));\n});\n/**\n * Check if the given value is a valid {@link Json} value, i.e., a value that is\n * serializable to JSON.\n *\n * @param value - The value to check.\n * @returns Whether the value is a valid {@link Json} value.\n */\nexport function isValidJson(value) {\n    try {\n        getSafeJson(value);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Validate and return sanitized JSON.\n *\n * Note:\n * This function uses sanitized JsonStruct for validation\n * that applies stringify and then parse of a value provided\n * to ensure that there are no getters which can have side effects\n * that can cause security issues.\n *\n * @param value - JSON structure to be processed.\n * @returns Sanitized JSON structure.\n */\nexport function getSafeJson(value) {\n    return create(value, JsonStruct);\n}\n/**\n * Get the size of a JSON value in bytes. This also validates the value.\n *\n * @param value - The JSON value to get the size of.\n * @returns The size of the JSON value in bytes.\n */\nexport function getJsonSize(value) {\n    assertStruct(value, JsonStruct, 'Invalid JSON value');\n    const json = JSON.stringify(value);\n    return new TextEncoder().encode(json).byteLength;\n}\n/**\n * The string '2.0'.\n */\nexport const jsonrpc2 = '2.0';\nexport const JsonRpcVersionStruct = literal(jsonrpc2);\nexport const JsonRpcIdStruct = nullable(union([number(), string()]));\nexport const JsonRpcErrorStruct = object({\n    code: integer(),\n    message: string(),\n    data: exactOptional(JsonStruct),\n    stack: exactOptional(string()),\n});\nexport const JsonRpcParamsStruct = union([record(string(), JsonStruct), array(JsonStruct)]);\nexport const JsonRpcRequestStruct = object({\n    id: JsonRpcIdStruct,\n    jsonrpc: JsonRpcVersionStruct,\n    method: string(),\n    params: exactOptional(JsonRpcParamsStruct),\n});\nexport const JsonRpcNotificationStruct = object({\n    jsonrpc: JsonRpcVersionStruct,\n    method: string(),\n    params: exactOptional(JsonRpcParamsStruct),\n});\n/**\n * Check if the given value is a valid {@link JsonRpcNotification} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcNotification}\n * object.\n */\nexport function isJsonRpcNotification(value) {\n    return is(value, JsonRpcNotificationStruct);\n}\n/**\n * Assert that the given value is a valid {@link JsonRpcNotification} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcNotification} object.\n */\nexport function assertIsJsonRpcNotification(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    assertStruct(value, JsonRpcNotificationStruct, 'Invalid JSON-RPC notification', ErrorWrapper);\n}\n/**\n * Check if the given value is a valid {@link JsonRpcRequest} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcRequest} object.\n */\nexport function isJsonRpcRequest(value) {\n    return is(value, JsonRpcRequestStruct);\n}\n/**\n * Assert that the given value is a valid {@link JsonRpcRequest} object.\n *\n * @param value - The JSON-RPC request or notification to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcRequest} object.\n */\nexport function assertIsJsonRpcRequest(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    assertStruct(value, JsonRpcRequestStruct, 'Invalid JSON-RPC request', ErrorWrapper);\n}\nexport const PendingJsonRpcResponseStruct = superstructObject({\n    id: JsonRpcIdStruct,\n    jsonrpc: JsonRpcVersionStruct,\n    result: optional(unknown()),\n    error: optional(JsonRpcErrorStruct),\n});\nexport const JsonRpcSuccessStruct = object({\n    id: JsonRpcIdStruct,\n    jsonrpc: JsonRpcVersionStruct,\n    result: JsonStruct,\n});\nexport const JsonRpcFailureStruct = object({\n    id: JsonRpcIdStruct,\n    jsonrpc: JsonRpcVersionStruct,\n    error: JsonRpcErrorStruct,\n});\nexport const JsonRpcResponseStruct = union([\n    JsonRpcSuccessStruct,\n    JsonRpcFailureStruct,\n]);\n/**\n * Type guard to check whether specified JSON-RPC response is a\n * {@link PendingJsonRpcResponse}.\n *\n * @param response - The JSON-RPC response to check.\n * @returns Whether the specified JSON-RPC response is pending.\n */\nexport function isPendingJsonRpcResponse(response) {\n    return is(response, PendingJsonRpcResponseStruct);\n}\n/**\n * Assert that the given value is a valid {@link PendingJsonRpcResponse} object.\n *\n * @param response - The JSON-RPC response to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link PendingJsonRpcResponse}\n * object.\n */\nexport function assertIsPendingJsonRpcResponse(response, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    assertStruct(response, PendingJsonRpcResponseStruct, 'Invalid pending JSON-RPC response', ErrorWrapper);\n}\n/**\n * Type guard to check if a value is a {@link JsonRpcResponse}.\n *\n * @param response - The object to check.\n * @returns Whether the object is a JsonRpcResponse.\n */\nexport function isJsonRpcResponse(response) {\n    return is(response, JsonRpcResponseStruct);\n}\n/**\n * Assert that the given value is a valid {@link JsonRpcResponse} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcResponse} object.\n */\nexport function assertIsJsonRpcResponse(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    assertStruct(value, JsonRpcResponseStruct, 'Invalid JSON-RPC response', ErrorWrapper);\n}\n/**\n * Check if the given value is a valid {@link JsonRpcSuccess} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcSuccess} object.\n */\nexport function isJsonRpcSuccess(value) {\n    return is(value, JsonRpcSuccessStruct);\n}\n/**\n * Assert that the given value is a valid {@link JsonRpcSuccess} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcSuccess} object.\n */\nexport function assertIsJsonRpcSuccess(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    assertStruct(value, JsonRpcSuccessStruct, 'Invalid JSON-RPC success response', ErrorWrapper);\n}\n/**\n * Check if the given value is a valid {@link JsonRpcFailure} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcFailure} object.\n */\nexport function isJsonRpcFailure(value) {\n    return is(value, JsonRpcFailureStruct);\n}\n/**\n * Assert that the given value is a valid {@link JsonRpcFailure} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcFailure} object.\n */\nexport function assertIsJsonRpcFailure(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    assertStruct(value, JsonRpcFailureStruct, 'Invalid JSON-RPC failure response', ErrorWrapper);\n}\n/**\n * Check if the given value is a valid {@link JsonRpcError} object.\n *\n * @param value - The value to check.\n * @returns Whether the given value is a valid {@link JsonRpcError} object.\n */\nexport function isJsonRpcError(value) {\n    return is(value, JsonRpcErrorStruct);\n}\n/**\n * Assert that the given value is a valid {@link JsonRpcError} object.\n *\n * @param value - The value to check.\n * @param ErrorWrapper - The error class to throw if the assertion fails.\n * Defaults to {@link AssertionError}.\n * @throws If the given value is not a valid {@link JsonRpcError} object.\n */\nexport function assertIsJsonRpcError(value, \n// eslint-disable-next-line @typescript-eslint/naming-convention\nErrorWrapper) {\n    assertStruct(value, JsonRpcErrorStruct, 'Invalid JSON-RPC error', ErrorWrapper);\n}\n/**\n * Gets a function for validating JSON-RPC request / response `id` values.\n *\n * By manipulating the options of this factory, you can control the behavior\n * of the resulting validator for some edge cases. This is useful because e.g.\n * `null` should sometimes but not always be permitted.\n *\n * Note that the empty string (`''`) is always permitted by the JSON-RPC\n * specification, but that kind of sucks and you may want to forbid it in some\n * instances anyway.\n *\n * For more details, see the\n * [JSON-RPC Specification](https://www.jsonrpc.org/specification).\n *\n * @param options - An options object.\n * @param options.permitEmptyString - Whether the empty string (i.e. `''`)\n * should be treated as a valid ID. Default: `true`\n * @param options.permitFractions - Whether fractional numbers (e.g. `1.2`)\n * should be treated as valid IDs. Default: `false`\n * @param options.permitNull - Whether `null` should be treated as a valid ID.\n * Default: `true`\n * @returns The JSON-RPC ID validator function.\n */\nexport function getJsonRpcIdValidator(options) {\n    const { permitEmptyString, permitFractions, permitNull } = {\n        permitEmptyString: true,\n        permitFractions: false,\n        permitNull: true,\n        ...options,\n    };\n    /**\n     * Type guard for {@link JsonRpcId}.\n     *\n     * @param id - The JSON-RPC ID value to check.\n     * @returns Whether the given ID is valid per the options given to the\n     * factory.\n     */\n    const isValidJsonRpcId = (id) => {\n        return Boolean((typeof id === 'number' && (permitFractions || Number.isInteger(id))) ||\n            (typeof id === 'string' && (permitEmptyString || id.length > 0)) ||\n            (permitNull && id === null));\n    };\n    return isValidJsonRpcId;\n}\n//# sourceMappingURL=json.mjs.map","import { Struct, is } from \"../struct.mjs\";\nimport { isPlainObject } from \"../utils.mjs\";\nimport { string, unknown } from \"./types.mjs\";\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validation—for example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n *\n * @param struct - The struct to augment.\n * @param condition - A struct that the input must pass to be coerced.\n * @param coercer - A function that takes the input and returns the coerced\n * value.\n * @returns A new struct that will coerce its input before validating it.\n */\nexport function coerce(struct, condition, coercer) {\n    return new Struct({\n        ...struct,\n        coercer: (value, ctx) => {\n            return is(value, condition)\n                ? struct.coercer(coercer(value, ctx), ctx)\n                : struct.coercer(value, ctx);\n        },\n    });\n}\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n *\n * @param struct - The struct to augment.\n * @param fallback - The value to use when the input is `undefined`.\n * @param options - An optional options object.\n * @param options.strict - When `true`, the fallback will only be used when the\n * input is `undefined`. When `false`, the fallback will be used when the input\n * is `undefined` or when the input is a plain object and the fallback is a\n * plain object, and any keys in the fallback are missing from the input.\n * @returns A new struct that will replace `undefined` inputs with a default.\n */\nexport function defaulted(struct, fallback, options = {}) {\n    return coerce(struct, unknown(), (value) => {\n        const result = typeof fallback === 'function' ? fallback() : fallback;\n        if (value === undefined) {\n            return result;\n        }\n        if (!options.strict && isPlainObject(value) && isPlainObject(result)) {\n            const ret = { ...value };\n            let changed = false;\n            for (const key in result) {\n                if (ret[key] === undefined) {\n                    ret[key] = result[key];\n                    changed = true;\n                }\n            }\n            if (changed) {\n                return ret;\n            }\n        }\n        return value;\n    });\n}\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n *\n * @param struct - The struct to augment.\n * @returns A new struct that will trim string inputs before validating them.\n */\nexport function trimmed(struct) {\n    return coerce(struct, string(), (value) => value.trim());\n}\n//# sourceMappingURL=coercions.mjs.map","// src/error-constants.ts\nvar errorCodes = {\n  rpc: {\n    invalidInput: -32e3,\n    resourceNotFound: -32001,\n    resourceUnavailable: -32002,\n    transactionRejected: -32003,\n    methodNotSupported: -32004,\n    limitExceeded: -32005,\n    parse: -32700,\n    invalidRequest: -32600,\n    methodNotFound: -32601,\n    invalidParams: -32602,\n    internal: -32603\n  },\n  provider: {\n    userRejectedRequest: 4001,\n    unauthorized: 4100,\n    unsupportedMethod: 4200,\n    disconnected: 4900,\n    chainDisconnected: 4901\n  }\n};\nvar errorValues = {\n  \"-32700\": {\n    standard: \"JSON RPC 2.0\",\n    message: \"Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.\"\n  },\n  \"-32600\": {\n    standard: \"JSON RPC 2.0\",\n    message: \"The JSON sent is not a valid Request object.\"\n  },\n  \"-32601\": {\n    standard: \"JSON RPC 2.0\",\n    message: \"The method does not exist / is not available.\"\n  },\n  \"-32602\": {\n    standard: \"JSON RPC 2.0\",\n    message: \"Invalid method parameter(s).\"\n  },\n  \"-32603\": {\n    standard: \"JSON RPC 2.0\",\n    message: \"Internal JSON-RPC error.\"\n  },\n  \"-32000\": {\n    standard: \"EIP-1474\",\n    message: \"Invalid input.\"\n  },\n  \"-32001\": {\n    standard: \"EIP-1474\",\n    message: \"Resource not found.\"\n  },\n  \"-32002\": {\n    standard: \"EIP-1474\",\n    message: \"Resource unavailable.\"\n  },\n  \"-32003\": {\n    standard: \"EIP-1474\",\n    message: \"Transaction rejected.\"\n  },\n  \"-32004\": {\n    standard: \"EIP-1474\",\n    message: \"Method not supported.\"\n  },\n  \"-32005\": {\n    standard: \"EIP-1474\",\n    message: \"Request limit exceeded.\"\n  },\n  \"4001\": {\n    standard: \"EIP-1193\",\n    message: \"User rejected the request.\"\n  },\n  \"4100\": {\n    standard: \"EIP-1193\",\n    message: \"The requested account and/or method has not been authorized by the user.\"\n  },\n  \"4200\": {\n    standard: \"EIP-1193\",\n    message: \"The requested method is not supported by this Ethereum provider.\"\n  },\n  \"4900\": {\n    standard: \"EIP-1193\",\n    message: \"The provider is disconnected from all chains.\"\n  },\n  \"4901\": {\n    standard: \"EIP-1193\",\n    message: \"The provider is disconnected from the specified chain.\"\n  }\n};\n\nexport {\n  errorCodes,\n  errorValues\n};\n//# sourceMappingURL=chunk-MIW4NMY6.mjs.map","import {\n  errorCodes,\n  errorValues\n} from \"./chunk-MIW4NMY6.mjs\";\n\n// src/utils.ts\nimport {\n  hasProperty,\n  isValidJson,\n  isObject,\n  isJsonRpcError\n} from \"@metamask/utils\";\nvar FALLBACK_ERROR_CODE = errorCodes.rpc.internal;\nvar FALLBACK_MESSAGE = \"Unspecified error message. This is a bug, please report it.\";\nvar FALLBACK_ERROR = {\n  code: FALLBACK_ERROR_CODE,\n  message: getMessageFromCode(FALLBACK_ERROR_CODE)\n};\nvar JSON_RPC_SERVER_ERROR_MESSAGE = \"Unspecified server error.\";\nfunction getMessageFromCode(code, fallbackMessage = FALLBACK_MESSAGE) {\n  if (isValidCode(code)) {\n    const codeString = code.toString();\n    if (hasProperty(errorValues, codeString)) {\n      return errorValues[codeString].message;\n    }\n    if (isJsonRpcServerError(code)) {\n      return JSON_RPC_SERVER_ERROR_MESSAGE;\n    }\n  }\n  return fallbackMessage;\n}\nfunction isValidCode(code) {\n  return Number.isInteger(code);\n}\nfunction serializeError(error, { fallbackError = FALLBACK_ERROR, shouldIncludeStack = true } = {}) {\n  if (!isJsonRpcError(fallbackError)) {\n    throw new Error(\n      \"Must provide fallback error with integer number code and string message.\"\n    );\n  }\n  const serialized = buildError(error, fallbackError);\n  if (!shouldIncludeStack) {\n    delete serialized.stack;\n  }\n  return serialized;\n}\nfunction buildError(error, fallbackError) {\n  if (error && typeof error === \"object\" && \"serialize\" in error && typeof error.serialize === \"function\") {\n    return error.serialize();\n  }\n  if (isJsonRpcError(error)) {\n    return error;\n  }\n  const cause = serializeCause(error);\n  const fallbackWithCause = {\n    ...fallbackError,\n    data: { cause }\n  };\n  return fallbackWithCause;\n}\nfunction isJsonRpcServerError(code) {\n  return code >= -32099 && code <= -32e3;\n}\nfunction serializeCause(error) {\n  if (Array.isArray(error)) {\n    return error.map((entry) => {\n      if (isValidJson(entry)) {\n        return entry;\n      } else if (isObject(entry)) {\n        return serializeObject(entry);\n      }\n      return null;\n    });\n  } else if (isObject(error)) {\n    return serializeObject(error);\n  }\n  if (isValidJson(error)) {\n    return error;\n  }\n  return null;\n}\nfunction serializeObject(object) {\n  return Object.getOwnPropertyNames(object).reduce(\n    (acc, key) => {\n      const value = object[key];\n      if (isValidJson(value)) {\n        acc[key] = value;\n      }\n      return acc;\n    },\n    {}\n  );\n}\nfunction dataHasCause(data) {\n  return isObject(data) && hasProperty(data, \"cause\") && isObject(data.cause);\n}\n\nexport {\n  JSON_RPC_SERVER_ERROR_MESSAGE,\n  getMessageFromCode,\n  isValidCode,\n  serializeError,\n  serializeCause,\n  dataHasCause\n};\n//# sourceMappingURL=chunk-HHE56EX3.mjs.map","module.exports = stringify\nstringify.default = stringify\nstringify.stable = deterministicStringify\nstringify.stableStringify = deterministicStringify\n\nvar LIMIT_REPLACE_NODE = '[...]'\nvar CIRCULAR_REPLACE_NODE = '[Circular]'\n\nvar arr = []\nvar replacerStack = []\n\nfunction defaultOptions () {\n  return {\n    depthLimit: Number.MAX_SAFE_INTEGER,\n    edgesLimit: Number.MAX_SAFE_INTEGER\n  }\n}\n\n// Regular stringify\nfunction stringify (obj, replacer, spacer, options) {\n  if (typeof options === 'undefined') {\n    options = defaultOptions()\n  }\n\n  decirc(obj, '', 0, [], undefined, 0, options)\n  var res\n  try {\n    if (replacerStack.length === 0) {\n      res = JSON.stringify(obj, replacer, spacer)\n    } else {\n      res = JSON.stringify(obj, replaceGetterValues(replacer), spacer)\n    }\n  } catch (_) {\n    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]')\n  } finally {\n    while (arr.length !== 0) {\n      var part = arr.pop()\n      if (part.length === 4) {\n        Object.defineProperty(part[0], part[1], part[3])\n      } else {\n        part[0][part[1]] = part[2]\n      }\n    }\n  }\n  return res\n}\n\nfunction setReplace (replace, val, k, parent) {\n  var propertyDescriptor = Object.getOwnPropertyDescriptor(parent, k)\n  if (propertyDescriptor.get !== undefined) {\n    if (propertyDescriptor.configurable) {\n      Object.defineProperty(parent, k, { value: replace })\n      arr.push([parent, k, val, propertyDescriptor])\n    } else {\n      replacerStack.push([val, k, replace])\n    }\n  } else {\n    parent[k] = replace\n    arr.push([parent, k, val])\n  }\n}\n\nfunction decirc (val, k, edgeIndex, stack, parent, depth, options) {\n  depth += 1\n  var i\n  if (typeof val === 'object' && val !== null) {\n    for (i = 0; i < stack.length; i++) {\n      if (stack[i] === val) {\n        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent)\n        return\n      }\n    }\n\n    if (\n      typeof options.depthLimit !== 'undefined' &&\n      depth > options.depthLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent)\n      return\n    }\n\n    if (\n      typeof options.edgesLimit !== 'undefined' &&\n      edgeIndex + 1 > options.edgesLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent)\n      return\n    }\n\n    stack.push(val)\n    // Optimize for Arrays. Big arrays could kill the performance otherwise!\n    if (Array.isArray(val)) {\n      for (i = 0; i < val.length; i++) {\n        decirc(val[i], i, i, stack, val, depth, options)\n      }\n    } else {\n      var keys = Object.keys(val)\n      for (i = 0; i < keys.length; i++) {\n        var key = keys[i]\n        decirc(val[key], key, i, stack, val, depth, options)\n      }\n    }\n    stack.pop()\n  }\n}\n\n// Stable-stringify\nfunction compareFunction (a, b) {\n  if (a < b) {\n    return -1\n  }\n  if (a > b) {\n    return 1\n  }\n  return 0\n}\n\nfunction deterministicStringify (obj, replacer, spacer, options) {\n  if (typeof options === 'undefined') {\n    options = defaultOptions()\n  }\n\n  var tmp = deterministicDecirc(obj, '', 0, [], undefined, 0, options) || obj\n  var res\n  try {\n    if (replacerStack.length === 0) {\n      res = JSON.stringify(tmp, replacer, spacer)\n    } else {\n      res = JSON.stringify(tmp, replaceGetterValues(replacer), spacer)\n    }\n  } catch (_) {\n    return JSON.stringify('[unable to serialize, circular reference is too complex to analyze]')\n  } finally {\n    // Ensure that we restore the object as it was.\n    while (arr.length !== 0) {\n      var part = arr.pop()\n      if (part.length === 4) {\n        Object.defineProperty(part[0], part[1], part[3])\n      } else {\n        part[0][part[1]] = part[2]\n      }\n    }\n  }\n  return res\n}\n\nfunction deterministicDecirc (val, k, edgeIndex, stack, parent, depth, options) {\n  depth += 1\n  var i\n  if (typeof val === 'object' && val !== null) {\n    for (i = 0; i < stack.length; i++) {\n      if (stack[i] === val) {\n        setReplace(CIRCULAR_REPLACE_NODE, val, k, parent)\n        return\n      }\n    }\n    try {\n      if (typeof val.toJSON === 'function') {\n        return\n      }\n    } catch (_) {\n      return\n    }\n\n    if (\n      typeof options.depthLimit !== 'undefined' &&\n      depth > options.depthLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent)\n      return\n    }\n\n    if (\n      typeof options.edgesLimit !== 'undefined' &&\n      edgeIndex + 1 > options.edgesLimit\n    ) {\n      setReplace(LIMIT_REPLACE_NODE, val, k, parent)\n      return\n    }\n\n    stack.push(val)\n    // Optimize for Arrays. Big arrays could kill the performance otherwise!\n    if (Array.isArray(val)) {\n      for (i = 0; i < val.length; i++) {\n        deterministicDecirc(val[i], i, i, stack, val, depth, options)\n      }\n    } else {\n      // Create a temporary object in the required way\n      var tmp = {}\n      var keys = Object.keys(val).sort(compareFunction)\n      for (i = 0; i < keys.length; i++) {\n        var key = keys[i]\n        deterministicDecirc(val[key], key, i, stack, val, depth, options)\n        tmp[key] = val[key]\n      }\n      if (typeof parent !== 'undefined') {\n        arr.push([parent, k, val])\n        parent[k] = tmp\n      } else {\n        return tmp\n      }\n    }\n    stack.pop()\n  }\n}\n\n// wraps replacer function to handle values we couldn't replace\n// and mark them as replaced value\nfunction replaceGetterValues (replacer) {\n  replacer =\n    typeof replacer !== 'undefined'\n      ? replacer\n      : function (k, v) {\n        return v\n      }\n  return function (key, val) {\n    if (replacerStack.length > 0) {\n      for (var i = 0; i < replacerStack.length; i++) {\n        var part = replacerStack[i]\n        if (part[1] === key && part[0] === val) {\n          val = part[2]\n          replacerStack.splice(i, 1)\n          break\n        }\n      }\n    }\n    return replacer.call(this, key, val)\n  }\n}\n","import {\n  dataHasCause,\n  serializeCause\n} from \"./chunk-HHE56EX3.mjs\";\n\n// src/classes.ts\nimport { hasProperty, isPlainObject } from \"@metamask/utils\";\nimport safeStringify from \"fast-safe-stringify\";\nvar JsonRpcError = class extends Error {\n  constructor(code, message, data) {\n    var __super = (...args) => {\n      super(...args);\n    };\n    if (!Number.isInteger(code)) {\n      throw new Error('\"code\" must be an integer.');\n    }\n    if (!message || typeof message !== \"string\") {\n      throw new Error('\"message\" must be a non-empty string.');\n    }\n    if (dataHasCause(data)) {\n      __super(message, { cause: data.cause });\n      if (!hasProperty(this, \"cause\")) {\n        Object.assign(this, { cause: data.cause });\n      }\n    } else {\n      __super(message);\n    }\n    if (data !== void 0) {\n      this.data = data;\n    }\n    this.code = code;\n  }\n  /**\n   * Get the error as JSON-serializable object.\n   *\n   * @returns A plain object with all public class properties.\n   */\n  serialize() {\n    const serialized = {\n      code: this.code,\n      message: this.message\n    };\n    if (this.data !== void 0) {\n      serialized.data = this.data;\n      if (isPlainObject(this.data)) {\n        serialized.data.cause = serializeCause(this.data.cause);\n      }\n    }\n    if (this.stack) {\n      serialized.stack = this.stack;\n    }\n    return serialized;\n  }\n  /**\n   * Get a string representation of the serialized error, omitting any circular\n   * references.\n   *\n   * @returns A string representation of the serialized error.\n   */\n  toString() {\n    return safeStringify(this.serialize(), stringifyReplacer, 2);\n  }\n};\nvar EthereumProviderError = class extends JsonRpcError {\n  /**\n   * Create an Ethereum Provider JSON-RPC error.\n   *\n   * @param code - The JSON-RPC error code. Must be an integer in the\n   * `1000 <= n <= 4999` range.\n   * @param message - The JSON-RPC error message.\n   * @param data - Optional data to include in the error.\n   */\n  constructor(code, message, data) {\n    if (!isValidEthProviderCode(code)) {\n      throw new Error(\n        '\"code\" must be an integer such that: 1000 <= code <= 4999'\n      );\n    }\n    super(code, message, data);\n  }\n};\nfunction isValidEthProviderCode(code) {\n  return Number.isInteger(code) && code >= 1e3 && code <= 4999;\n}\nfunction stringifyReplacer(_, value) {\n  if (value === \"[Circular]\") {\n    return void 0;\n  }\n  return value;\n}\n\nexport {\n  JsonRpcError,\n  EthereumProviderError\n};\n//# sourceMappingURL=chunk-ROLUROML.mjs.map","import {\n  EthereumProviderError,\n  JsonRpcError\n} from \"./chunk-ROLUROML.mjs\";\nimport {\n  getMessageFromCode\n} from \"./chunk-HHE56EX3.mjs\";\nimport {\n  errorCodes\n} from \"./chunk-MIW4NMY6.mjs\";\n\n// src/errors.ts\nvar rpcErrors = {\n  /**\n   * Get a JSON RPC 2.0 Parse (-32700) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  parse: (arg) => getJsonRpcError(errorCodes.rpc.parse, arg),\n  /**\n   * Get a JSON RPC 2.0 Invalid Request (-32600) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  invalidRequest: (arg) => getJsonRpcError(errorCodes.rpc.invalidRequest, arg),\n  /**\n   * Get a JSON RPC 2.0 Invalid Params (-32602) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  invalidParams: (arg) => getJsonRpcError(errorCodes.rpc.invalidParams, arg),\n  /**\n   * Get a JSON RPC 2.0 Method Not Found (-32601) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  methodNotFound: (arg) => getJsonRpcError(errorCodes.rpc.methodNotFound, arg),\n  /**\n   * Get a JSON RPC 2.0 Internal (-32603) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  internal: (arg) => getJsonRpcError(errorCodes.rpc.internal, arg),\n  /**\n   * Get a JSON RPC 2.0 Server error.\n   * Permits integer error codes in the [ -32099 <= -32005 ] range.\n   * Codes -32000 through -32004 are reserved by EIP-1474.\n   *\n   * @param opts - The error options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  server: (opts) => {\n    if (!opts || typeof opts !== \"object\" || Array.isArray(opts)) {\n      throw new Error(\n        \"Ethereum RPC Server errors must provide single object argument.\"\n      );\n    }\n    const { code } = opts;\n    if (!Number.isInteger(code) || code > -32005 || code < -32099) {\n      throw new Error(\n        '\"code\" must be an integer such that: -32099 <= code <= -32005'\n      );\n    }\n    return getJsonRpcError(code, opts);\n  },\n  /**\n   * Get an Ethereum JSON RPC Invalid Input (-32000) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  invalidInput: (arg) => getJsonRpcError(errorCodes.rpc.invalidInput, arg),\n  /**\n   * Get an Ethereum JSON RPC Resource Not Found (-32001) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  resourceNotFound: (arg) => getJsonRpcError(errorCodes.rpc.resourceNotFound, arg),\n  /**\n   * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  resourceUnavailable: (arg) => getJsonRpcError(errorCodes.rpc.resourceUnavailable, arg),\n  /**\n   * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  transactionRejected: (arg) => getJsonRpcError(errorCodes.rpc.transactionRejected, arg),\n  /**\n   * Get an Ethereum JSON RPC Method Not Supported (-32004) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  methodNotSupported: (arg) => getJsonRpcError(errorCodes.rpc.methodNotSupported, arg),\n  /**\n   * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link JsonRpcError} class.\n   */\n  limitExceeded: (arg) => getJsonRpcError(errorCodes.rpc.limitExceeded, arg)\n};\nvar providerErrors = {\n  /**\n   * Get an Ethereum Provider User Rejected Request (4001) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link EthereumProviderError} class.\n   */\n  userRejectedRequest: (arg) => {\n    return getEthProviderError(errorCodes.provider.userRejectedRequest, arg);\n  },\n  /**\n   * Get an Ethereum Provider Unauthorized (4100) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link EthereumProviderError} class.\n   */\n  unauthorized: (arg) => {\n    return getEthProviderError(errorCodes.provider.unauthorized, arg);\n  },\n  /**\n   * Get an Ethereum Provider Unsupported Method (4200) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link EthereumProviderError} class.\n   */\n  unsupportedMethod: (arg) => {\n    return getEthProviderError(errorCodes.provider.unsupportedMethod, arg);\n  },\n  /**\n   * Get an Ethereum Provider Not Connected (4900) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link EthereumProviderError} class.\n   */\n  disconnected: (arg) => {\n    return getEthProviderError(errorCodes.provider.disconnected, arg);\n  },\n  /**\n   * Get an Ethereum Provider Chain Not Connected (4901) error.\n   *\n   * @param arg - The error message or options bag.\n   * @returns An instance of the {@link EthereumProviderError} class.\n   */\n  chainDisconnected: (arg) => {\n    return getEthProviderError(errorCodes.provider.chainDisconnected, arg);\n  },\n  /**\n   * Get a custom Ethereum Provider error.\n   *\n   * @param opts - The error options bag.\n   * @returns An instance of the {@link EthereumProviderError} class.\n   */\n  custom: (opts) => {\n    if (!opts || typeof opts !== \"object\" || Array.isArray(opts)) {\n      throw new Error(\n        \"Ethereum Provider custom errors must provide single object argument.\"\n      );\n    }\n    const { code, message, data } = opts;\n    if (!message || typeof message !== \"string\") {\n      throw new Error('\"message\" must be a nonempty string');\n    }\n    return new EthereumProviderError(code, message, data);\n  }\n};\nfunction getJsonRpcError(code, arg) {\n  const [message, data] = parseOpts(arg);\n  return new JsonRpcError(code, message ?? getMessageFromCode(code), data);\n}\nfunction getEthProviderError(code, arg) {\n  const [message, data] = parseOpts(arg);\n  return new EthereumProviderError(\n    code,\n    message ?? getMessageFromCode(code),\n    data\n  );\n}\nfunction parseOpts(arg) {\n  if (arg) {\n    if (typeof arg === \"string\") {\n      return [arg];\n    } else if (typeof arg === \"object\" && !Array.isArray(arg)) {\n      const { message, data } = arg;\n      if (message && typeof message !== \"string\") {\n        throw new Error(\"Must specify string message.\");\n      }\n      return [message ?? void 0, data];\n    }\n  }\n  return [];\n}\n\nexport {\n  rpcErrors,\n  providerErrors\n};\n//# sourceMappingURL=chunk-22ZLYCIT.mjs.map","var __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj))\n    throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj))\n    throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\n\n// src/errors.ts\nvar _code, _message, _data, _stack;\nvar SnapError = class extends Error {\n  /**\n   * Create a new `SnapError`.\n   *\n   * @param error - The error to create the `SnapError` from. If this is a\n   * `string`, it will be used as the error message. If this is an `Error`, its\n   * `message` property will be used as the error message. If this is a\n   * `JsonRpcError`, its `message` property will be used as the error message\n   * and its `code` property will be used as the error code. Otherwise, the\n   * error will be converted to a string and used as the error message.\n   * @param data - Additional data to include in the error. This will be merged\n   * with the error data, if any.\n   */\n  constructor(error, data = {}) {\n    const message = getErrorMessage(error);\n    super(message);\n    __privateAdd(this, _code, void 0);\n    __privateAdd(this, _message, void 0);\n    __privateAdd(this, _data, void 0);\n    __privateAdd(this, _stack, void 0);\n    __privateSet(this, _message, message);\n    __privateSet(this, _code, getErrorCode(error));\n    const mergedData = { ...getErrorData(error), ...data };\n    if (Object.keys(mergedData).length > 0) {\n      __privateSet(this, _data, mergedData);\n    }\n    __privateSet(this, _stack, super.stack);\n  }\n  /**\n   * The error name.\n   *\n   * @returns The error name.\n   */\n  get name() {\n    return \"SnapError\";\n  }\n  /**\n   * The error code.\n   *\n   * @returns The error code.\n   */\n  get code() {\n    return __privateGet(this, _code);\n  }\n  /**\n   * The error message.\n   *\n   * @returns The error message.\n   */\n  // This line is covered, but Jest doesn't pick it up for some reason.\n  /* istanbul ignore next */\n  get message() {\n    return __privateGet(this, _message);\n  }\n  /**\n   * Additional data for the error.\n   *\n   * @returns Additional data for the error.\n   */\n  get data() {\n    return __privateGet(this, _data);\n  }\n  /**\n   * The error stack.\n   *\n   * @returns The error stack.\n   */\n  // This line is covered, but Jest doesn't pick it up for some reason.\n  /* istanbul ignore next */\n  get stack() {\n    return __privateGet(this, _stack);\n  }\n  /**\n   * Convert the error to a JSON object.\n   *\n   * @returns The JSON object.\n   */\n  toJSON() {\n    return {\n      code: SNAP_ERROR_CODE,\n      message: SNAP_ERROR_MESSAGE,\n      data: {\n        cause: {\n          code: this.code,\n          message: this.message,\n          stack: this.stack,\n          ...this.data ? { data: this.data } : {}\n        }\n      }\n    };\n  }\n  /**\n   * Serialize the error to a JSON object. This is called by\n   * `@metamask/rpc-errors` when serializing the error.\n   *\n   * @returns The JSON object.\n   */\n  serialize() {\n    return this.toJSON();\n  }\n};\n_code = new WeakMap();\n_message = new WeakMap();\n_data = new WeakMap();\n_stack = new WeakMap();\n\n// src/internals/error-wrappers.ts\nfunction createSnapError(fn) {\n  return class SnapJsonRpcError extends SnapError {\n    /**\n     * Create a new `SnapJsonRpcError` from a message and data.\n     *\n     * @param message - The message to create the error from.\n     * @param data - The data to create the error from.\n     */\n    constructor(message, data) {\n      if (typeof message === \"object\") {\n        const error2 = fn();\n        super({\n          code: error2.code,\n          message: error2.message,\n          data: message\n        });\n        return;\n      }\n      const error = fn(message);\n      super({\n        code: error.code,\n        message: error.message,\n        data\n      });\n    }\n  };\n}\n\n// src/internals/errors.ts\nimport { hasProperty, isObject, isValidJson } from \"@metamask/utils\";\nvar SNAP_ERROR_CODE = -31002;\nvar SNAP_ERROR_MESSAGE = \"Snap Error\";\nfunction getErrorMessage(error) {\n  if (isObject(error) && hasProperty(error, \"message\") && typeof error.message === \"string\") {\n    return error.message;\n  }\n  return String(error);\n}\nfunction getErrorStack(error) {\n  if (isObject(error) && hasProperty(error, \"stack\") && typeof error.stack === \"string\") {\n    return error.stack;\n  }\n  return void 0;\n}\nfunction getErrorCode(error) {\n  if (isObject(error) && hasProperty(error, \"code\") && typeof error.code === \"number\" && Number.isInteger(error.code)) {\n    return error.code;\n  }\n  return -32603;\n}\nfunction getErrorData(error) {\n  if (isObject(error) && hasProperty(error, \"data\") && typeof error.data === \"object\" && error.data !== null && isValidJson(error.data) && !Array.isArray(error.data)) {\n    return error.data;\n  }\n  return {};\n}\n\n// src/internals/structs.ts\nimport {\n  Struct,\n  define,\n  is,\n  literal as superstructLiteral,\n  union as superstructUnion\n} from \"@metamask/superstruct\";\nimport { hasProperty as hasProperty2, isPlainObject } from \"@metamask/utils\";\nfunction literal(value) {\n  return define(\n    JSON.stringify(value),\n    superstructLiteral(value).validator\n  );\n}\nfunction union([\n  head,\n  ...tail\n]) {\n  const struct = superstructUnion([head, ...tail]);\n  return new Struct({\n    ...struct,\n    schema: [head, ...tail]\n  });\n}\nfunction enumValue(constant) {\n  return literal(constant);\n}\nfunction typedUnion(structs) {\n  return new Struct({\n    type: \"union\",\n    schema: null,\n    *entries(value, context) {\n      if (!isPlainObject(value) || !hasProperty2(value, \"type\")) {\n        return;\n      }\n      const { type } = value;\n      const struct = structs.find(({ schema }) => is(type, schema.type));\n      if (!struct) {\n        return;\n      }\n      for (const entry of struct.entries(value, context)) {\n        yield entry;\n      }\n    },\n    validator(value, context) {\n      const types = structs.map(({ schema }) => schema.type.type);\n      if (!isPlainObject(value) || !hasProperty2(value, \"type\") || typeof value.type !== \"string\") {\n        return `Expected type to be one of: ${types.join(\n          \", \"\n        )}, but received: undefined`;\n      }\n      const { type } = value;\n      const struct = structs.find(({ schema }) => is(type, schema.type));\n      if (struct) {\n        return struct.validator(value, context);\n      }\n      return `Expected type to be one of: ${types.join(\n        \", \"\n      )}, but received: \"${type}\"`;\n    }\n  });\n}\n\n// src/internals/jsx.ts\nfunction nullUnion(structs) {\n  return union(structs);\n}\n\n// src/internals/svg.ts\nimport { refine, string } from \"@metamask/superstruct\";\nfunction svg() {\n  return refine(string(), \"SVG\", (value) => {\n    if (!value.includes(\"<svg\")) {\n      return \"Value is not a valid SVG.\";\n    }\n    return true;\n  });\n}\n\n// src/index.ts\nimport { assert as assert2 } from \"@metamask/utils\";\n\n// src/error-wrappers.ts\nimport { providerErrors, rpcErrors } from \"@metamask/rpc-errors\";\nvar InternalError = createSnapError(rpcErrors.internal);\nvar InvalidInputError = createSnapError(rpcErrors.invalidInput);\nvar InvalidParamsError = createSnapError(rpcErrors.invalidParams);\nvar InvalidRequestError = createSnapError(rpcErrors.invalidRequest);\nvar LimitExceededError = createSnapError(rpcErrors.limitExceeded);\nvar MethodNotFoundError = createSnapError(rpcErrors.methodNotFound);\nvar MethodNotSupportedError = createSnapError(\n  rpcErrors.methodNotSupported\n);\nvar ParseError = createSnapError(rpcErrors.parse);\nvar ResourceNotFoundError = createSnapError(\n  rpcErrors.resourceNotFound\n);\nvar ResourceUnavailableError = createSnapError(\n  rpcErrors.resourceUnavailable\n);\nvar TransactionRejected = createSnapError(\n  rpcErrors.transactionRejected\n);\nvar ChainDisconnectedError = createSnapError(\n  providerErrors.chainDisconnected\n);\nvar DisconnectedError = createSnapError(providerErrors.disconnected);\nvar UnauthorizedError = createSnapError(providerErrors.unauthorized);\nvar UnsupportedMethodError = createSnapError(\n  providerErrors.unsupportedMethod\n);\nvar UserRejectedRequestError = createSnapError(\n  providerErrors.userRejectedRequest\n);\n\n// src/images.ts\nimport { assert, bytesToBase64 } from \"@metamask/utils\";\n\n// src/ui/components/address.ts\nimport { assign as assign2, literal as literal2, object as object2 } from \"@metamask/superstruct\";\nimport { HexChecksumAddressStruct } from \"@metamask/utils\";\n\n// src/ui/builder.ts\nimport { assertStruct, isPlainObject as isPlainObject2 } from \"@metamask/utils\";\nfunction createBuilder(type, struct, keys = []) {\n  return (...args) => {\n    if (args.length === 1 && isPlainObject2(args[0])) {\n      const node2 = { ...args[0], type };\n      assertStruct(node2, struct, `Invalid ${type} component`);\n      return node2;\n    }\n    const node = keys.reduce(\n      (partialNode, key, index) => {\n        if (args[index] !== void 0) {\n          return {\n            ...partialNode,\n            [key]: args[index]\n          };\n        }\n        return partialNode;\n      },\n      { type }\n    );\n    assertStruct(node, struct, `Invalid ${type} component`);\n    return node;\n  };\n}\n\n// src/ui/nodes.ts\nimport { assign, object, string as string2, unknown } from \"@metamask/superstruct\";\nvar NodeType = /* @__PURE__ */ ((NodeType2) => {\n  NodeType2[\"Copyable\"] = \"copyable\";\n  NodeType2[\"Divider\"] = \"divider\";\n  NodeType2[\"Heading\"] = \"heading\";\n  NodeType2[\"Panel\"] = \"panel\";\n  NodeType2[\"Spinner\"] = \"spinner\";\n  NodeType2[\"Text\"] = \"text\";\n  NodeType2[\"Image\"] = \"image\";\n  NodeType2[\"Row\"] = \"row\";\n  NodeType2[\"Address\"] = \"address\";\n  NodeType2[\"Button\"] = \"button\";\n  NodeType2[\"Input\"] = \"input\";\n  NodeType2[\"Form\"] = \"form\";\n  return NodeType2;\n})(NodeType || {});\nvar NodeStruct = object({\n  type: string2()\n});\nvar LiteralStruct = assign(\n  NodeStruct,\n  object({\n    value: unknown()\n  })\n);\n\n// src/ui/components/address.ts\nvar AddressStruct = assign2(\n  LiteralStruct,\n  object2({\n    type: literal2(\"address\" /* Address */),\n    value: HexChecksumAddressStruct\n  })\n);\nvar address = createBuilder(\"address\" /* Address */, AddressStruct, [\n  \"value\"\n]);\n\n// src/ui/components/copyable.ts\nimport {\n  assign as assign3,\n  boolean,\n  literal as literal3,\n  object as object3,\n  optional,\n  string as string3\n} from \"@metamask/superstruct\";\nvar CopyableStruct = assign3(\n  LiteralStruct,\n  object3({\n    type: literal3(\"copyable\" /* Copyable */),\n    value: string3(),\n    sensitive: optional(boolean())\n  })\n);\nvar copyable = createBuilder(\"copyable\" /* Copyable */, CopyableStruct, [\n  \"value\",\n  \"sensitive\"\n]);\n\n// src/ui/components/divider.ts\nimport { assign as assign4, literal as literal4, object as object4 } from \"@metamask/superstruct\";\nvar DividerStruct = assign4(\n  NodeStruct,\n  object4({\n    type: literal4(\"divider\" /* Divider */)\n  })\n);\nvar divider = createBuilder(\"divider\" /* Divider */, DividerStruct);\n\n// src/ui/components/heading.ts\nimport { assign as assign5, literal as literal5, object as object5, string as string4 } from \"@metamask/superstruct\";\nvar HeadingStruct = assign5(\n  LiteralStruct,\n  object5({\n    type: literal5(\"heading\" /* Heading */),\n    value: string4()\n  })\n);\nvar heading = createBuilder(\"heading\" /* Heading */, HeadingStruct, [\n  \"value\"\n]);\n\n// src/ui/components/image.ts\nimport { assign as assign6, literal as literal6, object as object6 } from \"@metamask/superstruct\";\nvar ImageStruct = assign6(\n  NodeStruct,\n  object6({\n    type: literal6(\"image\" /* Image */),\n    value: svg()\n  })\n);\nvar image = createBuilder(\"image\" /* Image */, ImageStruct, [\"value\"]);\n\n// src/ui/components/panel.ts\nimport { array as array2, assign as assign13, lazy, literal as literal13, object as object13 } from \"@metamask/superstruct\";\n\n// src/ui/components/button.ts\nimport {\n  assign as assign7,\n  literal as literal7,\n  object as object7,\n  optional as optional2,\n  string as string5,\n  union as union2\n} from \"@metamask/superstruct\";\nvar ButtonVariant = /* @__PURE__ */ ((ButtonVariant2) => {\n  ButtonVariant2[\"Primary\"] = \"primary\";\n  ButtonVariant2[\"Secondary\"] = \"secondary\";\n  return ButtonVariant2;\n})(ButtonVariant || {});\nvar ButtonType = /* @__PURE__ */ ((ButtonType2) => {\n  ButtonType2[\"Button\"] = \"button\";\n  ButtonType2[\"Submit\"] = \"submit\";\n  return ButtonType2;\n})(ButtonType || {});\nvar ButtonStruct = assign7(\n  LiteralStruct,\n  object7({\n    type: literal7(\"button\" /* Button */),\n    value: string5(),\n    variant: optional2(\n      union2([\n        enumValue(\"primary\" /* Primary */),\n        enumValue(\"secondary\" /* Secondary */)\n      ])\n    ),\n    buttonType: optional2(\n      union2([enumValue(\"button\" /* Button */), enumValue(\"submit\" /* Submit */)])\n    ),\n    name: optional2(string5())\n  })\n);\nvar button = createBuilder(\"button\" /* Button */, ButtonStruct, [\n  \"value\",\n  \"buttonType\",\n  \"name\",\n  \"variant\"\n]);\n\n// src/ui/components/form.ts\nimport {\n  array,\n  assign as assign9,\n  literal as literal9,\n  object as object9,\n  string as string7,\n  union as union4\n} from \"@metamask/superstruct\";\n\n// src/ui/components/input.ts\nimport {\n  assign as assign8,\n  literal as literal8,\n  object as object8,\n  optional as optional3,\n  string as string6,\n  union as union3\n} from \"@metamask/superstruct\";\nvar InputType = /* @__PURE__ */ ((InputType2) => {\n  InputType2[\"Text\"] = \"text\";\n  InputType2[\"Number\"] = \"number\";\n  InputType2[\"Password\"] = \"password\";\n  return InputType2;\n})(InputType || {});\nvar InputStruct = assign8(\n  LiteralStruct,\n  object8({\n    type: literal8(\"input\" /* Input */),\n    value: optional3(string6()),\n    name: string6(),\n    inputType: optional3(\n      union3([\n        enumValue(\"text\" /* Text */),\n        enumValue(\"password\" /* Password */),\n        enumValue(\"number\" /* Number */)\n      ])\n    ),\n    placeholder: optional3(string6()),\n    label: optional3(string6()),\n    error: optional3(string6())\n  })\n);\nvar input = createBuilder(\"input\" /* Input */, InputStruct, [\n  \"name\",\n  \"inputType\",\n  \"placeholder\",\n  \"value\",\n  \"label\"\n]);\n\n// src/ui/components/form.ts\nvar FormComponentStruct = union4([InputStruct, ButtonStruct]);\nvar FormStruct = assign9(\n  NodeStruct,\n  object9({\n    type: literal9(\"form\" /* Form */),\n    children: array(FormComponentStruct),\n    name: string7()\n  })\n);\nvar form = createBuilder(\"form\" /* Form */, FormStruct, [\n  \"name\",\n  \"children\"\n]);\n\n// src/ui/components/row.ts\nimport {\n  assign as assign11,\n  literal as literal11,\n  object as object11,\n  string as string9,\n  optional as optional5,\n  union as union5\n} from \"@metamask/superstruct\";\n\n// src/ui/components/text.ts\nimport {\n  assign as assign10,\n  boolean as boolean2,\n  literal as literal10,\n  object as object10,\n  optional as optional4,\n  string as string8\n} from \"@metamask/superstruct\";\nvar TextStruct = assign10(\n  LiteralStruct,\n  object10({\n    type: literal10(\"text\" /* Text */),\n    value: string8(),\n    markdown: optional4(boolean2())\n  })\n);\nvar text = createBuilder(\"text\" /* Text */, TextStruct, [\n  \"value\",\n  \"markdown\"\n]);\n\n// src/ui/components/row.ts\nvar RowVariant = /* @__PURE__ */ ((RowVariant2) => {\n  RowVariant2[\"Default\"] = \"default\";\n  RowVariant2[\"Critical\"] = \"critical\";\n  RowVariant2[\"Warning\"] = \"warning\";\n  return RowVariant2;\n})(RowVariant || {});\nvar RowComponentStruct = union5([ImageStruct, TextStruct, AddressStruct]);\nvar RowStruct = assign11(\n  LiteralStruct,\n  object11({\n    type: literal11(\"row\" /* Row */),\n    variant: optional5(\n      union5([\n        enumValue(\"default\" /* Default */),\n        enumValue(\"critical\" /* Critical */),\n        enumValue(\"warning\" /* Warning */)\n      ])\n    ),\n    label: string9(),\n    value: RowComponentStruct\n  })\n);\nvar row = createBuilder(\"row\" /* Row */, RowStruct, [\n  \"label\",\n  \"value\",\n  \"variant\"\n]);\n\n// src/ui/components/spinner.ts\nimport { assign as assign12, literal as literal12, object as object12 } from \"@metamask/superstruct\";\nvar SpinnerStruct = assign12(\n  NodeStruct,\n  object12({\n    type: literal12(\"spinner\" /* Spinner */)\n  })\n);\nvar spinner = createBuilder(\"spinner\" /* Spinner */, SpinnerStruct);\n\n// src/ui/components/panel.ts\nvar ParentStruct = assign13(\n  NodeStruct,\n  object13({\n    // This node references itself indirectly, so we need to use `lazy()`.\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    children: array2(lazy(() => ComponentStruct))\n  })\n);\nvar PanelStruct = assign13(\n  ParentStruct,\n  object13({\n    type: literal13(\"panel\" /* Panel */)\n  })\n);\nvar panel = createBuilder(\"panel\" /* Panel */, PanelStruct, [\"children\"]);\nvar ComponentStruct = typedUnion([\n  CopyableStruct,\n  DividerStruct,\n  HeadingStruct,\n  ImageStruct,\n  PanelStruct,\n  SpinnerStruct,\n  TextStruct,\n  RowStruct,\n  AddressStruct,\n  InputStruct,\n  FormStruct,\n  ButtonStruct\n]);\n\n// src/ui/component.ts\nimport { is as is2 } from \"@metamask/superstruct\";\nimport { assertStruct as assertStruct2 } from \"@metamask/utils\";\nfunction isComponent(value) {\n  return is2(value, ComponentStruct);\n}\nfunction assertIsComponent(value) {\n  assertStruct2(value, ComponentStruct, \"Invalid component\");\n}\n\n// src/images.ts\nasync function getRawImageData(url, options) {\n  if (typeof fetch !== \"function\") {\n    throw new Error(\n      `Failed to fetch image data from \"${url}\": Using this function requires the \"endowment:network-access\" permission.`\n    );\n  }\n  return fetch(url, options).then(async (response) => {\n    if (!response.ok) {\n      throw new Error(\n        `Failed to fetch image data from \"${url}\": ${response.status} ${response.statusText}`\n      );\n    }\n    const blob = await response.blob();\n    assert(\n      blob.type === \"image/jpeg\" || blob.type === \"image/png\",\n      \"Expected image data to be a JPEG or PNG image.\"\n    );\n    return blob;\n  });\n}\nasync function getImageData(url, options) {\n  const blob = await getRawImageData(url, options);\n  const bytes = new Uint8Array(await blob.arrayBuffer());\n  return `data:${blob.type};base64,${bytesToBase64(bytes)}`;\n}\nasync function getImageComponent(url, { width, height = width, request }) {\n  assert(\n    typeof width === \"number\" && width > 0,\n    \"Expected width to be a number greater than 0.\"\n  );\n  assert(\n    typeof height === \"number\" && height > 0,\n    \"Expected height to be a number greater than 0.\"\n  );\n  const imageData = await getImageData(url, request);\n  const size = `width=\"${width}\" height=\"${height}\"`;\n  return image(\n    `<svg ${size.trim()} xmlns=\"http://www.w3.org/2000/svg\"><image ${size.trim()} href=\"${imageData}\" /></svg>`\n  );\n}\n\n// src/types/handlers/transaction.ts\nvar SeverityLevel = /* @__PURE__ */ ((SeverityLevel2) => {\n  SeverityLevel2[\"Critical\"] = \"critical\";\n  return SeverityLevel2;\n})(SeverityLevel || {});\n\n// src/types/handlers/user-input.ts\nimport {\n  number,\n  assign as assign14,\n  literal as literal14,\n  nullable,\n  object as object14,\n  optional as optional6,\n  record,\n  string as string10,\n  union as union6,\n  boolean as boolean3\n} from \"@metamask/superstruct\";\nvar UserInputEventType = /* @__PURE__ */ ((UserInputEventType2) => {\n  UserInputEventType2[\"ButtonClickEvent\"] = \"ButtonClickEvent\";\n  UserInputEventType2[\"FormSubmitEvent\"] = \"FormSubmitEvent\";\n  UserInputEventType2[\"InputChangeEvent\"] = \"InputChangeEvent\";\n  UserInputEventType2[\"FileUploadEvent\"] = \"FileUploadEvent\";\n  return UserInputEventType2;\n})(UserInputEventType || {});\nvar GenericEventStruct = object14({\n  type: string10(),\n  name: optional6(string10())\n});\nvar ButtonClickEventStruct = assign14(\n  GenericEventStruct,\n  object14({\n    type: literal14(\"ButtonClickEvent\" /* ButtonClickEvent */),\n    name: optional6(string10())\n  })\n);\nvar FileStruct = object14({\n  name: string10(),\n  size: number(),\n  contentType: string10(),\n  contents: string10()\n});\nvar FormSubmitEventStruct = assign14(\n  GenericEventStruct,\n  object14({\n    type: literal14(\"FormSubmitEvent\" /* FormSubmitEvent */),\n    value: record(string10(), nullable(union6([string10(), FileStruct, boolean3()]))),\n    name: string10()\n  })\n);\nvar InputChangeEventStruct = assign14(\n  GenericEventStruct,\n  object14({\n    type: literal14(\"InputChangeEvent\" /* InputChangeEvent */),\n    name: string10(),\n    value: union6([string10(), boolean3()])\n  })\n);\nvar FileUploadEventStruct = assign14(\n  GenericEventStruct,\n  object14({\n    type: literal14(\"FileUploadEvent\" /* FileUploadEvent */),\n    name: string10(),\n    file: nullable(FileStruct)\n  })\n);\nvar UserInputEventStruct = union6([\n  ButtonClickEventStruct,\n  FormSubmitEventStruct,\n  InputChangeEventStruct,\n  FileUploadEventStruct\n]);\n\n// src/types/methods/dialog.ts\nvar DialogType = /* @__PURE__ */ ((DialogType2) => {\n  DialogType2[\"Alert\"] = \"alert\";\n  DialogType2[\"Confirmation\"] = \"confirmation\";\n  DialogType2[\"Prompt\"] = \"prompt\";\n  return DialogType2;\n})(DialogType || {});\n\n// src/types/methods/get-file.ts\nvar AuxiliaryFileEncoding = /* @__PURE__ */ ((AuxiliaryFileEncoding2) => {\n  AuxiliaryFileEncoding2[\"Base64\"] = \"base64\";\n  AuxiliaryFileEncoding2[\"Hex\"] = \"hex\";\n  AuxiliaryFileEncoding2[\"Utf8\"] = \"utf8\";\n  return AuxiliaryFileEncoding2;\n})(AuxiliaryFileEncoding || {});\n\n// src/types/methods/manage-state.ts\nvar ManageStateOperation = /* @__PURE__ */ ((ManageStateOperation2) => {\n  ManageStateOperation2[\"ClearState\"] = \"clear\";\n  ManageStateOperation2[\"GetState\"] = \"get\";\n  ManageStateOperation2[\"UpdateState\"] = \"update\";\n  return ManageStateOperation2;\n})(ManageStateOperation || {});\n\n// src/types/methods/notify.ts\nvar NotificationType = /* @__PURE__ */ ((NotificationType2) => {\n  NotificationType2[\"InApp\"] = \"inApp\";\n  NotificationType2[\"Native\"] = \"native\";\n  return NotificationType2;\n})(NotificationType || {});\n\n// src/types/interface.ts\nimport {\n  boolean as boolean5,\n  nullable as nullable3,\n  record as record3,\n  string as string12,\n  union as union7\n} from \"@metamask/superstruct\";\nimport { JsonStruct as JsonStruct2 } from \"@metamask/utils\";\n\n// src/jsx/validation.ts\nimport {\n  is as is3,\n  boolean as boolean4,\n  optional as optional7,\n  array as array3,\n  lazy as lazy2,\n  nullable as nullable2,\n  number as number2,\n  object as object15,\n  record as record2,\n  string as string11,\n  tuple\n} from \"@metamask/superstruct\";\nimport {\n  hasProperty as hasProperty3,\n  HexChecksumAddressStruct as HexChecksumAddressStruct2,\n  isPlainObject as isPlainObject3,\n  JsonStruct\n} from \"@metamask/utils\";\nvar KeyStruct = nullUnion([string11(), number2()]);\nvar StringElementStruct = children([\n  string11()\n]);\nvar ElementStruct = object15({\n  type: string11(),\n  props: record2(string11(), JsonStruct),\n  key: nullable2(KeyStruct)\n});\nfunction nestable(struct) {\n  const nestableStruct = nullUnion([\n    struct,\n    array3(lazy2(() => nestableStruct))\n  ]);\n  return nestableStruct;\n}\nfunction children(structs) {\n  return nestable(nullable2(nullUnion([...structs, boolean4()])));\n}\nfunction element(name, props = {}) {\n  return object15({\n    type: literal(name),\n    props: object15(props),\n    key: nullable2(KeyStruct)\n  });\n}\nvar ButtonStruct2 = element(\"Button\", {\n  children: StringElementStruct,\n  name: optional7(string11()),\n  type: optional7(nullUnion([literal(\"button\"), literal(\"submit\")])),\n  variant: optional7(nullUnion([literal(\"primary\"), literal(\"destructive\")])),\n  disabled: optional7(boolean4())\n});\nvar CheckboxStruct = element(\"Checkbox\", {\n  name: string11(),\n  checked: optional7(boolean4()),\n  label: optional7(string11()),\n  variant: optional7(nullUnion([literal(\"default\"), literal(\"toggle\")]))\n});\nvar InputStruct2 = element(\"Input\", {\n  name: string11(),\n  type: optional7(\n    nullUnion([literal(\"text\"), literal(\"password\"), literal(\"number\")])\n  ),\n  value: optional7(string11()),\n  placeholder: optional7(string11())\n});\nvar OptionStruct = element(\"Option\", {\n  value: string11(),\n  children: string11()\n});\nvar DropdownStruct = element(\"Dropdown\", {\n  name: string11(),\n  value: optional7(string11()),\n  children: children([OptionStruct])\n});\nvar FileInputStruct = element(\n  \"FileInput\",\n  {\n    name: string11(),\n    accept: nullUnion([optional7(array3(string11()))]),\n    compact: optional7(boolean4())\n  }\n);\nvar BUTTON_INPUT = [InputStruct2, ButtonStruct2];\nvar FIELD_CHILDREN_ARRAY = [\n  InputStruct2,\n  DropdownStruct,\n  FileInputStruct,\n  CheckboxStruct\n];\nvar FieldChildUnionStruct = nullUnion([\n  ...FIELD_CHILDREN_ARRAY,\n  ...BUTTON_INPUT\n]);\nvar FieldChildStruct = nullUnion([\n  tuple(BUTTON_INPUT),\n  ...FIELD_CHILDREN_ARRAY\n]);\nvar FieldStruct = element(\"Field\", {\n  label: optional7(string11()),\n  error: optional7(string11()),\n  children: FieldChildStruct\n});\nvar FormChildStruct = children(\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  [FieldStruct, lazy2(() => BoxChildStruct)]\n);\nvar FormStruct2 = element(\"Form\", {\n  children: FormChildStruct,\n  name: string11()\n});\nvar BoldStruct = element(\"Bold\", {\n  children: children([\n    string11(),\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    lazy2(() => ItalicStruct)\n  ])\n});\nvar ItalicStruct = element(\"Italic\", {\n  children: children([\n    string11(),\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    lazy2(() => BoldStruct)\n  ])\n});\nvar FormattingStruct = nullUnion([\n  BoldStruct,\n  ItalicStruct\n]);\nvar AddressStruct2 = element(\"Address\", {\n  address: HexChecksumAddressStruct2\n});\nvar BoxChildrenStruct = children(\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  [lazy2(() => BoxChildStruct)]\n);\nvar BoxStruct = element(\"Box\", {\n  children: BoxChildrenStruct,\n  direction: optional7(nullUnion([literal(\"horizontal\"), literal(\"vertical\")])),\n  alignment: optional7(\n    nullUnion([\n      literal(\"start\"),\n      literal(\"center\"),\n      literal(\"end\"),\n      literal(\"space-between\"),\n      literal(\"space-around\")\n    ])\n  )\n});\nvar FooterChildStruct = nullUnion([\n  tuple([ButtonStruct2, ButtonStruct2]),\n  ButtonStruct2\n]);\nvar FooterStruct = element(\"Footer\", {\n  children: FooterChildStruct\n});\nvar ContainerChildStruct = nullUnion([\n  tuple([BoxStruct, FooterStruct]),\n  BoxStruct\n]);\nvar ContainerStruct = element(\n  \"Container\",\n  {\n    children: ContainerChildStruct\n  }\n);\nvar CopyableStruct2 = element(\"Copyable\", {\n  value: string11(),\n  sensitive: optional7(boolean4())\n});\nvar DividerStruct2 = element(\"Divider\");\nvar ValueStruct = element(\"Value\", {\n  value: string11(),\n  extra: string11()\n});\nvar CardStruct = element(\"Card\", {\n  image: optional7(string11()),\n  title: string11(),\n  description: optional7(string11()),\n  value: string11(),\n  extra: optional7(string11())\n});\nvar HeadingStruct2 = element(\"Heading\", {\n  children: StringElementStruct\n});\nvar ImageStruct2 = element(\"Image\", {\n  src: svg(),\n  alt: optional7(string11())\n});\nvar LinkStruct = element(\"Link\", {\n  href: string11(),\n  children: children([FormattingStruct, string11()])\n});\nvar TextStruct2 = element(\"Text\", {\n  children: children([string11(), BoldStruct, ItalicStruct, LinkStruct]),\n  alignment: optional7(\n    nullUnion([literal(\"start\"), literal(\"center\"), literal(\"end\")])\n  )\n});\nvar TooltipChildStruct = nullUnion([\n  TextStruct2,\n  BoldStruct,\n  ItalicStruct,\n  LinkStruct,\n  ImageStruct2,\n  boolean4()\n]);\nvar TooltipContentStruct = nullUnion([\n  TextStruct2,\n  BoldStruct,\n  ItalicStruct,\n  LinkStruct,\n  string11()\n]);\nvar TooltipStruct = element(\"Tooltip\", {\n  children: nullable2(TooltipChildStruct),\n  content: TooltipContentStruct\n});\nvar RowStruct2 = element(\"Row\", {\n  label: string11(),\n  children: nullUnion([AddressStruct2, ImageStruct2, TextStruct2, ValueStruct]),\n  variant: optional7(\n    nullUnion([literal(\"default\"), literal(\"warning\"), literal(\"critical\")])\n  ),\n  tooltip: optional7(string11())\n});\nvar SpinnerStruct2 = element(\"Spinner\");\nvar BoxChildStruct = typedUnion([\n  AddressStruct2,\n  BoldStruct,\n  BoxStruct,\n  ButtonStruct2,\n  CopyableStruct2,\n  DividerStruct2,\n  DropdownStruct,\n  FileInputStruct,\n  FormStruct2,\n  HeadingStruct2,\n  InputStruct2,\n  ImageStruct2,\n  ItalicStruct,\n  LinkStruct,\n  RowStruct2,\n  SpinnerStruct2,\n  TextStruct2,\n  TooltipStruct,\n  CheckboxStruct,\n  CardStruct\n]);\nvar RootJSXElementStruct = nullUnion([\n  BoxChildStruct,\n  ContainerStruct\n]);\nvar JSXElementStruct = typedUnion([\n  ButtonStruct2,\n  InputStruct2,\n  FileInputStruct,\n  FieldStruct,\n  FormStruct2,\n  BoldStruct,\n  ItalicStruct,\n  AddressStruct2,\n  BoxStruct,\n  CopyableStruct2,\n  DividerStruct2,\n  HeadingStruct2,\n  ImageStruct2,\n  LinkStruct,\n  RowStruct2,\n  SpinnerStruct2,\n  TextStruct2,\n  DropdownStruct,\n  OptionStruct,\n  ValueStruct,\n  TooltipStruct,\n  CheckboxStruct,\n  FooterStruct,\n  ContainerStruct,\n  CardStruct\n]);\n\n// src/types/interface.ts\nvar StateStruct = union7([FileStruct, string12(), boolean5()]);\nvar FormStateStruct = record3(string12(), nullable3(StateStruct));\nvar InterfaceStateStruct = record3(\n  string12(),\n  union7([FormStateStruct, nullable3(StateStruct)])\n);\nvar ComponentOrElementStruct = union7([\n  ComponentStruct,\n  RootJSXElementStruct\n]);\nvar InterfaceContextStruct = record3(string12(), JsonStruct2);\nexport {\n  AddressStruct,\n  AuxiliaryFileEncoding,\n  ButtonClickEventStruct,\n  ButtonStruct,\n  ButtonType,\n  ButtonVariant,\n  ChainDisconnectedError,\n  ComponentOrElementStruct,\n  ComponentStruct,\n  CopyableStruct,\n  DialogType,\n  DisconnectedError,\n  DividerStruct,\n  FileStruct,\n  FileUploadEventStruct,\n  FormComponentStruct,\n  FormStateStruct,\n  FormStruct,\n  FormSubmitEventStruct,\n  GenericEventStruct,\n  HeadingStruct,\n  ImageStruct,\n  InputChangeEventStruct,\n  InputStruct,\n  InputType,\n  InterfaceContextStruct,\n  InterfaceStateStruct,\n  InternalError,\n  InvalidInputError,\n  InvalidParamsError,\n  InvalidRequestError,\n  LimitExceededError,\n  ManageStateOperation,\n  MethodNotFoundError,\n  MethodNotSupportedError,\n  NodeType,\n  NotificationType,\n  PanelStruct,\n  ParseError,\n  ResourceNotFoundError,\n  ResourceUnavailableError,\n  RowStruct,\n  RowVariant,\n  SNAP_ERROR_CODE,\n  SNAP_ERROR_MESSAGE,\n  SeverityLevel,\n  SnapError,\n  SpinnerStruct,\n  StateStruct,\n  TextStruct,\n  TransactionRejected,\n  UnauthorizedError,\n  UnsupportedMethodError,\n  UserInputEventStruct,\n  UserInputEventType,\n  UserRejectedRequestError,\n  address,\n  assert2 as assert,\n  assertIsComponent,\n  button,\n  copyable,\n  divider,\n  enumValue,\n  form,\n  getErrorData,\n  getErrorMessage,\n  getErrorStack,\n  getImageComponent,\n  getImageData,\n  heading,\n  image,\n  input,\n  isComponent,\n  literal,\n  panel,\n  row,\n  spinner,\n  text,\n  union\n};\n//# sourceMappingURL=index.mjs.map","import {\n  MethodNotFoundError,\n  type OnRpcRequestHandler,\n} from '@metamask/snaps-sdk';\n\n/**\n * Handle incoming JSON-RPC requests from the dapp, sent through the\n * `wallet_invokeSnap` method. This handler handles a single method:\n *\n * - `hello`: Returns a static message, \"Hello from Rollup!\". This is just\n * for demonstration purposes, showing that a snap can be built with\n * Rollup.\n *\n * @param params - The request parameters.\n * @param params.request - The JSON-RPC request object.\n * @returns The JSON-RPC response.\n * @see https://docs.metamask.io/snaps/reference/exports/#onrpcrequest\n * @see https://docs.metamask.io/snaps/reference/rpc-api/#wallet_invokesnap\n */\nexport const onRpcRequest: OnRpcRequestHandler = async ({ request }) => {\n  switch (request.method) {\n    case 'hello':\n      return 'Hello from Rollup!';\n\n    default:\n      throw new MethodNotFoundError({ method: request.method });\n  }\n};\n"],"names":["StructError","TypeError","constructor","failure","failures","cached","message","explanation","rest","path","cause","length","join","super","this","Object","assign","name","isObject","value","print","toString","JSON","stringify","toFailure","result","context","struct","branch","type","refinement","key","toFailures","Symbol","iterator","isIterable","validationResult","run","options","coerce","mask","coercer","schema","Array","isArray","undefined","status","validator","innerKey","innerValue","innerStruct","entries","iterable","Map","set","Set","add","refiner","Struct","props","assert","create","is","validate","tuples","tuple","input","done","next","shiftIterator","innerTuple","Structs","isType","schemas","map","keys","k","object","define","lazy","fn","ctx","array","Element","index","arrayValue","slice","boolean","literal","constant","description","valueType","never","nullable","number","isNaN","knowns","Never","unknowns","delete","optional","record","Key","Value","objectKey","objectValue","string","Math","max","i","union","InnerStruct","error","coerced","first","push","unknown","pattern","regexp","refine","test","source","Boolean","hasProperty","objectToCheck","hasOwnProperty","call","JsonSize","isPlainObject","proto","getPrototypeOf","_","getErrorMessageWithoutTrailingPeriod","isErrorWithMessage","String","getErrorMessage","replace","getError","ErrorWrapper","prototype","AssertionError","Error","code","HexChecksumAddressStruct","superstructObject","hasOptional","field","exactOptional","UnsafeJsonStruct","Number","isFinite","JsonStruct","condition","errorPrefix","assertSuperstruct","assertStruct","parse","propKey","propValue","isValidJson","getSafeJson","JsonRpcVersionStruct","JsonRpcIdStruct","JsonRpcErrorStruct","isInteger","data","stack","JsonRpcParamsStruct","id","jsonrpc","method","params","errorCodes","invalidInput","resourceNotFound","resourceUnavailable","transactionRejected","methodNotSupported","limitExceeded","invalidRequest","methodNotFound","invalidParams","internal","errorValues","standard","FALLBACK_ERROR_CODE","FALLBACK_MESSAGE","getMessageFromCode","JSON_RPC_SERVER_ERROR_MESSAGE","fallbackMessage","isValidCode","codeString","isJsonRpcServerError","serializeObject","getOwnPropertyNames","reduce","acc","fastSafeStringify","default","stable","deterministicStringify","stableStringify","LIMIT_REPLACE_NODE","CIRCULAR_REPLACE_NODE","arr","replacerStack","defaultOptions","depthLimit","MAX_SAFE_INTEGER","edgesLimit","obj","replacer","spacer","res","decirc","replaceGetterValues","part","pop","defineProperty","setReplace","val","parent","propertyDescriptor","getOwnPropertyDescriptor","get","configurable","edgeIndex","depth","compareFunction","a","b","tmp","deterministicDecirc","toJSON","sort","v","splice","JsonRpcError","__super","args","dataHasCause","serialize","serialized","entry","safeStringify","stringifyReplacer","rpcErrors","arg","getJsonRpcError","parseOpts","_code","_message","_data","_stack","__accessCheck","member","msg","has","__privateGet","getter","__privateAdd","WeakSet","__privateSet","setter","SnapError","getErrorCode","mergedData","getErrorData","SNAP_ERROR_CODE","SNAP_ERROR_MESSAGE","WeakMap","superstructLiteral","enumValue","typedUnion","structs","hasProperty2","find","types","nullUnion","head","tail","superstructUnion","svg","includes","MethodNotFoundError","error2","NodeStruct","string2","LiteralStruct","AddressStruct","assign2","object2","literal2","CopyableStruct","assign3","object3","literal3","string3","sensitive","DividerStruct","assign4","object4","literal4","HeadingStruct","assign5","object5","literal5","string4","ImageStruct","assign6","object6","literal6","ButtonStruct","assign7","object7","literal7","string5","variant","optional2","union2","buttonType","InputStruct","assign8","object8","literal8","optional3","string6","inputType","union3","placeholder","label","FormComponentStruct","union4","FormStruct","assign9","object9","literal9","children","string7","TextStruct","assign10","object10","literal10","string8","markdown","optional4","boolean2","RowComponentStruct","union5","RowStruct","assign11","object11","literal11","optional5","string9","SpinnerStruct","assign12","object12","literal12","ParentStruct","assign13","object13","array2","ComponentStruct","literal13","GenericEventStruct","object14","string10","optional6","ButtonClickEventStruct","assign14","literal14","FileStruct","size","contentType","contents","FormSubmitEventStruct","union6","boolean3","InputChangeEventStruct","file","KeyStruct","string11","number2","StringElementStruct","nestableStruct","array3","lazy2","nestable","nullable2","boolean4","element","object15","record2","ButtonStruct2","optional7","disabled","CheckboxStruct","checked","InputStruct2","OptionStruct","DropdownStruct","FileInputStruct","accept","compact","BUTTON_INPUT","FIELD_CHILDREN_ARRAY","FieldChildStruct","FieldStruct","FormStruct2","BoxChildStruct","BoldStruct","ItalicStruct","FormattingStruct","AddressStruct2","address","HexChecksumAddressStruct2","BoxStruct","direction","alignment","FooterStruct","ContainerStruct","CopyableStruct2","DividerStruct2","ValueStruct","extra","CardStruct","image","title","HeadingStruct2","ImageStruct2","src","alt","LinkStruct","href","TextStruct2","TooltipChildStruct","TooltipContentStruct","TooltipStruct","content","RowStruct2","tooltip","SpinnerStruct2","RootJSXElementStruct","StateStruct","union7","string12","boolean5","FormStateStruct","record3","nullable3","JsonStruct2","async","request"],"mappings":"oEAWO,MAAMA,UAAoBC,UAC7BC,YAAYC,EAASC,GACjB,IAAIC,EACJ,MAAMC,QAAEA,EAAOC,YAAEA,KAAgBC,GAASL,GACpCM,KAAEA,GAASN,EACXO,EAAwB,IAAhBD,EAAKE,OAAeL,EAAW,YAAWG,EAAKG,KAAK,WAAWN,IAC7EO,MAAMN,GAAeG,GACjBH,UACAO,KAAKJ,MAAQA,GAEjBK,OAAOC,OAAOF,KAAMN,GACpBM,KAAKG,KAAOH,KAAKZ,YAAYe,KAC7BH,KAAKV,SAAW,IACJC,IAAWA,EAAS,CAACF,KAAYC,KAEhD,ECXE,SAASc,EAASC,GACrB,MAAwB,iBAAVA,GAAgC,OAAVA,CACxC,CAoBO,SAASC,EAAMD,GAClB,MAAqB,iBAAVA,EACAA,EAAME,WAGO,iBAAVF,EAAqBG,KAAKC,UAAUJ,GAAU,GAAEA,GAClE,CAuBO,SAASK,EAAUC,EAAQC,EAASC,EAAQR,GAC/C,IAAe,IAAXM,EACA,QAEgB,IAAXA,EAELA,EAAS,CAAA,EAEc,iBAAXA,IAEZA,EAAS,CAAEnB,QAASmB,IAExB,MAAMhB,KAAEA,EAAImB,OAAEA,GAAWF,GACnBG,KAAEA,GAASF,GACXG,WAAEA,EAAUxB,QAAEA,EAAW,8BAA6BuB,MAASC,EAAc,sBAAqBA,MAAiB,uBAAuBV,EAAMD,QAAgBM,EACtK,MAAO,CACHN,QACAU,OACAC,aACAC,IAAKtB,EAAKA,EAAKE,OAAS,GACxBF,OACAmB,YACGH,EACHnB,UAER,CAWO,SAAU0B,EAAWP,EAAQC,EAASC,EAAQR,IAhGrD,SAAoBA,GAChB,OAAOD,EAASC,IAA4C,mBAA3BA,EAAMc,OAAOC,SAClD,EA+FSC,CAAWV,KAEZA,EAAS,CAACA,IAEd,IAAK,MAAMW,KAAoBX,EAAQ,CACnC,MAAMtB,EAAUqB,EAAUY,EAAkBV,EAASC,EAAQR,GACzDhB,UACMA,EAEb,CACL,CAgBO,SAAUkC,EAAIlB,EAAOQ,EAAQW,EAAU,CAAA,GAC1C,MAAM7B,KAAEA,EAAO,GAAEmB,OAAEA,EAAS,CAACT,GAAMoB,OAAEA,GAAS,EAAKC,KAAEA,GAAO,GAAUF,EAChEZ,EAAU,CAAEjB,OAAMmB,UACxB,GAAIW,IAEApB,EAAQQ,EAAOc,QAAQtB,EAAOO,GAC1Bc,GACgB,SAAhBb,EAAOE,MACPX,EAASS,EAAOe,SAChBxB,EAASC,KACRwB,MAAMC,QAAQzB,IACf,IAAK,MAAMY,KAAOZ,OACa0B,IAAvBlB,EAAOe,OAAOX,WACPZ,EAAMY,GAK7B,IAAIe,EAAS,QACb,IAAK,MAAM3C,KAAWwB,EAAOoB,UAAU5B,EAAOO,GAC1CvB,EAAQI,YAAc+B,EAAQhC,QAC9BwC,EAAS,iBACH,CAAC3C,OAAS0C,GAGpB,IAAK,IAAKG,EAAUC,EAAYC,KAAgBvB,EAAOwB,QAAQhC,EAAOO,GAAU,CAC5E,MAAM0B,EAAWf,EAAIY,EAAYC,EAAa,CAC1CzC,UAAmBoC,IAAbG,EAAyBvC,EAAO,IAAIA,EAAMuC,GAChDpB,YAAqBiB,IAAbG,EAAyBpB,EAAS,IAAIA,EAAQqB,GACtDV,SACAC,OACAlC,QAASgC,EAAQhC,UAErB,IAAK,MAAMmB,KAAU2B,EACb3B,EAAO,IACPqB,EAC6B,OAAzBrB,EAAO,GAAGK,iBAAgDe,IAAzBpB,EAAO,GAAGK,WACrC,YACA,mBACJ,CAACL,EAAO,QAAIoB,IAEbN,IACLU,EAAaxB,EAAO,QACHoB,IAAbG,EAEA7B,EAAQ8B,EAEH9B,aAAiBkC,IACtBlC,EAAMmC,IAAIN,EAAUC,GAEf9B,aAAiBoC,IACtBpC,EAAMqC,IAAIP,GAEL/B,EAASC,UACK0B,IAAfI,GAA4BD,KAAY7B,KACxCA,EAAM6B,GAAYC,GAKrC,CACD,GAAe,cAAXH,EACA,IAAK,MAAM3C,KAAWwB,EAAO8B,QAAQtC,EAAOO,GACxCvB,EAAQI,YAAc+B,EAAQhC,QAC9BwC,EAAS,mBACH,CAAC3C,OAAS0C,GAGT,UAAXC,SACM,MAACD,EAAW1B,GAE1B,CCjMO,MAAMuC,EACTxD,YAAYyD,GACR,MAAM9B,KAAEA,EAAIa,OAAEA,EAAMK,UAAEA,EAASU,QAAEA,EAAOhB,QAAEA,EAAWtB,IAAUA,GAAKgC,QAAEA,EAAU,YAE/E,GAAMQ,EACP7C,KAAKe,KAAOA,EACZf,KAAK4B,OAASA,EACd5B,KAAKqC,QAAUA,EACfrC,KAAK2B,QAAUA,EAEX3B,KAAKiC,UADLA,EACiB,CAAC5B,EAAOO,IAEdM,EADQe,EAAU5B,EAAOO,GACNA,EAASZ,KAAMK,GAI5B,IAAM,GAGvBL,KAAK2C,QADLA,EACe,CAACtC,EAAOO,IAEZM,EADQyB,EAAQtC,EAAOO,GACJA,EAASZ,KAAMK,GAI9B,IAAM,EAE5B,CAIDyC,OAAOzC,EAAOb,GACV,OAAOsD,EAAOzC,EAAOL,KAAMR,EAC9B,CAIDuD,OAAO1C,EAAOb,GACV,OAAOuD,EAAO1C,EAAOL,KAAMR,EAC9B,CAIDwD,GAAG3C,GACC,OAAO2C,EAAG3C,EAAOL,KACpB,CAKD0B,KAAKrB,EAAOb,GACR,OAoDD,SAAca,EAAOQ,EAAQrB,GAChC,MAAMmB,EAASsC,EAAS5C,EAAOQ,EAAQ,CAAEY,QAAQ,EAAMC,MAAM,EAAMlC,YACnE,GAAImB,EAAO,GACP,MAAMA,EAAO,GAGb,OAAOA,EAAO,EAEtB,CA5Dee,CAAKrB,EAAOL,KAAMR,EAC5B,CASDyD,SAAS5C,EAAOmB,EAAU,IACtB,OAAOyB,EAAS5C,EAAOL,KAAMwB,EAChC,EASE,SAASsB,EAAOzC,EAAOQ,EAAQrB,GAClC,MAAMmB,EAASsC,EAAS5C,EAAOQ,EAAQ,CAAErB,YACzC,GAAImB,EAAO,GACP,MAAMA,EAAO,EAErB,CASO,SAASoC,EAAO1C,EAAOQ,EAAQrB,GAClC,MAAMmB,EAASsC,EAAS5C,EAAOQ,EAAQ,CAAEY,QAAQ,EAAMjC,YACvD,GAAImB,EAAO,GACP,MAAMA,EAAO,GAGb,OAAOA,EAAO,EAEtB,CAyBO,SAASqC,EAAG3C,EAAOQ,GAEtB,OADeoC,EAAS5C,EAAOQ,GAChB,EACnB,CAaO,SAASoC,EAAS5C,EAAOQ,EAAQW,EAAU,CAAA,GAC9C,MAAM0B,EAAS3B,EAAIlB,EAAOQ,EAAQW,GAC5B2B,ED5FH,SAAuBC,GAC1B,MAAMC,KAAEA,EAAIhD,MAAEA,GAAU+C,EAAME,OAC9B,OAAOD,OAAOtB,EAAY1B,CAC9B,CCyFkBkD,CAAcL,GAC5B,GAAIC,EAAM,GAAI,CAQV,MAAO,CAPO,IAAIjE,EAAYiE,EAAM,IAAI,YACpC,IAAK,MAAMK,KAAcN,EACjBM,EAAW,WACLA,EAAW,GAGrC,SACuBzB,EAClB,CAED,MAAO,MAACA,EADeoB,EAAM,GAEjC,CCpJO,SAASjD,KAAUuD,GACtB,MAAMC,EAA8B,SAArBD,EAAQ,IAAI1C,KACrB4C,EAAUF,EAAQG,KAAI,EAAGhC,YAAaA,IACtCA,EAAS3B,OAAOC,OAAO,CAAA,KAAOyD,GACpC,OAAOD,EC+YJ,SAAc9B,GACjB,MAAMiC,EAAO5D,OAAO4D,KAAKjC,GACzB,OAAO,IAAIgB,EAAO,CACd7B,KAAM,OACNa,SACAS,SAAShC,GACL,GAAID,EAASC,GACT,IAAK,MAAMyD,KAAKD,OACN,CAACC,EAAGzD,EAAMyD,GAAIlC,EAAOkC,GAGtC,EACD7B,UAAU5B,GACED,EAASC,IAAW,qCAAoCC,EAAMD,KAE1EsB,QAAQtB,GACGD,EAASC,GAAS,IAAKA,GAAUA,GAGpD,CDlaoBU,CAAKa,GAAUmC,EAAOnC,EAC1C,CAQO,SAASoC,EAAO7D,EAAM8B,GACzB,OAAO,IAAIW,EAAO,CAAE7B,KAAMZ,EAAMyB,OAAQ,KAAMK,aAClD,CAkEO,SAASgC,EAAKC,GACjB,IAAIrD,EACJ,OAAO,IAAI+B,EAAO,CACd7B,KAAM,OACNa,OAAQ,KACRS,SAAShC,EAAO8D,GACZtD,IAAWA,EAASqD,WACbrD,EAAOwB,QAAQhC,EAAO8D,EAChC,EACDlC,UAASA,CAAC5B,EAAO8D,KACbtD,IAAWA,EAASqD,KACbrD,EAAOoB,UAAU5B,EAAO8D,IAEnCxC,QAAOA,CAACtB,EAAO8D,KACXtD,IAAWA,EAASqD,KACbrD,EAAOc,QAAQtB,EAAO8D,IAEjCxB,QAAOA,CAACtC,EAAO8D,KACXtD,IAAWA,EAASqD,KACbrD,EAAO8B,QAAQtC,EAAO8D,KAGzC,CC3FO,SAASC,EAAMC,GAClB,OAAO,IAAIzB,EAAO,CACd7B,KAAM,QACNa,OAAQyC,EACRhC,SAAShC,GACL,GAAIgE,GAAWxC,MAAMC,QAAQzB,GACzB,IAAK,MAAOiE,EAAOC,KAAelE,EAAMgC,eAC9B,CAACiC,EAAOC,EAAYF,EAGrC,EACD1C,QAAQtB,GACGwB,MAAMC,QAAQzB,GAASA,EAAMmE,QAAUnE,EAElD4B,UAAU5B,GACEwB,MAAMC,QAAQzB,IACjB,0CAAyCC,EAAMD,MAGhE,CAgBO,SAASoE,IACZ,OAAOT,EAAO,WAAY3D,GACE,kBAAVA,GAEtB,CA4GO,SAASqE,EAAQC,GACpB,MAAMC,EAActE,EAAMqE,GACpBE,SAAmBF,EACzB,OAAO,IAAI/B,EAAO,CACd7B,KAAM,UACNa,OAAsB,WAAdiD,GACU,WAAdA,GACc,YAAdA,EACEF,EACA,KACN1C,UAAU5B,GACEA,IAAUsE,GACb,0BAAyBC,sBAAgCtE,EAAMD,MAGhF,CAmCO,SAASyE,IACZ,OAAOd,EAAO,SAAS,KAAM,GACjC,CAOO,SAASe,EAASlE,GACrB,OAAO,IAAI+B,EAAO,IACX/B,EACHoB,UAAWA,CAAC5B,EAAO8D,IAAkB,OAAV9D,GAAkBQ,EAAOoB,UAAU5B,EAAO8D,GACrExB,QAASA,CAACtC,EAAO8D,IAAkB,OAAV9D,GAAkBQ,EAAO8B,QAAQtC,EAAO8D,IAEzE,CAMO,SAASa,IACZ,OAAOhB,EAAO,UAAW3D,GACK,iBAAVA,IAAuB4E,MAAM5E,IACxC,oCAAmCC,EAAMD,MAEtD,CAUO,SAAS0D,EAAOnC,GACnB,MAAMsD,EAAStD,EAAS3B,OAAO4D,KAAKjC,GAAU,GACxCuD,EAAQL,IACd,OAAO,IAAIlC,EAAO,CACd7B,KAAM,SACNa,OAAQA,GAAU,KAClBS,SAAShC,GACL,GAAIuB,GAAUxB,EAASC,GAAQ,CAC3B,MAAM+E,EAAW,IAAI3C,IAAIxC,OAAO4D,KAAKxD,IACrC,IAAK,MAAMY,KAAOiE,EACdE,EAASC,OAAOpE,QACV,CAACA,EAAKZ,EAAMY,GAAMW,EAAOX,IAEnC,IAAK,MAAMA,KAAOmE,OACR,CAACnE,EAAKZ,EAAMY,GAAMkE,EAE/B,CACJ,EACDlD,UAAU5B,GACED,EAASC,IAAW,qCAAoCC,EAAMD,KAE1EsB,QAAQtB,GACGD,EAASC,GAAS,IAAKA,GAAUA,GAGpD,CAOO,SAASiF,EAASzE,GACrB,OAAO,IAAI+B,EAAO,IACX/B,EACHoB,UAAWA,CAAC5B,EAAO8D,SAAkBpC,IAAV1B,GAAuBQ,EAAOoB,UAAU5B,EAAO8D,GAC1ExB,QAASA,CAACtC,EAAO8D,SAAkBpC,IAAV1B,GAAuBQ,EAAO8B,QAAQtC,EAAO8D,IAE9E,CAeO,SAASoB,EAAOC,EAAKC,GACxB,OAAO,IAAI7C,EAAO,CACd7B,KAAM,SACNa,OAAQ,KACRS,SAAShC,GACL,GAAID,EAASC,GAET,IAAK,MAAMqF,KAAarF,EAAO,CAC3B,MAAMsF,EAActF,EAAMqF,QACpB,CAACA,EAAWA,EAAWF,QACvB,CAACE,EAAWC,EAAaF,EAClC,CAER,EACDxD,UAAU5B,GACED,EAASC,IAAW,qCAAoCC,EAAMD,MAGlF,CA8CO,SAASuF,IACZ,OAAO5B,EAAO,UAAW3D,GACI,iBAAVA,GACV,oCAAmCC,EAAMD,MAEtD,CAQO,SAAS8C,EAAMM,GAClB,MAAM0B,EAAQL,IACd,OAAO,IAAIlC,EAAO,CACd7B,KAAM,QACNa,OAAQ,KACRS,SAAShC,GACL,GAAIwB,MAAMC,QAAQzB,GAAQ,CACtB,MAAMR,EAASgG,KAAKC,IAAIrC,EAAQ5D,OAAQQ,EAAMR,QAC9C,IAAK,IAAIkG,EAAI,EAAGA,EAAIlG,EAAQkG,SAClB,CAACA,EAAG1F,EAAM0F,GAAItC,EAAQsC,IAAMZ,EAEzC,CACJ,EACDlD,UAAU5B,GACEwB,MAAMC,QAAQzB,IACjB,oCAAmCC,EAAMD,MAG1D,CAqCO,SAAS2F,EAAMvC,GAClB,MAAMmB,EAAcnB,EAAQG,KAAK/C,GAAWA,EAAOE,OAAMjB,KAAK,OAC9D,OAAO,IAAI8C,EAAO,CACd7B,KAAM,QACNa,OAAQ,KACRD,QAAQtB,GACJ,IAAK,MAAM4F,KAAexC,EAAS,CAC/B,MAAOyC,EAAOC,GAAWF,EAAYhD,SAAS5C,EAAO,CAAEoB,QAAQ,IAC/D,IAAKyE,EACD,OAAOC,CAEd,CACD,OAAO9F,CACV,EACD4B,UAAU5B,EAAO8D,GACb,MAAM7E,EAAW,GACjB,IAAK,MAAM2G,KAAexC,EAAS,CAC/B,SAAUP,GAAU3B,EAAIlB,EAAO4F,EAAa9B,IACrCiC,GAASlD,EAChB,IAAKkD,IAAQ,GACT,MAAO,GAEX,IAAK,MAAO/G,KAAY6D,EAChB7D,GACAC,EAAS+G,KAAKhH,EAGzB,CACD,MAAO,CACF,8CAA6CuF,sBAAgCtE,EAAMD,QACjFf,EAEV,GAET,CAMO,SAASgH,IACZ,OAAOtC,EAAO,WAAW,KAAM,GACnC,CCpYO,SAASuC,EAAQ1F,EAAQ2F,GAC5B,OAAOC,EAAO5F,EAAQ,WAAYR,GACtBmG,EAAOE,KAAKrG,IACf,cAAaQ,EAAOE,oBAAoByF,EAAOG,2BAA2BtG,MAEvF,CA8CO,SAASoG,EAAO5F,EAAQV,EAAMwC,GACjC,OAAO,IAAIC,EAAO,IACX/B,EACH8B,SAAStC,EAAO8D,SACLtD,EAAO8B,QAAQtC,EAAO8D,GAC7B,MACM7E,EAAW4B,EADFyB,EAAQtC,EAAO8D,GACMA,EAAKtD,EAAQR,GACjD,IAAK,MAAMhB,KAAWC,OACZ,IAAKD,EAAS2B,WAAYb,EAEvC,GAET,CC5HO,SAASC,EAASC,GACrB,OAAOuG,QAAQvG,IAA2B,iBAAVA,IAAuBwB,MAAMC,QAAQzB,EACzE,CAYO,MAAMwG,EAAcA,CAACC,EAAe3G,IAASF,OAAO8G,eAAeC,KAAKF,EAAe3G,GAkBvF,IAAI8G,EAuBJ,SAASC,EAAc7G,GAC1B,GAAqB,iBAAVA,GAAgC,OAAVA,EAC7B,OAAO,EAEX,IACI,IAAI8G,EAAQ9G,EACZ,KAAwC,OAAjCJ,OAAOmH,eAAeD,IACzBA,EAAQlH,OAAOmH,eAAeD,GAElC,OAAOlH,OAAOmH,eAAe/G,KAAW8G,CAC3C,CACD,MAAOE,GACH,OAAO,CACV,CACL,CC9EA,SAASC,EAAqCpB,GAE1C,OC6BG,SAAyBA,GAC5B,OAvBG,SAA4BA,GAC/B,MAAwB,iBAAVA,GAAgC,OAAVA,GAAkB,YAAaA,CACvE,CAqBQqB,CAAmBrB,IAAmC,iBAAlBA,EAAM1G,QACnC0G,EAAM1G,QFjCVa,MEmCe6F,EACX,GAEJsB,OAAOtB,EAClB,CDrCWuB,CAAgBvB,GAAOwB,QAAQ,OAAQ,GAClD,CASA,SAASC,EAASC,EAAcpI,GAC5B,OA3BqB0E,EA2BD0D,EAzBbhB,QAAoD,iBAArC1C,GAAI2D,WAAWzI,aAAae,MA0BvC,IAAIyH,EAAa,CACpBpI,YAGDoI,EAAa,CAChBpI,YAjCR,IAAyB0E,CAmCzB,EDqBA,SAAW+C,GACPA,EAASA,EAAe,KAAI,GAAK,OACjCA,EAASA,EAAgB,MAAI,GAAK,QAClCA,EAASA,EAAkB,QAAI,GAAK,UACpCA,EAASA,EAAe,KAAI,GAAK,OACjCA,EAASA,EAAgB,MAAI,GAAK,QAClCA,EAASA,EAAgB,MAAI,GAAK,QAClCA,EAASA,EAAgB,MAAI,GAAK,QAElCA,EAASA,EAAe,KAAI,IAAM,MACrC,CAVD,CAUGA,EAAWA,IAAaA,EAAW,CAAA,IC3B/B,MAAMa,UAAuBC,MAChC3I,YAAYoC,GACRzB,MAAMyB,EAAQhC,SACdQ,KAAKgI,KAAO,eACf,EEhDoBzB,EAAQX,IAAU,wBACZW,EAAQX,IAAU,mBACjBW,EAAQX,IAAU,qBAC3C,MAAMqC,EAA2B1B,EAAQX,IAAU,wBCG7C7B,EAAUnC,GAIvBsG,EAAkBtG,GASlB,SAASuG,GAAYxI,KAAEA,EAAImB,OAAEA,IACzB,MAAMsH,EAAQzI,EAAKA,EAAKE,OAAS,GACjC,OAAOgH,EAAY/F,EAAOA,EAAOjB,OAAS,GAAIuI,EAClD,CA6BO,SAASC,EAAcxH,GAC1B,OAAO,IAAI+B,EAAO,IACX/B,EACHE,KAAO,YAAWF,EAAOE,OACzBkB,UAAWA,CAAC5B,EAAOO,KAAauH,EAAYvH,IAAYC,EAAOoB,UAAU5B,EAAOO,GAChF+B,QAASA,CAACtC,EAAOO,KAAauH,EAAYvH,IAAYC,EAAO8B,QAAQtC,EAAOO,IAEpF,CAOA,MASa0H,EAAmBtC,EAAM,CAClCtB,EAAQ,MACRD,IAXuBT,EAAO,iBAAkB3D,GACzC2C,EAAG3C,EAAO2E,MAAauD,OAAOC,SAASnI,KAY9CuF,IACAxB,EAAMH,GAAK,IAAMqE,KACjB/C,EAAOK,IAAU3B,GAAK,IAAMqE,OAQnBG,GCzEU5H,EDyEUyH,ECzEFI,EPVpB1E,EAAO,OAAO,KAAM,IOUWrC,EDyEiBtB,IHLpD,SAAsBA,EAAOQ,EAAQ8H,EAAc,mBAE1Df,EAAeE,GACX,IACIc,EAAkBvI,EAAOQ,EAC5B,CACD,MAAOqF,GACH,MAAMyB,EAASC,EAAe,GAAEe,MAAgBrB,EAAqCpB,MACxF,CACL,CGHI2C,CAAaxI,EAAOiI,GACb9H,KAAKsI,MAAMtI,KAAKC,UAAUJ,GAAO,CAAC0I,EAASC,KAE9C,GAAgB,cAAZD,GAAuC,gBAAZA,EAG/B,OAAOC,CAAS,MC/Eb,IAAIpG,EAAO,IACX/B,EACHc,QAASA,CAACtB,EAAO8D,IACNnB,EAAG3C,EAAOqI,GACX7H,EAAOc,QAAQA,EAAQtB,EAAO8D,GAAMA,GACpCtD,EAAOc,QAAQtB,EAAO8D,MANjC,IAAgBtD,EAAQ6H,EAAW/G,ED0FnC,SAASsH,EAAY5I,GACxB,IAEI,OAkBD,SAAqBA,GACjB0C,EAAO1C,EAAOoI,EACzB,CArBQS,CAAY7I,IACL,CACV,CACD,MACI,OAAO,CACV,CACL,CA8BO,MACM8I,EAAuBzE,EADZ,OAEX0E,EAAkBrE,EAASiB,EAAM,CAAChB,IAAUY,OAC5CyD,EAAqBtF,EAAO,CACrCiE,KNtBOhE,EAAO,WAAY3D,GACI,iBAAVA,IAAuB4E,MAAM5E,IAAUkI,OAAOe,UAAUjJ,IACnE,sCAAqCC,EAAMD,OMqBpDb,QAASoG,IACT2D,KAAMlB,EAAcI,GACpBe,MAAOnB,EAAczC,OAEZ6D,EAAsBzD,EAAM,CAACT,EAAOK,IAAU6C,GAAarE,EAAMqE,KAC1C1E,EAAO,CACvC2F,GAAIN,EACJO,QAASR,EACTS,OAAQhE,IACRiE,OAAQxB,EAAcoB,KAEe1F,EAAO,CAC5C4F,QAASR,EACTS,OAAQhE,IACRiE,OAAQxB,EAAcoB,KA+CkBvB,EAAkB,CAC1DwB,GAAIN,EACJO,QAASR,EACTxI,OAAQ2E,EAASgB,KACjBJ,MAAOZ,EAAS+D,KAYiBrD,EAAM,CAVPjC,EAAO,CACvC2F,GAAIN,EACJO,QAASR,EACTxI,OAAQ8H,IAEwB1E,EAAO,CACvC2F,GAAIN,EACJO,QAASR,EACTjD,MAAOmD,MElOX,IAAIS,EACG,CACHC,cAAe,KACfC,kBAAmB,MACnBC,qBAAsB,MACtBC,qBAAsB,MACtBC,oBAAqB,MACrBC,eAAgB,MAChBtB,OAAQ,MACRuB,gBAAiB,MACjBC,gBAAiB,MACjBC,eAAgB,MAChBC,UAAW,OAUXC,EAAc,CAChB,SAAU,CACRC,SAAU,eACVlL,QAAS,yGAEX,SAAU,CACRkL,SAAU,eACVlL,QAAS,gDAEX,SAAU,CACRkL,SAAU,eACVlL,QAAS,iDAEX,SAAU,CACRkL,SAAU,eACVlL,QAAS,gCAEX,SAAU,CACRkL,SAAU,eACVlL,QAAS,4BAEX,SAAU,CACRkL,SAAU,WACVlL,QAAS,kBAEX,SAAU,CACRkL,SAAU,WACVlL,QAAS,uBAEX,SAAU,CACRkL,SAAU,WACVlL,QAAS,yBAEX,SAAU,CACRkL,SAAU,WACVlL,QAAS,yBAEX,SAAU,CACRkL,SAAU,WACVlL,QAAS,yBAEX,SAAU,CACRkL,SAAU,WACVlL,QAAS,2BAEX,KAAQ,CACNkL,SAAU,WACVlL,QAAS,8BAEX,KAAQ,CACNkL,SAAU,WACVlL,QAAS,4EAEX,KAAQ,CACNkL,SAAU,WACVlL,QAAS,oEAEX,KAAQ,CACNkL,SAAU,WACVlL,QAAS,iDAEX,KAAQ,CACNkL,SAAU,WACVlL,QAAS,2DC1ETmL,EAAsBb,EAAeU,SACrCI,EAAmB,8DAGZC,GAAmBF,GAE9B,IAAIG,GAAgC,4BACpC,SAASD,GAAmB7C,EAAM+C,EAAkBH,GAClD,GAWF,SAAqB5C,GACnB,OAAOO,OAAOe,UAAUtB,EAC1B,CAbMgD,CAAYhD,GAAO,CACrB,MAAMiD,EAAajD,EAAKzH,WACxB,GAAIsG,EAAY4D,EAAaQ,GAC3B,OAAOR,EAAYQ,GAAYzL,QAEjC,GAmCJ,SAA8BwI,GAC5B,OAAOA,IAAS,OAASA,IAAS,IACpC,CArCQkD,CAAqBlD,GACvB,OAAO8C,EAEV,CACD,OAAOC,CACT,CAmDA,SAASI,GAAgBpH,GACvB,OAAO9D,OAAOmL,oBAAoBrH,GAAQsH,QACxC,CAACC,EAAKrK,KACJ,MAAMZ,EAAQ0D,EAAO9C,GAIrB,OAHIgI,EAAY5I,KACdiL,EAAIrK,GAAOZ,GAENiL,CAAG,GAEZ,CAAE,EAEN,CC5FA,IAAAC,GAAiB9K,GACjBA,GAAU+K,QAAU/K,GACpBA,GAAUgL,OAASC,GACnBjL,GAAUkL,gBAAkBD,GAE5B,IAAIE,GAAqB,QACrBC,GAAwB,aAExBC,GAAM,GACNC,GAAgB,GAEpB,SAASC,KACP,MAAO,CACLC,WAAY1D,OAAO2D,iBACnBC,WAAY5D,OAAO2D,iBAEvB,CAGA,SAASzL,GAAW2L,EAAKC,EAAUC,EAAQ9K,GAMzC,IAAI+K,OALmB,IAAZ/K,IACTA,EAAUwK,MAGZQ,GAAOJ,EAAK,GAAI,EAAG,QAAIrK,EAAW,EAAGP,GAErC,IAEI+K,EAD2B,IAAzBR,GAAclM,OACVW,KAAKC,UAAU2L,EAAKC,EAAUC,GAE9B9L,KAAKC,UAAU2L,EAAKK,GAAoBJ,GAAWC,EAE5D,CAAC,MAAOjF,GACP,OAAO7G,KAAKC,UAAU,sEAC1B,CAAY,QACR,KAAsB,IAAfqL,GAAIjM,QAAc,CACvB,IAAI6M,EAAOZ,GAAIa,MACK,IAAhBD,EAAK7M,OACPI,OAAO2M,eAAeF,EAAK,GAAIA,EAAK,GAAIA,EAAK,IAE7CA,EAAK,GAAGA,EAAK,IAAMA,EAAK,EAE3B,CACF,CACD,OAAOH,CACT,CAEA,SAASM,GAAYnF,EAASoF,EAAKhJ,EAAGiJ,GACpC,IAAIC,EAAqB/M,OAAOgN,yBAAyBF,EAAQjJ,QAClC/B,IAA3BiL,EAAmBE,IACjBF,EAAmBG,cACrBlN,OAAO2M,eAAeG,EAAQjJ,EAAG,CAAEzD,MAAOqH,IAC1CoE,GAAIzF,KAAK,CAAC0G,EAAQjJ,EAAGgJ,EAAKE,KAE1BjB,GAAc1F,KAAK,CAACyG,EAAKhJ,EAAG4D,KAG9BqF,EAAOjJ,GAAK4D,EACZoE,GAAIzF,KAAK,CAAC0G,EAAQjJ,EAAGgJ,IAEzB,CAEA,SAASN,GAAQM,EAAKhJ,EAAGsJ,EAAW5D,EAAOuD,EAAQM,EAAO7L,GAExD,IAAIuE,EACJ,GAFAsH,GAAS,EAEU,iBAARP,GAA4B,OAARA,EAAc,CAC3C,IAAK/G,EAAI,EAAGA,EAAIyD,EAAM3J,OAAQkG,IAC5B,GAAIyD,EAAMzD,KAAO+G,EAEf,YADAD,GAAWhB,GAAuBiB,EAAKhJ,EAAGiJ,GAK9C,QACgC,IAAvBvL,EAAQyK,YACfoB,EAAQ7L,EAAQyK,WAGhB,YADAY,GAAWjB,GAAoBkB,EAAKhJ,EAAGiJ,GAIzC,QACgC,IAAvBvL,EAAQ2K,YACfiB,EAAY,EAAI5L,EAAQ2K,WAGxB,YADAU,GAAWjB,GAAoBkB,EAAKhJ,EAAGiJ,GAMzC,GAFAvD,EAAMnD,KAAKyG,GAEPjL,MAAMC,QAAQgL,GAChB,IAAK/G,EAAI,EAAGA,EAAI+G,EAAIjN,OAAQkG,IAC1ByG,GAAOM,EAAI/G,GAAIA,EAAGA,EAAGyD,EAAOsD,EAAKO,EAAO7L,OAErC,CACL,IAAIqC,EAAO5D,OAAO4D,KAAKiJ,GACvB,IAAK/G,EAAI,EAAGA,EAAIlC,EAAKhE,OAAQkG,IAAK,CAChC,IAAI9E,EAAM4C,EAAKkC,GACfyG,GAAOM,EAAI7L,GAAMA,EAAK8E,EAAGyD,EAAOsD,EAAKO,EAAO7L,EAC7C,CACF,CACDgI,EAAMmD,KACP,CACH,CAGA,SAASW,GAAiBC,EAAGC,GAC3B,OAAID,EAAIC,GACE,EAEND,EAAIC,EACC,EAEF,CACT,CAEA,SAAS9B,GAAwBU,EAAKC,EAAUC,EAAQ9K,QAC/B,IAAZA,IACTA,EAAUwK,MAGZ,IACIO,EADAkB,EAAMC,GAAoBtB,EAAK,GAAI,EAAG,QAAIrK,EAAW,EAAGP,IAAY4K,EAExE,IAEIG,EAD2B,IAAzBR,GAAclM,OACVW,KAAKC,UAAUgN,EAAKpB,EAAUC,GAE9B9L,KAAKC,UAAUgN,EAAKhB,GAAoBJ,GAAWC,EAE5D,CAAC,MAAOjF,GACP,OAAO7G,KAAKC,UAAU,sEAC1B,CAAY,QAER,KAAsB,IAAfqL,GAAIjM,QAAc,CACvB,IAAI6M,EAAOZ,GAAIa,MACK,IAAhBD,EAAK7M,OACPI,OAAO2M,eAAeF,EAAK,GAAIA,EAAK,GAAIA,EAAK,IAE7CA,EAAK,GAAGA,EAAK,IAAMA,EAAK,EAE3B,CACF,CACD,OAAOH,CACT,CAEA,SAASmB,GAAqBZ,EAAKhJ,EAAGsJ,EAAW5D,EAAOuD,EAAQM,EAAO7L,GAErE,IAAIuE,EACJ,GAFAsH,GAAS,EAEU,iBAARP,GAA4B,OAARA,EAAc,CAC3C,IAAK/G,EAAI,EAAGA,EAAIyD,EAAM3J,OAAQkG,IAC5B,GAAIyD,EAAMzD,KAAO+G,EAEf,YADAD,GAAWhB,GAAuBiB,EAAKhJ,EAAGiJ,GAI9C,IACE,GAA0B,mBAAfD,EAAIa,OACb,MAEH,CAAC,MAAOtG,GACP,MACD,CAED,QACgC,IAAvB7F,EAAQyK,YACfoB,EAAQ7L,EAAQyK,WAGhB,YADAY,GAAWjB,GAAoBkB,EAAKhJ,EAAGiJ,GAIzC,QACgC,IAAvBvL,EAAQ2K,YACfiB,EAAY,EAAI5L,EAAQ2K,WAGxB,YADAU,GAAWjB,GAAoBkB,EAAKhJ,EAAGiJ,GAMzC,GAFAvD,EAAMnD,KAAKyG,GAEPjL,MAAMC,QAAQgL,GAChB,IAAK/G,EAAI,EAAGA,EAAI+G,EAAIjN,OAAQkG,IAC1B2H,GAAoBZ,EAAI/G,GAAIA,EAAGA,EAAGyD,EAAOsD,EAAKO,EAAO7L,OAElD,CAEL,IAAIiM,EAAM,CAAA,EACN5J,EAAO5D,OAAO4D,KAAKiJ,GAAKc,KAAKN,IACjC,IAAKvH,EAAI,EAAGA,EAAIlC,EAAKhE,OAAQkG,IAAK,CAChC,IAAI9E,EAAM4C,EAAKkC,GACf2H,GAAoBZ,EAAI7L,GAAMA,EAAK8E,EAAGyD,EAAOsD,EAAKO,EAAO7L,GACzDiM,EAAIxM,GAAO6L,EAAI7L,EAChB,CACD,QAAsB,IAAX8L,EAIT,OAAOU,EAHP3B,GAAIzF,KAAK,CAAC0G,EAAQjJ,EAAGgJ,IACrBC,EAAOjJ,GAAK2J,CAIf,CACDjE,EAAMmD,KACP,CACH,CAIA,SAASF,GAAqBJ,GAO5B,OANAA,OACsB,IAAbA,EACHA,EACA,SAAUvI,EAAG+J,GACb,OAAOA,GAEN,SAAU5M,EAAK6L,GACpB,GAAIf,GAAclM,OAAS,EACzB,IAAK,IAAIkG,EAAI,EAAGA,EAAIgG,GAAclM,OAAQkG,IAAK,CAC7C,IAAI2G,EAAOX,GAAchG,GACzB,GAAI2G,EAAK,KAAOzL,GAAOyL,EAAK,KAAOI,EAAK,CACtCA,EAAMJ,EAAK,GACXX,GAAc+B,OAAO/H,EAAG,GACxB,KACD,CACF,CAEH,OAAOsG,EAASrF,KAAKhH,KAAMiB,EAAK6L,GAEpC,oGC5NIiB,GAAe,cAAchG,MAC/B3I,YAAY4I,EAAMxI,EAAS+J,GACzB,IAAIyE,EAAUA,IAAIC,KAChBlO,SAASkO,EAAK,EAEhB,IAAK1F,OAAOe,UAAUtB,GACpB,MAAM,IAAID,MAAM,8BAElB,IAAKvI,GAA8B,iBAAZA,EACrB,MAAM,IAAIuI,MAAM,0CF4EtB,SAAsBwB,GACpB,OAAOnJ,EAASmJ,IAAS1C,EAAY0C,EAAM,UAAYnJ,EAASmJ,EAAK3J,MACvE,CE5EQsO,CAAa3E,GAMfyE,EAAQxO,IALRwO,EAAQxO,EAAS,CAAEI,MAAO2J,EAAK3J,QAC1BiH,EAAY7G,KAAM,UACrBC,OAAOC,OAAOF,KAAM,CAAEJ,MAAO2J,EAAK3J,cAKzB,IAAT2J,IACFvJ,KAAKuJ,KAAOA,GAEdvJ,KAAKgI,KAAOA,CACb,CAMDmG,YACE,MAAMC,EAAa,CACjBpG,KAAMhI,KAAKgI,KACXxI,QAASQ,KAAKR,SFuBpB,IAAwB0G,EEZpB,YATkB,IAAdlG,KAAKuJ,OACP6E,EAAW7E,KAAOvJ,KAAKuJ,KACnBrC,EAAclH,KAAKuJ,QACrB6E,EAAW7E,KAAK3J,OFkBAsG,EElBuBlG,KAAKuJ,KAAK3J,MFmBnDiC,MAAMC,QAAQoE,GACTA,EAAMtC,KAAKyK,GACZpF,EAAYoF,GACPA,EACEjO,EAASiO,GACXlD,GAAgBkD,GAElB,OAEAjO,EAAS8F,GACXiF,GAAgBjF,GAErB+C,EAAY/C,GACPA,EAEF,QE/BDlG,KAAKwJ,QACP4E,EAAW5E,MAAQxJ,KAAKwJ,OAEnB4E,CACR,CAOD7N,WACE,OAAO+N,GAActO,KAAKmO,YAAaI,GAAmB,EAC3D,GAuBH,SAASA,GAAkBlH,EAAGhH,GAC5B,GAAc,eAAVA,EAGJ,OAAOA,CACT,CC7EA,IAAImO,GA4BeC,GAAQC,GAAgB5E,EAAeQ,eAAgBmE,GA0I1E,SAASC,GAAgB1G,EAAMyG,GAC7B,MAAOjP,EAAS+J,GAWlB,SAAmBkF,GACjB,GAAIA,EAAK,CACP,GAAmB,iBAARA,EACT,MAAO,CAACA,GACH,GAAmB,iBAARA,IAAqB5M,MAAMC,QAAQ2M,GAAM,CACzD,MAAMjP,QAAEA,EAAO+J,KAAEA,GAASkF,EAC1B,GAAIjP,GAA8B,iBAAZA,EACpB,MAAM,IAAIuI,MAAM,gCAElB,MAAO,CAACvI,QAAW,EAAQ+J,EAC5B,CACF,CACD,MAAO,EACT,CAxB0BoF,CAAUF,GAClC,OAAO,IAAIV,GAAa/F,EAAMxI,GAAWqL,GAAmB7C,GAAOuB,EACrE,CCrLA,IAoBIqF,GAAOC,GAAUC,GAAOC,GApBxBC,GAAgBA,CAAC5C,EAAK6C,EAAQC,KAChC,IAAKD,EAAOE,IAAI/C,GACd,MAAMjN,UAAU,UAAY+P,EAAI,EAEhCE,GAAeA,CAAChD,EAAK6C,EAAQI,KAC/BL,GAAc5C,EAAK6C,EAAQ,2BACpBI,EAASA,EAAOrI,KAAKoF,GAAO6C,EAAO/B,IAAId,IAE5CkD,GAAeA,CAAClD,EAAK6C,EAAQ5O,KAC/B,GAAI4O,EAAOE,IAAI/C,GACb,MAAMjN,UAAU,qDAClB8P,aAAkBM,QAAUN,EAAOvM,IAAI0J,GAAO6C,EAAOzM,IAAI4J,EAAK/L,EAAM,EAElEmP,GAAeA,CAACpD,EAAK6C,EAAQ5O,EAAOoP,KACtCT,GAAc5C,EAAK6C,EAAQ,0BAC3BQ,EAASA,EAAOzI,KAAKoF,EAAK/L,GAAS4O,EAAOzM,IAAI4J,EAAK/L,GAC5CA,GAKLqP,GAAY,cAAc3H,MAa5B3I,YAAY8G,EAAOqD,EAAO,IACxB,MAAM/J,EA6HV,SAAyB0G,GACvB,GAAI9F,EAAS8F,IAAUW,EAAYX,EAAO,YAAuC,iBAAlBA,EAAM1G,QACnE,OAAO0G,EAAM1G,QAEf,OAAOgI,OAAOtB,EAChB,CAlIoBuB,CAAgBvB,GAChCnG,MAAMP,GACN8P,GAAatP,KAAM4O,QAAO,GAC1BU,GAAatP,KAAM6O,QAAU,GAC7BS,GAAatP,KAAM8O,QAAO,GAC1BQ,GAAatP,KAAM+O,QAAQ,GAC3BS,GAAaxP,KAAM6O,GAAUrP,GAC7BgQ,GAAaxP,KAAM4O,GAkIvB,SAAsB1I,GACpB,GAAI9F,EAAS8F,IAAUW,EAAYX,EAAO,SAAiC,iBAAfA,EAAM8B,MAAqBO,OAAOe,UAAUpD,EAAM8B,MAC5G,OAAO9B,EAAM8B,KAEf,OAAQ,KACV,CAvI8B2H,CAAazJ,IACvC,MAAM0J,EAAa,IAAKC,GAAa3J,MAAWqD,GAC5CtJ,OAAO4D,KAAK+L,GAAY/P,OAAS,GACnC2P,GAAaxP,KAAM8O,GAAOc,GAE5BJ,GAAaxP,KAAM+O,GAAQhP,MAAMyJ,MAClC,CAMGrJ,WACF,MAAO,WACR,CAMG6H,WACF,OAAOoH,GAAapP,KAAM4O,GAC3B,CAQGpP,cACF,OAAO4P,GAAapP,KAAM6O,GAC3B,CAMGtF,WACF,OAAO6F,GAAapP,KAAM8O,GAC3B,CAQGtF,YACF,OAAO4F,GAAapP,KAAM+O,GAC3B,CAMDpB,SACE,MAAO,CACL3F,KAAM8H,GACNtQ,QAASuQ,GACTxG,KAAM,CACJ3J,MAAO,CACLoI,KAAMhI,KAAKgI,KACXxI,QAASQ,KAAKR,QACdgK,MAAOxJ,KAAKwJ,SACTxJ,KAAKuJ,KAAO,CAAEA,KAAMvJ,KAAKuJ,MAAS,CAAE,IAI9C,CAOD4E,YACE,OAAOnO,KAAK2N,QACb,GAEHiB,GAAQ,IAAIoB,QACZnB,GAAW,IAAImB,QACflB,GAAQ,IAAIkB,QACZjB,GAAS,IAAIiB,QAiCb,IAAIF,IAAmB,MACnBC,GAAqB,aAmBzB,SAASF,GAAa3J,GACpB,OAAI9F,EAAS8F,IAAUW,EAAYX,EAAO,SAAiC,iBAAfA,EAAMqD,MAAoC,OAAfrD,EAAMqD,MAAiBN,EAAY/C,EAAMqD,QAAU1H,MAAMC,QAAQoE,EAAMqD,MACrJrD,EAAMqD,KAER,EACT,CAWA,SAAS7E,GAAQrE,GACf,OAAO2D,EACLxD,KAAKC,UAAUJ,GACf4P,EAAmB5P,GAAO4B,UAE9B,CAWA,SAASiO,GAAUvL,GACjB,OAAOD,GAAQC,EACjB,CACA,SAASwL,GAAWC,GAClB,OAAO,IAAIxN,EAAO,CAChB7B,KAAM,QACNa,OAAQ,KACRS,SAAShC,EAAOO,GACd,IAAKsG,EAAc7G,KAAWgQ,EAAahQ,EAAO,QAChD,OAEF,MAAMU,KAAEA,GAASV,EACXQ,EAASuP,EAAQE,MAAK,EAAG1O,YAAaoB,EAAGjC,EAAMa,EAAOb,QAC5D,GAAKF,EAGL,IAAK,MAAMwN,KAASxN,EAAOwB,QAAQhC,EAAOO,SAClCyN,CAET,EACDpM,UAAU5B,EAAOO,GACf,MAAM2P,EAAQH,EAAQxM,KAAI,EAAGhC,YAAaA,EAAOb,KAAKA,OACtD,IAAKmG,EAAc7G,KAAWgQ,EAAahQ,EAAO,SAAiC,iBAAfA,EAAMU,KACxE,MAAQ,+BAA8BwP,EAAMzQ,KAC1C,iCAGJ,MAAMiB,KAAEA,GAASV,EACXQ,EAASuP,EAAQE,MAAK,EAAG1O,YAAaoB,EAAGjC,EAAMa,EAAOb,QAC5D,OAAIF,EACKA,EAAOoB,UAAU5B,EAAOO,GAEzB,+BAA8B2P,EAAMzQ,KAC1C,yBACmBiB,IACtB,GAEL,CAGA,SAASyP,GAAUJ,GACjB,OAnDF,UACEK,KACGC,IAEH,MAAM7P,EAAS8P,EAAiB,CAACF,KAASC,IAC1C,OAAO,IAAI9N,EAAO,IACb/B,EACHe,OAAQ,CAAC6O,KAASC,IAEtB,CA0CS1K,CAAMoK,EACf,CAIA,SAASQ,KACP,OAAOnK,EAAOb,IAAU,OAAQvF,KACzBA,EAAMwQ,SAAS,SACX,6BAIb,CAYA,IAnJyB3M,GAmJrB4M,IAnJqB5M,GAmJiBsK,GAlJjC,cAA+BkB,GAOpCtQ,YAAYI,EAAS+J,GACnB,GAAuB,iBAAZ/J,EAAsB,CAC/B,MAAMuR,EAAS7M,KAMf,YALAnE,MAAM,CACJiI,KAAM+I,EAAO/I,KACbxI,QAASuR,EAAOvR,QAChB+J,KAAM/J,GAGT,CACD,MAAM0G,EAAQhC,GAAG1E,GACjBO,MAAM,CACJiI,KAAM9B,EAAM8B,KACZxI,QAAS0G,EAAM1G,QACf+J,QAEH,IAuMDyH,GAAajN,EAAO,CACtBhD,KAAMkQ,MAEJC,GAAgBhR,EAClB8Q,GACAjN,EAAO,CACL1D,MAAOiG,OAKP6K,GAAgBC,EAClBF,GACAG,EAAQ,CACNtQ,KAAMuQ,EAAS,WACfjR,MAAO4H,KAgBPsJ,GAAiBC,EACnBN,GACAO,EAAQ,CACN1Q,KAAM2Q,EAAS,YACfrR,MAAOsR,IACPC,UAAWtM,EAASb,QAUpBoN,GAAgBC,EAClBd,GACAe,EAAQ,CACNhR,KAAMiR,EAAS,cAOfC,GAAgBC,EAClBhB,GACAiB,EAAQ,CACNpR,KAAMqR,EAAS,WACf/R,MAAOgS,OASPC,GAAcC,EAChBvB,GACAwB,EAAQ,CACNzR,KAAM0R,EAAS,SACfpS,MAAOuQ,QA2BP8B,GAAeC,EACjBzB,GACA0B,EAAQ,CACN7R,KAAM8R,EAAS,UACfxS,MAAOyS,IACPC,QAASC,EACPC,EAAO,CACL/C,GAAU,WACVA,GAAU,gBAGdgD,WAAYF,EACVC,EAAO,CAAC/C,GAAU,UAAwBA,GAAU,aAEtD/P,KAAM6S,EAAUF,QAmChBK,GAAcC,EAChBlC,GACAmC,EAAQ,CACNtS,KAAMuS,EAAS,SACfjT,MAAOkT,EAAUC,KACjBrT,KAAMqT,IACNC,UAAWF,EACTG,EAAO,CACLxD,GAAU,QACVA,GAAU,YACVA,GAAU,aAGdyD,YAAaJ,EAAUC,KACvBI,MAAOL,EAAUC,KACjBtN,MAAOqN,EAAUC,QAYjBK,GAAsBC,EAAO,CAACX,GAAaT,KAC3CqB,GAAaC,EACfhD,GACAiD,EAAQ,CACNlT,KAAMmT,EAAS,QACfC,SAAU/P,EAAMyP,IAChB1T,KAAMiU,OA2BNC,GAAaC,EACfpD,GACAqD,EAAS,CACPxT,KAAMyT,EAAU,QAChBnU,MAAOoU,IACPC,SAAUC,EAAUC,QAepBC,GAAqBC,EAAO,CAACxC,GAAa+B,GAAYlD,KACtD4D,GAAYC,EACd9D,GACA+D,EAAS,CACPlU,KAAMmU,EAAU,OAChBnC,QAASoC,EACPL,EAAO,CACL5E,GAAU,WACVA,GAAU,YACVA,GAAU,cAGd0D,MAAOwB,IACP/U,MAAOwU,MAWPQ,GAAgBC,EAClBtE,GACAuE,EAAS,CACPxU,KAAMyU,EAAU,cAMhBC,GAAeC,EACjB1E,GACA2E,EAAS,CAGPxB,SAAUyB,EAAO3R,GAAK,IAAM4R,SAU5BA,GAAkB1F,GAAW,CAC/BoB,GACAM,GACAI,GACAK,GAXgBoD,EAChBD,GACAE,EAAS,CACP5U,KAAM+U,EAAU,YAUlBT,GACAhB,GACAU,GACA5D,GACAgC,GACAY,GACArB,KAiFEqD,GAAqBC,EAAS,CAChCjV,KAAMkV,IACN9V,KAAM+V,EAAUD,OAEdE,GAAyBC,EAC3BL,GACAC,EAAS,CACPjV,KAAMsV,EAAU,oBAChBlW,KAAM+V,EAAUD,QAGhBK,GAAaN,EAAS,CACxB7V,KAAM8V,IACNM,KAAMvR,IACNwR,YAAaP,IACbQ,SAAUR,MAERS,GAAwBN,EAC1BL,GACAC,EAAS,CACPjV,KAAMsV,EAAU,mBAChBhW,MAAOkF,EAAO0Q,IAAYlR,EAAS4R,EAAO,CAACV,IAAYK,GAAYM,QACnEzW,KAAM8V,OAGNY,GAAyBT,EAC3BL,GACAC,EAAS,CACPjV,KAAMsV,EAAU,oBAChBlW,KAAM8V,IACN5V,MAAOsW,EAAO,CAACV,IAAYW,SAWJD,EAAO,CAChCR,GACAO,GACAG,GAX0BT,EAC1BL,GACAC,EAAS,CACPjV,KAAMsV,EAAU,mBAChBlW,KAAM8V,IACNa,KAAM/R,EAASuR,SAuEnB,IAAIS,GAAYvG,GAAU,CAACwG,IAAYC,MACnCC,GAAsB/C,GAAS,CACjC6C,MAcF,SAAS7C,GAAS/D,GAChB,OARF,SAAkBvP,GAChB,MAAMsW,EAAiB3G,GAAU,CAC/B3P,EACAuW,EAAOC,GAAM,IAAMF,OAErB,OAAOA,CACT,CAESG,CAASC,EAAU/G,GAAU,IAAIJ,EAASoH,OACnD,CACA,SAASC,GAAQtX,EAAM0C,EAAQ,IAC7B,OAAO6U,EAAS,CACd3W,KAAM2D,GAAQvE,GACd0C,MAAO6U,EAAS7U,GAChB5B,IAAKsW,EAAUR,KAEnB,CArBoBW,EAAS,CAC3B3W,KAAMiW,IACNnU,MAAO8U,EAAQX,IAAYvO,GAC3BxH,IAAKsW,EAAUR,MAmBjB,IAAIa,GAAgBH,GAAQ,SAAU,CACpCtD,SAAU+C,GACV/W,KAAM0X,EAAUb,KAChBjW,KAAM8W,EAAUrH,GAAU,CAAC9L,GAAQ,UAAWA,GAAQ,aACtDqO,QAAS8E,EAAUrH,GAAU,CAAC9L,GAAQ,WAAYA,GAAQ,kBAC1DoT,SAAUD,EAAUL,OAElBO,GAAiBN,GAAQ,WAAY,CACvCtX,KAAM6W,IACNgB,QAASH,EAAUL,KACnB5D,MAAOiE,EAAUb,KACjBjE,QAAS8E,EAAUrH,GAAU,CAAC9L,GAAQ,WAAYA,GAAQ,eAExDuT,GAAeR,GAAQ,QAAS,CAClCtX,KAAM6W,IACNjW,KAAM8W,EACJrH,GAAU,CAAC9L,GAAQ,QAASA,GAAQ,YAAaA,GAAQ,aAE3DrE,MAAOwX,EAAUb,KACjBrD,YAAakE,EAAUb,OAErBkB,GAAeT,GAAQ,SAAU,CACnCpX,MAAO2W,IACP7C,SAAU6C,MAERmB,GAAiBV,GAAQ,WAAY,CACvCtX,KAAM6W,IACN3W,MAAOwX,EAAUb,KACjB7C,SAAUA,GAAS,CAAC+D,OAElBE,GAAkBX,GACpB,YACA,CACEtX,KAAM6W,IACNqB,OAAQ7H,GAAU,CAACqH,EAAUT,EAAOJ,QACpCsB,QAAST,EAAUL,OAGnBe,GAAe,CAACN,GAAcL,IAC9BY,GAAuB,CACzBP,GACAE,GACAC,GACAL,IAE0BvH,GAAU,IACjCgI,MACAD,KAEL,IAAIE,GAAmBjI,GAAU,CAC/BrN,EAAMoV,OACHC,KAEDE,GAAcjB,GAAQ,QAAS,CACjC7D,MAAOiE,EAAUb,KACjB9Q,MAAO2R,EAAUb,KACjB7C,SAAUsE,KAMRE,GAAclB,GAAQ,OAAQ,CAChCtD,SALoBA,GAEpB,CAACuE,GAAarB,GAAM,IAAMuB,OAI1BzY,KAAM6W,MAEJ6B,GAAapB,GAAQ,OAAQ,CAC/BtD,SAAUA,GAAS,CACjB6C,IAEAK,GAAM,IAAMyB,SAGZA,GAAerB,GAAQ,SAAU,CACnCtD,SAAUA,GAAS,CACjB6C,IAEAK,GAAM,IAAMwB,SAGZE,GAAmBvI,GAAU,CAC/BqI,GACAC,KAEEE,GAAiBvB,GAAQ,UAAW,CACtCwB,QAASC,IAMPC,GAAY1B,GAAQ,MAAO,CAC7BtD,SALsBA,GAEtB,CAACkD,GAAM,IAAMuB,OAIbQ,UAAWvB,EAAUrH,GAAU,CAAC9L,GAAQ,cAAeA,GAAQ,eAC/D2U,UAAWxB,EACTrH,GAAU,CACR9L,GAAQ,SACRA,GAAQ,UACRA,GAAQ,OACRA,GAAQ,iBACRA,GAAQ,qBAQV4U,GAAe7B,GAAQ,SAAU,CACnCtD,SALsB3D,GAAU,CAChCrN,EAAM,CAACyU,GAAeA,KACtBA,OASE2B,GAAkB9B,GACpB,YACA,CACEtD,SAPuB3D,GAAU,CACnCrN,EAAM,CAACgW,GAAWG,KAClBH,OAQEK,GAAkB/B,GAAQ,WAAY,CACxCpX,MAAO2W,IACPpF,UAAWiG,EAAUL,OAEnBiC,GAAiBhC,GAAQ,WACzBiC,GAAcjC,GAAQ,QAAS,CACjCpX,MAAO2W,IACP2C,MAAO3C,MAEL4C,GAAanC,GAAQ,OAAQ,CAC/BoC,MAAOhC,EAAUb,KACjB8C,MAAO9C,IACPpS,YAAaiT,EAAUb,KACvB3W,MAAO2W,IACP2C,MAAO9B,EAAUb,OAEf+C,GAAiBtC,GAAQ,UAAW,CACtCtD,SAAU+C,KAER8C,GAAevC,GAAQ,QAAS,CAClCwC,IAAKrJ,KACLsJ,IAAKrC,EAAUb,OAEbmD,GAAa1C,GAAQ,OAAQ,CAC/B2C,KAAMpD,IACN7C,SAAUA,GAAS,CAAC4E,GAAkB/B,QAEpCqD,GAAc5C,GAAQ,OAAQ,CAChCtD,SAAUA,GAAS,CAAC6C,IAAY6B,GAAYC,GAAcqB,KAC1Dd,UAAWxB,EACTrH,GAAU,CAAC9L,GAAQ,SAAUA,GAAQ,UAAWA,GAAQ,YAGxD4V,GAAqB9J,GAAU,CACjC6J,GACAxB,GACAC,GACAqB,GACAH,GACAxC,MAEE+C,GAAuB/J,GAAU,CACnC6J,GACAxB,GACAC,GACAqB,GACAnD,MAEEwD,GAAgB/C,GAAQ,UAAW,CACrCtD,SAAUoD,EAAU+C,IACpBG,QAASF,KAEPG,GAAajD,GAAQ,MAAO,CAC9B7D,MAAOoD,IACP7C,SAAU3D,GAAU,CAACwI,GAAgBgB,GAAcK,GAAaX,KAChE3G,QAAS8E,EACPrH,GAAU,CAAC9L,GAAQ,WAAYA,GAAQ,WAAYA,GAAQ,eAE7DiW,QAAS9C,EAAUb,OAEjB4D,GAAiBnD,GAAQ,WACzBmB,GAAiBzI,GAAW,CAC9B6I,GACAH,GACAM,GACAvB,GACA4B,GACAC,GACAtB,GACAC,GACAO,GACAoB,GACA9B,GACA+B,GACAlB,GACAqB,GACAO,GACAE,GACAP,GACAG,GACAzC,GACA6B,KAEEiB,GAAuBrK,GAAU,CACnCoI,GACAW,KAEqBpJ,GAAW,CAChCyH,GACAK,GACAG,GACAM,GACAC,GACAE,GACAC,GACAE,GACAG,GACAK,GACAC,GACAM,GACAC,GACAG,GACAO,GACAE,GACAP,GACAlC,GACAD,GACAwB,GACAc,GACAzC,GACAuB,GACAC,GACAK,KAIF,IAAIkB,GAAcC,EAAO,CAACzE,GAAY0E,IAAYC,MAC9CC,GAAkBC,EAAQH,IAAYI,EAAUN,KACzBK,EACzBH,IACAD,EAAO,CAACG,GAAiBE,EAAUN,OAENC,EAAO,CACpClF,GACAgF,KAE2BM,EAAQH,IAAYK,wBC5jCAC,OAASC,cACxD,GACO,UADCA,EAAQ3R,OAEZ,MAAO,qBAGP,MAAM,IAAIkH,GAAoB,CAAElH,OAAQ2R,EAAQ3R,QACpD"}